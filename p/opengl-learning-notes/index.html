<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="在windows平台下使用OpenGL">
<title>OpenGL学习随笔</title>

<link rel='canonical' href='https://Liyufei1.github.io/p/opengl-learning-notes/'>

<link rel="stylesheet" href="/scss/style.min.b0e76e98cdd4f7082d1fc36f7af7e0843a81201db2197c03ca426751dc923735.css"><meta property='og:title' content="OpenGL学习随笔">
<meta property='og:description' content="在windows平台下使用OpenGL">
<meta property='og:url' content='https://Liyufei1.github.io/p/opengl-learning-notes/'>
<meta property='og:site_name' content='李宇飞-Liyufei1'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2026-01-05T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2026-01-05T00:00:00&#43;00:00'/><meta property='og:image' content='https://Liyufei1.github.io/OpenGL.png' />
<meta name="twitter:title" content="OpenGL学习随笔">
<meta name="twitter:description" content="在windows平台下使用OpenGL"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://Liyufei1.github.io/OpenGL.png' />
    <link rel="shortcut icon" href="/favicon.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/guidao1Icon_hu_4c95e88ebc9c8e46.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🤣</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">李宇飞-Liyufei1</a></h1>
            <h2 class="site-description">存放学习随笔的个人博客,主要有:Godot、Unreal、Blog、Cpp.
 下方是个人的b站、gitbug链接:</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://space.bilibili.com/7531504?spm_id_from=333.1007.0.0'
                        target="_blank"
                        title="Bilibili"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-bilibili"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 10a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v6a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4v-6z" /><path d="M8 3l2 3" /><path d="M16 3l-2 3" /><path d="M9 13v-2" /><path d="M15 11v2" /></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/Liyufei1'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="https://Liyufei1.github.io/en/" >English</option>
                                
                                    <option value="https://Liyufei1.github.io/" selected>中文</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#依赖库">依赖库</a>
      <ol>
        <li><a href="#glfw">GLFW</a></li>
        <li><a href="#glad">GLAD</a></li>
      </ol>
    </li>
    <li><a href="#窗口搭建">窗口搭建</a></li>
  </ol>

  <ol>
    <li><a href="#零杂项">零、杂项</a>
      <ol>
        <li><a href="#1glenable">1、glEnable</a></li>
      </ol>
    </li>
    <li><a href="#一内存相关接口">一、内存相关接口</a>
      <ol>
        <li>
          <ol>
            <li><a href="#0常用示例">0、常用示例</a></li>
            <li><a href="#1glgenbuffers">1、glGenBuffers</a></li>
            <li><a href="#2glbindbuffer">2、glBindBuffer</a></li>
            <li><a href="#3glbufferdata">3、glBufferData</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#二着色器">二、着色器</a>
      <ol>
        <li>
          <ol>
            <li><a href="#0代码示例">0、代码示例</a></li>
            <li><a href="#1glcreateshader">1、glCreateShader</a></li>
            <li><a href="#2glshadersource">2、glShaderSource</a></li>
            <li><a href="#4glcompileshader">4、glCompileShader</a></li>
            <li><a href="#5glgetshaderiv">5、glGetShaderiv</a></li>
            <li><a href="#6glgetshaderinfolog">6、glGetShaderInfoLog</a></li>
            <li><a href="#7gldeleteshader">7、glDeleteShader</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#三着色器程序">三、着色器程序</a>
      <ol>
        <li>
          <ol>
            <li><a href="#0代码示例-1">0、代码示例</a></li>
            <li><a href="#1glcreateprogram">1、glCreateProgram</a></li>
            <li><a href="#2glattachshader">2、glAttachShader</a></li>
            <li><a href="#3gllinkprogram">3、glLinkProgram</a></li>
            <li><a href="#4glgetprogramiv">4、glGetProgramiv</a></li>
            <li><a href="#5glgetprograminfolog">5、glGetProgramInfoLog</a></li>
            <li><a href="#6gluseprogram">6、glUseProgram</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#四缓存">四、缓存</a>
      <ol>
        <li>
          <ol>
            <li><a href="#0示例代码">0.示例代码</a></li>
            <li><a href="#1-glvertexattribpointer">1. glVertexAttribPointer</a></li>
            <li><a href="#2glenablevertexattribarray">2.glEnableVertexAttribArray</a></li>
            <li><a href="#3glgenbuffers">3.glGenBuffers</a></li>
            <li><a href="#4glbindbuffer">4.glBindBuffer</a></li>
            <li><a href="#5glgenvertexarrays">5.glGenVertexArrays</a></li>
            <li><a href="#6glbindvertexarray">6.glBindVertexArray</a></li>
            <li><a href="#7glbufferdata">7.glBufferData</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#五绘制">五、绘制</a>
      <ol>
        <li>
          <ol>
            <li><a href="#0示例代码-1">0.示例代码</a></li>
            <li><a href="#1gldrawelements">1.glDrawElements</a></li>
            <li><a href="#2-gluniform1f">2. glUniform1f</a></li>
            <li><a href="#3-gluniform3f">3. glUniform3f</a></li>
            <li><a href="#4-gluniform3fv">4. glUniform3fv</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#六纹理">六、纹理</a>
      <ol>
        <li><a href="#0代码示例-2">0.代码示例</a></li>
        <li><a href="#1-gltexparameteri">1. glTexParameteri</a></li>
        <li><a href="#2gltexparameterfv">2.glTexParameterfv</a></li>
        <li><a href="#3glgentextures">3.glGenTextures</a></li>
        <li><a href="#4glteximage2d">4.glTexImage2D</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#一坐标空间">一、坐标空间</a>
      <ol>
        <li><a href="#0glm的实现">0、GLM的实现</a></li>
        <li><a href="#1简介">1、简介</a></li>
        <li><a href="#2局部空间模型矩阵">2、局部空间（模型矩阵）</a></li>
        <li><a href="#3摄像机视口矩阵">3、摄像机（视口矩阵）</a>
          <ol>
            <li><a href="#1摄像机位置">（1）摄像机位置</a></li>
            <li><a href="#2摄像机方向">（2）摄像机方向</a></li>
            <li><a href="#3摄像机的右轴和上轴">（3）摄像机的右轴和上轴</a></li>
            <li><a href="#4lookat矩阵">（4）LookAt矩阵</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#二光照">二、光照</a>
      <ol>
        <li><a href="#1布林恩-冯模型">1、布林恩-冯模型</a></li>
        <li><a href="#2直接光源">2、直接光源</a></li>
        <li><a href="#3点光源">3、点光源</a></li>
        <li><a href="#4聚光灯">4、聚光灯</a></li>
      </ol>
    </li>
    <li><a href="#三材质">三、材质</a></li>
  </ol>

  <ol>
    <li><a href="#零简单的示例">零、简单的示例</a></li>
    <li><a href="#一着色器关键字">一、着色器关键字</a></li>
    <li><a href="#二变量">二、变量</a></li>
    <li><a href="#三函数">三、函数</a></li>
    <li><a href="#四常用函数">四、常用函数</a>
      <ol>
        <li><a href="#一深度打包函数">一、深度打包函数</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#一stb_image">一、stb_image</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/opengl-learning-notes/">
                
                    <img src="/OpenGL.png" loading="lazy" alt="Featured image of post OpenGL学习随笔" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/opengl/" >
                OpenGL
            </a>
        
            <a href="/categories/render/" >
                Render
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/opengl-learning-notes/">OpenGL学习随笔</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            在windows平台下使用OpenGL
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published" datetime='2026-01-05T00:00:00Z'>2026-01-05</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 34 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="环境搭建">环境搭建
</h1><h2 id="依赖库">依赖库
</h2><h3 id="glfw">GLFW
</h3><p>GLFW（OpenGL FrameWork）是一个专门为 OpenGL 和 Vulkan 设计的开源、跨平台的窗口和输入库。它提供了一组简单、直观的 API，用于创建窗口、处理输入（键盘、鼠标、游戏手柄）以及管理 OpenGL 上下文。</p>
<p><strong>主要特性：</strong></p>
<ul>
<li><strong>跨平台支持</strong>：支持 Windows、macOS、Linux、FreeBSD 和其他类 Unix 系统</li>
<li><strong>OpenGL 上下文管理</strong>：支持创建和管理 OpenGL 上下文，包括核心模式和兼容模式</li>
<li><strong>窗口管理</strong>：提供窗口创建、调整大小、位置控制等功能</li>
<li><strong>输入处理</strong>：支持键盘、鼠标、游戏手柄等多种输入设备</li>
<li><strong>事件驱动</strong>：采用回调机制处理窗口事件、输入事件等</li>
<li><strong>时间管理</strong>：提供高精度的时间查询功能</li>
<li><strong>多显示器支持</strong>：支持多显示器环境下的窗口管理</li>
</ul>
<p>与其他窗口库（如 GLUT、SDL）相比，GLFW 更加轻量级，专注于提供 OpenGL 开发所需的核心功能，API 设计简洁，易于使用。它不提供渲染功能，只负责窗口和输入管理，让开发者可以完全专注于 OpenGL 的图形编程。</p>
<p><strong>接口</strong></p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数</th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>glfwInit()</td>
          <td>初始化 GLFW 库，必须在调用其他 GLFW 函数之前调用。成功返回 <code>GLFW_TRUE</code>，失败返回 <code>GLFW_FALSE</code></td>
      </tr>
      <tr>
          <td>glfwWindowHint()</td>
          <td>设置窗口创建提示，用于配置窗口的属性（如 OpenGL 版本、窗口模式、采样数等）。必须在 glfwCreateWindow 之前调用</td>
      </tr>
      <tr>
          <td>glfwCreateWindow()</td>
          <td>创建窗口和 OpenGL 上下文。返回窗口指针，失败返回 <code>NULL</code>。参数包括宽度、高度、窗口标题、监视器和共享上下文</td>
      </tr>
      <tr>
          <td>glfwMakeContextCurrent()</td>
          <td>将指定窗口的 OpenGL 上下文设为当前上下文。必须在调用 OpenGL 函数之前调用，确保 OpenGL 操作作用于正确的窗口</td>
      </tr>
      <tr>
          <td>glfwSetFramebufferSizeCallback()</td>
          <td>注册帧缓冲大小改变的回调函数。当窗口大小改变时，自动调用该函数，用于更新视口大小等操作</td>
      </tr>
      <tr>
          <td>glfwSetInputMode()</td>
          <td>设置输入模式。常用配置包括光标模式（正常、隐藏、禁用）、粘滞按键模式等</td>
      </tr>
      <tr>
          <td>glfwSetCursorPosCallback()</td>
          <td>注册光标位置改变的回调函数。当光标移动时，自动调用该函数，传入光标的屏幕坐标</td>
      </tr>
      <tr>
          <td>glfwSetScrollCallback()</td>
          <td>注册滚动事件的回调函数。当鼠标滚轮滚动时，自动调用该函数，传入滚动偏移量</td>
      </tr>
      <tr>
          <td>glfwWindowShouldClose()</td>
          <td>检查窗口是否应该关闭。当用户点击关闭按钮或调用 glfwSetWindowShouldClose 时返回 <code>GLFW_TRUE</code></td>
      </tr>
      <tr>
          <td>glfwSwapBuffers()</td>
          <td>交换颜色缓冲区。使用双缓冲机制，将渲染好的图像显示到屏幕上，避免闪烁</td>
      </tr>
      <tr>
          <td>glfwPollEvents()</td>
          <td>处理所有待处理事件。包括键盘输入、鼠标移动、窗口调整大小等。必须在渲染循环中调用</td>
      </tr>
      <tr>
          <td>glfwTerminate()</td>
          <td>终止 GLFW 库，释放所有分配的资源。在程序退出前调用，清理 GLFW 相关的所有资源</td>
      </tr>
      <tr>
          <td>glfwGetTime()</td>
          <td>获取自 glfwInit 被调用以来的时间，单位为秒。返回高精度的双精度浮点数，用于动画和计时</td>
      </tr>
  </tbody>
</table></div>
<h3 id="glad">GLAD
</h3><p>对OpenGL的接口封装。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 定义函数原型
</span></span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">GL_GENBUFFERS</span><span class="p">)</span> <span class="p">(</span><span class="n">GLsizei</span><span class="p">,</span> <span class="n">GLuint</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 找到正确的函数并赋值给函数指针
</span></span></span><span class="line"><span class="cl"><span class="n">GL_GENBUFFERS</span> <span class="n">glGenBuffers</span>  <span class="o">=</span> <span class="p">(</span><span class="n">GL_GENBUFFERS</span><span class="p">)</span><span class="nf">wglGetProcAddress</span><span class="p">(</span><span class="s">&#34;glGenBuffers&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 现在函数可以被正常调用了
</span></span></span><span class="line"><span class="cl"><span class="n">GLuint</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="窗口搭建">窗口搭建
</h2><p>下方是使用GLFW创建窗口的最简示例代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;glad/glad.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;GLFW/glfw3.h&gt;</span><span class="cp">	
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//初始化GLFW
</span></span></span><span class="line"><span class="cl"><span class="n">glfwInit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//设置主要和次要版本,本文档使用3.3版本OpenGL的核心模式
</span></span></span><span class="line"><span class="cl"><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_PROFILE</span><span class="p">,</span><span class="n">GLFW_OPENGL_CORE_PROFILE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//新建一个窗口
</span></span></span><span class="line"><span class="cl"><span class="n">GLFWwindow</span> <span class="o">*</span> <span class="n">MyWindows</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span><span class="mi">600</span><span class="p">,</span><span class="s">&#34;Title&#34;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">MyWindows</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Create Windows Failed!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">glfwTerminate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//创建上下文关联
</span></span></span><span class="line"><span class="cl"><span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">MyWindows</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//初始化GLAD，用于管理OpenGL的函数指针
</span></span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gladLoadGLLoader</span><span class="p">((</span><span class="n">GLADloadproc</span><span class="p">)</span><span class="n">glfwGetProcAddress</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed to initiallize GLAD &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//设置视口,左下角位置为(0,0),宽800，高600
</span></span></span><span class="line"><span class="cl"><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">800</span><span class="p">,</span><span class="mi">600</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_PROGRAM_POINT_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//注册监听
</span></span></span><span class="line"><span class="cl"><span class="n">glfwSetFramebufferSizeCallback</span><span class="p">(</span><span class="n">MyWindows</span><span class="p">,</span><span class="n">FrameBufferSizeCallback</span><span class="p">);</span><span class="c1">//监听函数（1）定义在下方
</span></span></span><span class="line"><span class="cl">    <span class="c1">//渲染循环
</span></span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">MyWindows</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//~Input Begin
</span></span></span><span class="line"><span class="cl">    <span class="n">ProcessInput</span><span class="p">(</span><span class="n">MyWindows</span><span class="p">);</span><span class="c1">//输入函数（2）
</span></span></span><span class="line"><span class="cl">    <span class="c1">//~Input End
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//~Render command Begin
</span></span></span><span class="line"><span class="cl">    <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.4f</span><span class="p">,</span><span class="mf">0.9f</span><span class="p">,</span><span class="mf">0.8f</span><span class="p">,</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//~Render command End
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//检查并调用事件，交换缓冲
</span></span></span><span class="line"><span class="cl">    <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">MyWindows</span><span class="p">);</span><span class="c1">//采用双缓存机制，保证帧与帧之间不会闪烁
</span></span></span><span class="line"><span class="cl">    <span class="n">glfwPollEvents</span><span class="p">();</span><span class="c1">//检测事件输入：键盘输入、鼠标点击、Window缩放等,并更新Window
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">glfwTerminate</span><span class="p">();</span><span class="c1">//释放/删除 分配的资源
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>监听函数</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/** When the user changes the size of GlfwWindow , it will change the size of Viewport*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">FrameBufferSizeCallback</span><span class="p">(</span><span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">Window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Height</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">Width</span><span class="p">,</span><span class="n">Height</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>输入函数</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/** When the user press the &#34;ESC&#34; ,quit the Window */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ProcessInput</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">Window</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">Window</span><span class="p">,</span><span class="n">GLFW_KEY_ESCAPE</span><span class="p">)</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">glfwSetWindowShouldClose</span><span class="p">(</span><span class="n">Window</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="opengl">OpenGL
</h1><p>OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。</p>
<h2 id="零杂项">零、杂项
</h2><h3 id="1glenable">1、glEnable
</h3><h2 id="一内存相关接口">一、内存相关接口
</h2><h4 id="0常用示例">0、常用示例
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VBO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="nf">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1glgenbuffers">1、glGenBuffers
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 生成一个或多个缓冲区对象的名称（ID）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该函数会创建一个或多个新的缓冲区对象的标识符（GLuint 类型），这些名称可用于之后的缓冲区绑定和数据传输操作。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 它仅生成名称，不会分配或初始化任何数据，必须与 glBindBuffer 和 glBufferData 搭配使用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param n 指定要生成的缓冲区对象名称的数量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param buffers 指向一个 GLuint 类型的数组，用于存储生成的缓冲区对象名称。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                调用者需要为该数组分配足够的空间（例如 n 个 GLuint）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 生成的缓冲区对象在使用前必须通过 glBindBuffer 绑定到合适的目标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *       若传入的 buffers 数组无效或未分配，可能导致未定义行为。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glBindBuffer, glBufferData, glDeleteBuffers
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glGenBuffers</span><span class="p">(</span><span class="n">GLsizei</span> <span class="n">n</span><span class="p">,</span> <span class="n">GLuint</span> <span class="o">*</span><span class="n">buffers</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2glbindbuffer">2、glBindBuffer
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 绑定一个命名的缓冲区对象到指定的缓冲区目标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该函数将指定的缓冲区对象绑定到给定的缓冲区目标上，使得后续对该目标的缓冲区操作（如数据分配或更新）会作用于此缓冲区对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果传入的 buffer 为 0，则会解绑当前绑定的缓冲区对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param target 指定要绑定的缓冲区目标。常用的目标包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_ARRAY_BUFFER：用于顶点属性数据（VBO）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_ELEMENT_ARRAY_BUFFER：用于索引数据（EBO/IBO）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_UNIFORM_BUFFER、GL_SHADER_STORAGE_BUFFER 等高级用途
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param buffer 要绑定的缓冲区对象的名称（ID），由 glGenBuffers 生成。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               如果设置为 0，表示解绑当前目标的缓冲区对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 每个缓冲区目标在任意时刻只能绑定一个缓冲区对象。绑定之后，所有对该目标的操作都作用于当前绑定的对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glGenBuffers, glBufferData, glDeleteBuffers
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glBindBuffer</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">target</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">buffer</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="3glbufferdata">3、glBufferData
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 向当前绑定的缓冲区对象分配内存并可选地传入数据。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该函数用于为当前绑定到指定目标的缓冲区对象分配存储空间，并可将指定的数据复制到缓冲区中。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 它通常在 glGenBuffers 和 glBindBuffer 之后调用，用于初始化缓冲区数据。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param target 指定缓冲区对象的目标类型。常用值包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_ARRAY_BUFFER：用于顶点属性数据
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_ELEMENT_ARRAY_BUFFER：用于索引数据
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param size 要分配的缓冲区大小，以字节为单位。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param data 指向包含初始化数据的指针。如果为 NULL，仅分配内存而不初始化数据。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param usage 提示数据的使用方式，帮助 OpenGL 优化性能。常用值包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_STATIC_DRAW：数据将很少更改，主要用于绘制
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_DYNAMIC_DRAW：数据会频繁更改，仍用于绘制
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_STREAM_DRAW：数据每帧都可能更新
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 如果缓冲区已经有数据，此调用会替换原有内容。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glBufferData</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">target</span><span class="p">,</span> <span class="n">GLsizeiptr</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">usage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">eg</span><span class="mf">.1</span>
</span></span><span class="line"><span class="cl">    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="二着色器">二、着色器
</h2><h4 id="0代码示例">0、代码示例
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//eg.1 创建着色器
</span></span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexShader</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">vertexShader</span> <span class="o">=</span> <span class="nf">glCreateShader</span><span class="p">(</span><span class="n">GL_VERTEX_SHADER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">glShaderSource</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vertexShaderSource</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">glCompileShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">GLint</span> <span class="n">success</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glGetShaderiv</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="n">GL_COMPILE_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">infoLog</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glGetShaderInfoLog</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Shader compilation failed:</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//eg.2	着色器程序
</span></span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shaderProgram</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">shaderProgram</span> <span class="o">=</span> <span class="nf">glCreateProgram</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">vertexShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">fragmentShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glLinkProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glGetProgramiv</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">GL_LINK_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glGetProgramInfoLog</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glDeleteShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glDeleteShader</span><span class="p">(</span><span class="n">fragmentShader</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1glcreateshader">1、glCreateShader
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 创建一个着色器对象并返回其 ID。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该函数用于创建一个空的着色器对象。创建后，你需要使用 glShaderSource 提供源代码，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 然后使用 glCompileShader 对其进行编译。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param shaderType 指定要创建的着色器类型。常见的类型包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                   - GL_VERTEX_SHADER：顶点着色器
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                   - GL_FRAGMENT_SHADER：片段（像素）着色器
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                   - GL_GEOMETRY_SHADER：几何着色器（可选）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                   - GL_COMPUTE_SHADER：计算着色器
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                   - GL_TESS_CONTROL_SHADER / GL_TESS_EVALUATION_SHADER：细分着色器（可选）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 返回一个非零的 GLuint 值，表示新创建的着色器对象的 ID。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *         如果返回值为 0，则表示创建失败（可能是因为上下文错误或 shaderType 无效）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 着色器创建后必须手动释放，使用 glDeleteShader 删除不再使用的着色器对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glShaderSource, glCompileShader, glAttachShader, glDeleteShader
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">GLuint</span> <span class="nf">glCreateShader</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">shaderType</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2glshadersource">2、glShaderSource
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将源代码字符串传递给指定的着色器对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该函数用于设置着色器对象的源代码，通常在调用 glCreateShader 创建着色器对象之后使用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 设置完成后，需要使用 glCompileShader 对该着色器进行编译。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param shader 着色器对象的 ID，由 glCreateShader 创建。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param count 源码字符串的数量。如果你只传入一个字符串，可以设置为 1。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param string 包含源代码字符串的指针数组（每个元素是一个 C 风格字符串的指针）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param length 每个字符串的长度数组。可以为 NULL（此时字符串以 null 结尾），
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               否则必须提供一个包含 count 个元素的整型数组，指明每个字符串的长度。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 设置源代码并不会自动编译，需要手动调用 glCompileShader 进行编译。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glCreateShader, glCompileShader, glGetShaderiv, glGetShaderInfoLog
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glShaderSource</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">shader</span><span class="p">,</span> <span class="n">GLsizei</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">GLchar</span> <span class="o">**</span><span class="n">string</span><span class="p">,</span> <span class="k">const</span> <span class="n">GLint</span> <span class="o">*</span><span class="n">length</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="4glcompileshader">4、glCompileShader
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 编译一个着色器对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数用于编译通过 glShaderSource 设置了源代码的着色器对象。编译成功后，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 着色器对象可以被附加到程序对象（Program Object）中。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param shader 要编译的着色器对象 ID，由 glCreateShader 创建，并通过 glShaderSource 设置了源代码。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 编译完成后应使用 glGetShaderiv 和 glGetShaderInfoLog 检查是否编译成功以及获取可能的错误信息。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *       着色器编译失败不会导致 OpenGL 抛出错误，必须手动检查状态。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glCreateShader, glShaderSource, glGetShaderiv, glAttachShader, glLinkProgram
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glCompileShader</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">shader</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="5glgetshaderiv">5、glGetShaderiv
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 获取着色器对象的参数信息。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数用于查询着色器对象的编译状态或其他相关属性。最常用于检测编译是否成功，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 通常在调用 glCompileShader 后立即使用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param shader 要查询的着色器对象 ID，由 glCreateShader 创建。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pname 指定要获取的参数类型。常用值包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_COMPILE_STATUS：编译是否成功（GL_TRUE 或 GL_FALSE）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_SHADER_TYPE：着色器类型（如 GL_VERTEX_SHADER）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_DELETE_STATUS：是否已被标记删除
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_INFO_LOG_LENGTH：信息日志的长度（可用于分配 glGetShaderInfoLog 所需的缓冲区）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param params 指向整数变量的指针，用于接收查询结果。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glCompileShader, glGetShaderInfoLog, glCreateShader, glShaderSource
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glGetShaderiv</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">shader</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">pname</span><span class="p">,</span> <span class="n">GLint</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="6glgetshaderinfolog">6、glGetShaderInfoLog
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 获取着色器编译过程中的信息日志（如错误或警告信息）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数通常在着色器编译失败后调用，用于获取编译错误或警告的详细文本信息。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param shader 要查询的着色器对象 ID，由 glCreateShader 创建并已调用 glCompileShader 编译。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param maxLength 指定 infoLog 缓冲区的最大长度（以字符数计，包括结尾的 null 字符）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param length 可为 NULL，或者指向一个整数的指针，用于接收实际写入 infoLog 的字符串长度（不包含结尾 null）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param infoLog 一个字符数组，用于接收信息日志字符串。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 只有在编译失败或编译时出现警告时，信息日志才可能包含内容。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *       建议在编译后始终调用此函数，以便及时发现潜在问题。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glCompileShader, glGetShaderiv, glCreateShader
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glGetShaderInfoLog</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">shader</span><span class="p">,</span> <span class="n">GLsizei</span> <span class="n">maxLength</span><span class="p">,</span> <span class="n">GLsizei</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">GLchar</span> <span class="o">*</span><span class="n">infoLog</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="7gldeleteshader">7、glDeleteShader
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 删除一个着色器对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数标记一个着色器对象以供删除。当该着色器不再附加到任何程序对象时，它将被真正释放。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param shader 要删除的着色器对象 ID，由 glCreateShader 创建。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 如果该着色器仍然附加到某个程序对象中，它不会立即被删除，而是在分离或删除程序对象后才真正销毁。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 即使着色器已经删除，只要程序仍然链接成功，使用该程序对象依然有效。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 在成功链接后，你通常可以安全地调用 glDeleteShader 释放中间的 shader 资源。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glCreateShader, glAttachShader, glCompileShader, glDeleteProgram
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glDeleteShader</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">shader</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="三着色器程序">三、着色器程序
</h2><h4 id="0代码示例-1">0、代码示例
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//eg.2	着色器程序
</span></span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shaderProgram</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">shaderProgram</span> <span class="o">=</span> <span class="nf">glCreateProgram</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">vertexShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">fragmentShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glLinkProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glGetProgramiv</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">GL_LINK_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">glGetProgramInfoLog</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glDeleteShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">glDeleteShader</span><span class="p">(</span><span class="n">fragmentShader</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1glcreateprogram">1、glCreateProgram
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 创建一个新的程序对象（Program Object）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 程序对象用于将多个着色器（如顶点着色器、片段着色器等）链接在一起，形成一个完整的 GPU 渲染管线。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 创建后，可以通过 glAttachShader 附加已编译的着色器，并使用 glLinkProgram 进行链接。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 返回一个非零的程序对象 ID（GLuint 类型）。如果返回值为 0，表示创建失败。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 创建的程序对象在使用完毕后应通过 glDeleteProgram 释放。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *       必须先链接（glLinkProgram）后才能使用（glUseProgram）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glAttachShader, glLinkProgram, glUseProgram, glDeleteProgram
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">GLuint</span> <span class="nf">glCreateProgram</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2glattachshader">2、glAttachShader
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将一个已编译的着色器对象附加到程序对象上。可以附加多种着色器，但是每种着色器仅支持一个，
</span></span></span><span class="line"><span class="cl"><span class="cm"> *	特别的计算着色器与其他不混用
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm">    glAttachShader(program, vertexShader);       // 顶点着色器
</span></span></span><span class="line"><span class="cl"><span class="cm">    glAttachShader(program, fragmentShader);     // 片段着色器
</span></span></span><span class="line"><span class="cl"><span class="cm">    glAttachShader(program, geometryShader);     // 几何着色器（可选）
</span></span></span><span class="line"><span class="cl"><span class="cm">    glAttachShader(program, tessCtrlShader);     // 曲面细分控制（可选）
</span></span></span><span class="line"><span class="cl"><span class="cm">    glAttachShader(program, tessEvalShader);     // 曲面细分评估（可选）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数用于将已经编译成功的着色器附加到一个 OpenGL 程序对象（program object）中。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 一个程序可以附加多个不同类型的着色器（例如顶点和片段着色器），在链接程序时将它们组合成一个完整的渲染管线。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param program 要附加着色器的程序对象 ID，由 glCreateProgram 创建。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param shader 要附加的着色器对象 ID，需由 glCreateShader 创建并通过 glCompileShader 编译。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 一个着色器对象可以附加到多个程序对象中。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 必须在 glLinkProgram 之前调用 glAttachShader。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 可以多次调用以附加多个不同类型的着色器。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 调用 glDeleteShader 删除着色器不会立即销毁它，只要它仍然被附加到程序上。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glCreateProgram, glCreateShader, glCompileShader, glLinkProgram, glDetachShader, glDeleteShader
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glAttachShader</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">program</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">shader</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="3gllinkprogram">3、glLinkProgram
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 链接一个程序对象，将附加的着色器组合为一个可执行的 GPU 程序。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数用于将通过 glAttachShader 附加到程序对象的各个着色器进行链接。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 链接成功后，该程序对象可以通过 glUseProgram 启用用于渲染或计算任务。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param program 程序对象的 ID，由 glCreateProgram 创建，且已附加所需的着色器对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 链接前必须附加至少一个着色器对象（通常是顶点和片段着色器）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 链接后可以调用 glGetProgramiv 和 glGetProgramInfoLog 检查是否成功。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 成功链接后，可以分离或删除着色器对象（glDetachShader、glDeleteShader），不会影响程序对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glCreateProgram, glAttachShader, glUseProgram, glGetProgramiv, glGetProgramInfoLog
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glLinkProgram</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">program</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="4glgetprogramiv">4、glGetProgramiv
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 获取程序对象的参数信息（如链接状态、日志长度等）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数用于查询 OpenGL 程序对象的状态或属性，常用于在 glLinkProgram 后检查是否链接成功。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param program 要查询的程序对象 ID，由 glCreateProgram 创建。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pname 指定要获取的参数类型。常用值包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_LINK_STATUS：链接是否成功（GL_TRUE 或 GL_FALSE）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_VALIDATE_STATUS：验证状态是否成功
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_INFO_LOG_LENGTH：信息日志的长度（用于分配 glGetProgramInfoLog 的缓冲区）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_ATTACHED_SHADERS：附加的着色器数量
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_ACTIVE_ATTRIBUTES：活跃的顶点属性数量
</span></span></span><span class="line"><span class="cl"><span class="cm"> *              - GL_ACTIVE_UNIFORMS：活跃的 uniform 数量
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param params 指向整数变量的指针，用于接收查询结果。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 通常与 glGetProgramInfoLog 配合使用，用于在程序链接失败时获取错误信息。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glLinkProgram, glGetProgramInfoLog, glAttachShader
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glGetProgramiv</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">program</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">pname</span><span class="p">,</span> <span class="n">GLint</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="5glgetprograminfolog">5、glGetProgramInfoLog
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 获取程序对象的链接或验证阶段的错误或警告信息日志。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数用于在调用 glLinkProgram 或 glValidateProgram 后获取程序对象的编译/链接日志，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 主要用于调试失败的着色器程序。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param program 要查询的程序对象 ID，由 glCreateProgram 创建。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param maxLength infoLog 缓冲区的最大长度（以字符数为单位，包括结尾 null 字符）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param length 可为 NULL，或者指向整数变量的指针，用于接收写入 infoLog 的实际长度（不包括结尾 null）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param infoLog 接收日志字符串的字符数组（必须由用户分配内存）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 在 glLinkProgram 或 glValidateProgram 之后调用此函数。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 如果程序对象没有信息日志（如链接成功且无警告），返回的 infoLog 可能是空字符串。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glLinkProgram, glValidateProgram, glGetProgramiv
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glGetProgramInfoLog</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">program</span><span class="p">,</span> <span class="n">GLsizei</span> <span class="n">maxLength</span><span class="p">,</span> <span class="n">GLsizei</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">GLchar</span> <span class="o">*</span><span class="n">infoLog</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="6gluseprogram">6、glUseProgram
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 激活指定的程序对象，使其成为当前使用的着色器程序。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数将一个已成功链接的程序对象设为当前 OpenGL 状态下使用的着色器程序，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 后续所有绘图操作将使用该程序中的着色器执行渲染。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param program 程序对象的 ID，由 glCreateProgram 创建并成功链接。如果设置为 0，表示取消当前着色器程序（使用固定功能管线，如果支持）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 程序必须在调用 glLinkProgram 后才能使用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 每次只能激活一个程序对象，重复调用会替换之前的。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 在绘制前必须调用 glUseProgram 激活程序，否则顶点和片段着色器不会生效。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glCreateProgram, glAttachShader, glLinkProgram, glDeleteProgram
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glUseProgram</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">program</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="四缓存">四、缓存
</h2><h4 id="0示例代码">0.示例代码
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VBO</span><span class="p">,</span> <span class="n">VAO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="nf">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1-glvertexattribpointer">1. glVertexAttribPointer
</h4><p><img src="/vertex_attribute_pointer.png"
	
	
	
	loading="lazy"
	
		alt="vertex_attribute_pointer.png"
	
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 定义一个顶点属性数组中单个属性的内存布局。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数用于告诉 OpenGL 如何从当前绑定的顶点缓冲区对象中读取顶点属性（如位置、颜色、法线等）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 它定义了顶点属性在缓冲区中的数据格式和偏移方式。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param index 顶点着色器中输入变量的位置（location），由 layout(location = x) 指定或通过 glGetAttribLocation 查询。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param size 每个顶点属性的数据数量（1~4）。如 vec3 则为 3。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param type 数据类型。常见的有：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *             - GL_FLOAT
</span></span></span><span class="line"><span class="cl"><span class="cm"> *             - GL_INT
</span></span></span><span class="line"><span class="cl"><span class="cm"> *             - GL_UNSIGNED_BYTE 等
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param normalized 指定数据是否在送入着色器前需要归一化（如 GL_UNSIGNED_BYTE 转换为 [0,1]）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                   通常为 GL_FALSE。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param stride 每个顶点的字节间隔（步长）。如果数据是紧密排列的，可以传 0。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pointer 指向第一个顶点属性数据在缓冲区中的偏移量（可以是偏移量值或 (void*)0 表示起始）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 调用前必须绑定一个对应的缓冲区到 `GL_ARRAY_BUFFER`。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 调用后需启用该属性：`glEnableVertexAttribArray(index)`。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 所有配置只影响当前绑定的 VAO（顶点数组对象）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glEnableVertexAttribArray, glDisableVertexAttribArray, glBindBuffer, glVertexAttribDivisor
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glVertexAttribPointer</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">index</span><span class="p">,</span> <span class="n">GLint</span> <span class="n">size</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">type</span><span class="p">,</span> <span class="n">GLboolean</span> <span class="n">normalized</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                           <span class="n">GLsizei</span> <span class="n">stride</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2glenablevertexattribarray">2.glEnableVertexAttribArray
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 启用一个顶点属性数组。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数用于启用通过 glVertexAttribPointer 定义的顶点属性，使其在渲染时被 GPU 使用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 如果没有启用，对应属性即使定义了也不会生效。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param index 顶点属性的位置（location），对应着色器中 layout(location = x) 或 glGetAttribLocation 的返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 顶点属性默认是禁用的，必须手动启用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 启用后，GPU 会从绑定的 VBO 中按 glVertexAttribPointer 定义读取该属性。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 绑定的 VAO 会记录该状态，因此建议在设置 VAO 时启用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glVertexAttribPointer, glDisableVertexAttribArray, glBindVertexArray
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">index</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="3glgenbuffers">3.glGenBuffers
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 生成一个或多个缓冲区对象名称（ID）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 该函数用于创建一个或多个新的 OpenGL 缓冲区对象标识符（名称），这些对象可用于存储顶点数据、
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 索引数据、统一变量等。生成的名称可用于后续的 glBindBuffer 和 glBufferData 等操作。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param n 要生成的缓冲区对象数量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param buffers 指向 GLuint 数组的指针，用于存储生成的缓冲区对象名称。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                调用者必须预先为该数组分配至少 n 个元素的空间。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 此函数只分配名称（ID），不分配 GPU 内存。必须通过 glBindBuffer + glBufferData 才能真正使用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 创建后可使用 glDeleteBuffers 删除对象，释放资源。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glBindBuffer, glBufferData, glDeleteBuffers
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glGenBuffers</span><span class="p">(</span><span class="n">GLsizei</span> <span class="n">n</span><span class="p">,</span> <span class="n">GLuint</span> <span class="o">*</span><span class="n">buffers</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="4glbindbuffer">4.glBindBuffer
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 将一个缓冲区对象绑定到指定的缓冲区目标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数将给定的缓冲区对象 ID 绑定到指定目标，使其成为当前活跃的缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 后续对该目标的操作（如 glBufferData、glVertexAttribPointer）将作用于此绑定对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param target 指定要绑定的缓冲区目标。常见目标包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_ARRAY_BUFFER：顶点缓冲对象（VBO）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_ELEMENT_ARRAY_BUFFER：索引缓冲对象（EBO/IBO）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_UNIFORM_BUFFER：统一变量缓冲区
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_SHADER_STORAGE_BUFFER：着色器存储缓冲区
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param buffer 要绑定的缓冲区对象 ID，由 glGenBuffers 创建。如果为 0，则解绑当前目标的缓冲区对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 每个缓冲区目标在任一时刻只能绑定一个缓冲区对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 调用 glBindBuffer 后的所有缓冲区操作将作用于当前绑定的目标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - VAO（顶点数组对象）会记录对 GL_ARRAY_BUFFER 和 GL_ELEMENT_ARRAY_BUFFER 的绑定状态。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glGenBuffers, glBufferData, glDeleteBuffers, glBindVertexArray
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glBindBuffer</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">target</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">buffer</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="5glgenvertexarrays">5.glGenVertexArrays
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 生成一个或多个顶点数组对象（VAO）的名称（ID）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 顶点数组对象用于封装所有与顶点输入有关的状态，包括顶点属性指针（如位置、颜色、法线等）、
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 顶点缓冲绑定和索引缓冲绑定等。使用 VAO 可以简化绘制调用，并提高渲染效率。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param n 要生成的 VAO 数量。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param arrays 指向 GLuint 数组的指针，用于存储生成的 VAO 名称。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 生成的 VAO 名称本身没有分配实际资源，只有在绑定并配置时才真正记录状态。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 每次绘制前应绑定对应的 VAO。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - VAO 的状态包括：glVertexAttribPointer 设置、glEnableVertexAttribArray 状态、绑定的 VBO 和 EBO。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glBindVertexArray, glDeleteVertexArrays, glVertexAttribPointer, glEnableVertexAttribArray
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glGenVertexArrays</span><span class="p">(</span><span class="n">GLsizei</span> <span class="n">n</span><span class="p">,</span> <span class="n">GLuint</span> <span class="o">*</span><span class="n">arrays</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="6glbindvertexarray">6.glBindVertexArray
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 绑定一个顶点数组对象（VAO）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数将指定的顶点数组对象绑定为当前使用的 VAO。绑定后，所有与顶点输入相关的状态设置（如属性指针、启用状态、缓冲区绑定等）将记录在此 VAO 中。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param array 要绑定的 VAO 的 ID，由 glGenVertexArrays 生成。传入 0 表示解绑当前 VAO。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - VAO 会记录：glVertexAttribPointer 设置、glEnableVertexAttribArray 状态、当前绑定的 GL_ARRAY_BUFFER 和 GL_ELEMENT_ARRAY_BUFFER。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 绘图前必须绑定正确的 VAO。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - VAO 状态与绑定缓冲区对象是绑定在一起的，必须在绑定 VAO 后设置缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glGenVertexArrays, glVertexAttribPointer, glEnableVertexAttribArray, glDrawArrays, glDrawElements
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glBindVertexArray</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">array</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="7glbufferdata">7.glBufferData
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 创建并初始化缓冲区对象的数据存储。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 此函数为当前绑定的缓冲区对象（如 GL_ARRAY_BUFFER 或 GL_ELEMENT_ARRAY_BUFFER）分配内存，并可以选择性地初始化数据。它是设置顶点数据或索引数据的关键步骤。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param target 指定要操作的缓冲区类型，常用值有 GL_ARRAY_BUFFER、GL_ELEMENT_ARRAY_BUFFER、GL_UNIFORM_BUFFER 等。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param size 分配的内存大小（以字节为单位）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param data 指向要复制到缓冲区的数据指针，传入 NULL 表示只分配内存不初始化。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param usage 指定缓冲区的预期用途模式，例如 GL_STATIC_DRAW、GL_DYNAMIC_DRAW、GL_STREAM_DRAW。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 此函数会使之前缓冲区中的内容失效（即使大小不变）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - `usage` 参数不会影响渲染结果，仅用于驱动优化内存管理。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 使用前应绑定对应的缓冲区目标；绑定点由 `target` 参数指定。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 若要更新已有缓冲数据的局部内容，应使用 glBufferSubData。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glGenBuffers, glBindBuffer, glBufferSubData, glDeleteBuffers
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glBufferData</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">target</span><span class="p">,</span> <span class="n">GLsizeiptr</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">usage</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="五绘制">五、绘制
</h2><h4 id="0示例代码-1">0.示例代码
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// ------------------------------------------------------------------
</span></span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// top right
</span></span></span><span class="line"><span class="cl">         <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// bottom right
</span></span></span><span class="line"><span class="cl">        <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// bottom left
</span></span></span><span class="line"><span class="cl">        <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span>   <span class="c1">// top left 
</span></span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">indices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1">// note that we start from 0!
</span></span></span><span class="line"><span class="cl">        <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>  <span class="c1">// first Triangle
</span></span></span><span class="line"><span class="cl">        <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>   <span class="c1">// second Triangle
</span></span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VBO</span><span class="p">,</span> <span class="n">VAO</span><span class="p">,</span> <span class="n">EBO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EBO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="n">processInput</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="c1">// draw our first triangle
</span></span></span><span class="line"><span class="cl">     <span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">glfwPollEvents</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1gldrawelements">1.glDrawElements
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 使用索引数组渲染图元（基于索引的绘制）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * glDrawElements 根据当前绑定的顶点数组对象（VAO）和索引缓冲对象（EBO）中的索引，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 从已绑定的顶点缓冲对象（VBO）中读取顶点数据，并按指定的绘制模式渲染图元。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param mode   指定要渲染的图元类型。可选值包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_POINTS
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - 以及其他从 OpenGL 扩展中支持的模式。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param count  指定将要渲染的索引数量（元素数量），即索引数组中元素的个数。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param type   指定索引数组中每个索引的数据类型。可选值为：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_UNSIGNED_BYTE
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_UNSIGNED_SHORT
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_UNSIGNED_INT
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               （注意：部分旧版硬件可能不支持 32 位无符号整型索引）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param indices 指定索引数据的偏移量或指针：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - 当已绑定 GL_ELEMENT_ARRAY_BUFFER（EBO）时，此参数被视为字节偏移量（const void* offset）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - 若未绑定 EBO，则此参数为指向客户端内存中索引数组的指针（已废弃，现代 OpenGL 建议使用 EBO）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 渲染前必须绑定相应的 VAO，并确保该 VAO 已记录了正确的顶点属性和 EBO 绑定状态。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 索引读取的位置基于当前绑定的 GL_ELEMENT_ARRAY_BUFFER 对象，并受 type 参数指定的字节大小影响。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 如果 indices 为非零指针且未绑定 EBO，则索引数据会从客户端内存读取，但此用法在核心模式下已不推荐。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - glDrawElements 是一次性绘制，若需多实例绘制，请使用 glDrawElementsInstanced。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 绘制完成后，OpenGL 会根据当前上下文状态（剔除、深度测试、混合等）对图元进行处理。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glDrawArrays, glDrawElementsInstanced, glBindBuffer, glBindVertexArray
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glDrawElements</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">mode</span><span class="p">,</span><span class="n">GLsizei</span> <span class="n">count</span><span class="p">,</span><span class="n">GLenum</span> <span class="n">type</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">indices</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2-gluniform1f">2. glUniform1f
</h4><p>设置单个浮点数 uniform 变量的值。</p>
<h4 id="3-gluniform3f">3. glUniform3f
</h4><p>设置三个浮点数 uniform 变量的值。</p>
<h4 id="4-gluniform3fv">4. glUniform3fv
</h4><p>设置浮点数向量 uniform 变量的值。</p>
<h2 id="六纹理">六、纹理
</h2><p>贴图的UV坐标如下分布：</p>
<p><img src="/image-20250716133044809.png"
	
	
	
	loading="lazy"
	
		alt="image-20250716133044809.png"
	
	
></p>
<h3 id="0代码示例-2">0.代码示例
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">//创建和绑定
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">mData</span> <span class="o">=</span> <span class="n">stbi_load</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mWidth</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mHeight</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mChannels</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//利用stb_image读取图片
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mTextureID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mTextureID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//设置环绕方式
</span></span></span><span class="line"><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">mSurroundMode</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">mSurroundMode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//设置滤波方式（采样）
</span></span></span><span class="line"><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">mFilterMode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">mFilterMode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//绑定原始数据
</span></span></span><span class="line"><span class="cl"><span class="k">switch</span> <span class="p">(</span><span class="n">mChannels</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">mWidth</span><span class="p">,</span> <span class="n">mHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">mData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">4</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">mWidth</span><span class="p">,</span> <span class="n">mHeight</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">mData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//生成mipmap
</span></span></span><span class="line"><span class="cl"><span class="n">glGenerateMipmap</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//使用
</span></span></span><span class="line"><span class="cl"><span class="n">glUniform1i</span><span class="p">(</span><span class="s">&#34;uTexture&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//需要先设置贴图通道
</span></span></span><span class="line"><span class="cl"><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">mTextureID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">mVAO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="n">mMeshBatch</span><span class="p">.</span><span class="n">indexs</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="1-gltexparameteri">1. glTexParameteri
</h3><p>image-20250716134350990.png</p>
<p>image-20250716133617973</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 设置纹理对象的参数属性（如过滤方式和环绕模式）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * glTexParameteri 用于为当前绑定的纹理对象指定特定的行为参数，常用于定义纹理在缩放、
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 环绕等情况下的表现方式。该函数只适用于绑定到当前激活纹理目标的纹理对象。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param target 指定纹理目标类型。可选值包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_1D
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_2D
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_3D
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_CUBE_MAP
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - 以及其他 OpenGL 扩展支持的目标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pname  指定要设置的纹理参数名。常用值包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_MIN_FILTER：纹理缩小时的过滤方式
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_MAG_FILTER：纹理放大时的过滤方式
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_WRAP_S：纹理在 S（U）轴的环绕模式
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_WRAP_T：纹理在 T（V）轴的环绕模式
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_WRAP_R：纹理在 R（W）轴的环绕模式（仅适用于 3D/立方体贴图）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param param  指定 pname 所对应的参数值。取值依赖于 pname 的类型：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - 过滤方式常用值：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                 - GL_NEAREST：最近点采样
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                 - GL_LINEAR：线性插值采样
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                 - GL_NEAREST_MIPMAP_NEAREST / GL_LINEAR_MIPMAP_LINEAR 等（用于 mipmap）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - 环绕模式常用值：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                 - GL_REPEAT：重复纹理
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                 - GL_CLAMP_TO_EDGE：边缘钳制
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                 - GL_MIRRORED_REPEAT：镜像重复
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - glTexParameteri 必须在绑定了相应纹理（通过 glBindTexture）之后调用，否则无效。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 对于 mipmap 过滤方式，需要使用 glGenerateMipmap 或手动指定每级 mipmap 层。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 若未设置合适的过滤和环绕模式，可能会导致纹理显示异常或性能下降。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 纹理参数是纹理对象状态的一部分，一旦设置便会被该纹理一直使用，除非再次修改。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glTexParameterf, glBindTexture, glTexImage2D, glGenerateMipmap
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glTexParameteri</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">target</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">pname</span><span class="p">,</span> <span class="n">GLint</span> <span class="n">param</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="2gltexparameterfv">2.glTexParameterfv
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 设置纹理对象的参数属性（以浮点数组形式传入）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * glTexParameterfv 用于为当前绑定的纹理对象指定某个纹理参数，其值通过一个浮点数组传入。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 适用于参数值为浮点向量类型的纹理属性（如边界颜色等）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param target 指定纹理目标类型。可选值包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_1D
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_2D
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_3D
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_CUBE_MAP
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - 以及其他 OpenGL 扩展支持的目标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param pname  指定要设置的纹理参数名。常用值包括：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - GL_TEXTURE_BORDER_COLOR：纹理边界颜色（需传入4个float）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - 其他接受浮点数组作为参数的扩展参数
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param params 指向浮点值数组的指针，其内容依赖于 pname 的要求：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - 若 pname 为 GL_TEXTURE_BORDER_COLOR，则应提供 4 个元素的 RGBA 数组（例如：{1.0f, 1.0f, 1.0f, 1.0f}）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *               - 其他 pname 可根据具体 OpenGL 扩展需求设置对应数量的 float。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - glTexParameterfv 与 glTexParameteri 用法类似，但参数类型为浮点数组。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 在设置 GL_TEXTURE_BORDER_COLOR 时，纹理环绕模式需配合 GL_CLAMP_TO_BORDER 使用才能生效。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 请确保已正确绑定纹理对象，否则调用将不会产生效果。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 不支持的 pname 值可能在不同硬件或 OpenGL 版本下导致行为未定义。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glTexParameteri, glTexParameterf, glBindTexture, glTexImage2D, glTexParameteriv
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glTexParameterfv</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">target</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">pname</span><span class="p">,</span> <span class="k">const</span> <span class="n">GLfloat</span> <span class="o">*</span><span class="n">params</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3glgentextures">3.glGenTextures
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 生成一个或多个新的纹理对象名称。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * glGenTextures 用于请求 OpenGL 创建一个或多个唯一的纹理对象 ID（名称），这些纹理对象
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 可通过 glBindTexture 绑定并进一步配置。生成的纹理对象尚未初始化，需通过绑定后使用。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param n      指定要生成的纹理对象名称数量（即纹理数量）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param textures 指向 GLuint 类型数组的指针，用于接收生成的纹理名称（ID）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                 - 该数组的大小应至少为 n。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                 - 得到的纹理 ID 可通过 glBindTexture 绑定至指定纹理目标。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 生成的纹理对象名称在首次绑定前是“未初始化状态”，OpenGL 不会自动分配存储或属性。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 调用 glGenTextures 只生成名称，不会做任何资源分配，资源分配将在 glTexImage* 发生。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 可以通过 glDeleteTextures 删除不再使用的纹理对象，释放资源。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 不应在未初始化的纹理对象上调用渲染操作，否则结果未定义。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glBindTexture, glDeleteTextures, glTexImage2D, glTexParameteri
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glGenTextures</span><span class="p">(</span><span class="n">GLsizei</span> <span class="n">n</span><span class="p">,</span> <span class="n">GLuint</span> <span class="o">*</span><span class="n">textures</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4glteximage2d">4.glTexImage2D
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief 为当前绑定的二维纹理对象指定二维像素图像数据。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * glTexImage2D 用于向当前绑定到 target 的二维纹理对象上传图像数据，
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 并为该纹理分配存储空间。可用于初始化纹理或替换指定 mipmap 级别的数据。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param target         指定纹理目标类型。常用值：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                       - GL_TEXTURE_2D
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                       - GL_PROXY_TEXTURE_2D（仅用于查询纹理规格，不分配内存）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                       - GL_TEXTURE_CUBE_MAP_POSITIVE_X 等立方体贴图面（若用二维调用）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param level          指定 mipmap 级别。0 为基准级（最高分辨率），n 为第 n 级 mipmap。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param internalFormat 指定纹理在 GPU 中的内部存储格式，例如：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                       - GL_RGB, GL_RGBA
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                       - GL_R8, GL_RG16F
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                       - GL_DEPTH_COMPONENT24 等
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param width          指定纹理图像的宽度（像素数），必须为正整数。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param height         指定纹理图像的高度（像素数），对于一维纹理应为 1。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param border         指定边框宽度，必须为 0（核心模式不支持非零边框）。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param format         指定像素数据的布局格式，例如：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                       - GL_RGB, GL_RGBA, GL_RED, GL_DEPTH_COMPONENT 等
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param type           指定像素数据的类型，例如：
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                       - GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_FLOAT 等
</span></span></span><span class="line"><span class="cl"><span class="cm"> *                       （取决于 format 支持的数据类型）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param data           指向客户端内存中图像数据的指针；若为 NULL，则只分配存储，不上传数据。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return 无返回值。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @note
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 调用前必须已绑定纹理对象：glBindTexture(target, texID)。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - internalFormat 与 format/type 组合必须受硬件支持，否则可能产生错误或降级行为。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 若需要创建完整 mipmap 级别，可多次调用 glTexImage2D 上传每个 level，或在上传基准级后调用 glGenerateMipmap。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - GL_PROXY_TEXTURE_2D 可用于测试指定格式/尺寸是否被支持，查询后不分配实际存储。
</span></span></span><span class="line"><span class="cl"><span class="cm"> * - 对于子区域更新，可改用 glTexSubImage2D 以避免重分配存储。
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @see glBindTexture, glTexSubImage2D, glGenerateMipmap, glTexImage3D
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">glTexImage2D</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">target</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">GLint</span> <span class="n">level</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">GLint</span> <span class="n">internalFormat</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">GLsizei</span> <span class="n">width</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">GLsizei</span> <span class="n">height</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">GLint</span> <span class="n">border</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">GLenum</span> <span class="n">format</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">GLenum</span> <span class="n">type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="图形学相关">图形学相关
</h1><h2 id="一坐标空间">一、坐标空间
</h2><h3 id="0glm的实现">0、GLM的实现
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 1、矢量和矩阵的初始化
</span></span></span><span class="line"><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="n">vec</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4x4</span> <span class="n">MView</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 2、变换矩阵
</span></span></span><span class="line"><span class="cl"><span class="c1">// 平移
</span></span></span><span class="line"><span class="cl"><span class="n">Mtrans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">Mtrans</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 缩放
</span></span></span><span class="line"><span class="cl"><span class="n">MScale</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">MScale</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 旋转（欧拉角）
</span></span></span><span class="line"><span class="cl"><span class="n">MRot</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">MRot</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">90.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 转置
</span></span></span><span class="line"><span class="cl"><span class="n">MTranspose</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">transpose</span><span class="p">(</span><span class="n">Mx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 3、模型矩阵
</span></span></span><span class="line"><span class="cl"><span class="n">MModel</span> <span class="o">=</span> <span class="n">MTran</span> <span class="o">*</span> <span class="n">MRota</span><span class="p">;</span> <span class="c1">// 表示在本地坐标系下，模型自身的变换
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 4、观察矩阵
</span></span></span><span class="line"><span class="cl"><span class="n">MView</span> <span class="o">=</span> <span class="n">MrT</span> <span class="o">*</span> <span class="n">M</span><span class="o">-</span><span class="n">t</span><span class="p">;</span> <span class="c1">// 表示摄像机的变换，并将其反变换作用在模型上
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 5、投影透视矩阵
</span></span></span><span class="line"><span class="cl"><span class="n">Mpersp</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">),</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span> <span class="c1">// 投影盒子+透视
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 6、总矩阵
</span></span></span><span class="line"><span class="cl"><span class="n">M</span> <span class="o">=</span> <span class="n">Mpersp</span> <span class="o">*</span> <span class="n">MView</span> <span class="o">*</span> <span class="n">MModel</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="1简介">1、简介
</h3><p>将坐标变换为<strong>标准化设备坐标</strong>，接着再转化为<strong>屏幕坐标</strong>的过程通常是<strong>分步进行</strong>的。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到<strong>多个坐标系统</strong>(Coordinate System)。将物体的坐标变换到几个<strong>过渡坐标系</strong>(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p>
<ul>
<li>局部空间(Local Space，或者称为物体空间(Object Space))</li>
<li>世界空间(World Space)</li>
<li>观察空间(View Space，或者称为视觉空间(Eye Space))</li>
<li>裁剪空间(Clip Space)</li>
<li>屏幕空间(Screen Space)</li>
</ul>
<p>coordinate_systems.png</p>
<p><strong>模型</strong>(Model)、<strong>观察</strong>(View)、<strong>投影</strong>(Projection)三个矩阵
</p>
$$
M_{Total}=M_{Projection}*M_{View}*M_{Model}
$$<h3 id="2局部空间模型矩阵">2、局部空间（模型矩阵）
</h3><ol>
<li>
<p>平移矩阵：$T_{t_x,t_y}=\left( \begin{matrix} 1 &amp; 0 &amp; 0 &amp; t_x \ 0 &amp; 1 &amp; 0&amp; t_y \ 0 &amp; 0 &amp; 1 &amp; t_z \ 0&amp; 0 &amp; 0 &amp; 1 \end{matrix} \right) \tag{3}$</p>
</li>
<li>
<p>旋转矩阵：</p>
<ol>
<li>
<p>绕$\hat z$方向逆时针旋转矩阵:$R_{\theta}=\left( \begin{matrix} \cos \theta &amp; -\sin \theta &amp; 0 &amp; 0 \ \sin \theta &amp; \cos \theta &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0&amp;0&amp;1 \end{matrix} \right) \tag{4}$</p>
</li>
<li>
<p>绕$\hat x$方向逆时针旋转矩阵:$R_{\theta}=\left( \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; \cos \theta &amp; \sin \theta &amp; 0 \ 0 &amp; -\sin \theta &amp; \cos \theta  &amp; 0 \ 0 &amp; 0&amp;0&amp;1 \end{matrix} \right) \tag{4}$</p>
</li>
<li>
<p>绕$\hat y$方向逆时针旋转矩阵:$R_{\theta}=\left( \begin{matrix} \cos \theta &amp; 0 &amp; \sin \theta &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ -\sin \theta &amp; 0 &amp; \cos \theta &amp; 0 \ 0 &amp; 0&amp;0&amp;1 \end{matrix} \right) \tag{4}$</p>
</li>
<li>
<p>对于旋转矩阵R，有以下性质$R^{-1}<em>\theta =R</em>{-\theta}=R_\theta ^T$</p>
</li>
</ol>
</li>
<li>
<p>缩放矩阵：$S_{s_x,s_y}=\left( \begin{matrix} s_x &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; s_y &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; s_z &amp; 0\ 0 &amp;0 &amp;0 &amp;1 \end{matrix} \right) \tag{3}$</p>
</li>
<li>
<p>切变：$S_{s_x,s_y}=\left( \begin{matrix} 1 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp;0&amp;0&amp;1 \end{matrix} \right) $</p>
</li>
</ol>
<p>模型矩阵一般由<strong>平移矩阵、缩放矩阵、旋转矩阵</strong>相乘得到。</p>
$$
M_{model}=M_{transform}*M_{Scale}*M_{rotarion}
$$<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="nf">vec</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4x4</span> <span class="n">Mtrans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="nf">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4x4</span> <span class="n">MProject</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="nf">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="nf">radians</span><span class="p">(</span><span class="mf">90.0f</span><span class="p">),</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span> <span class="c1">// 投影矩阵
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4x4</span> <span class="n">Mtrans</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="nf">translate</span><span class="p">(</span><span class="n">Mtrans</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="nf">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0f</span><span class="p">));</span> <span class="c1">// 生成平移矩阵
</span></span></span><span class="line"><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4x4</span> <span class="n">MScale</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="nf">scale</span><span class="p">(</span><span class="n">MScale</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="nf">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span> <span class="c1">// 生成缩放矩阵
</span></span></span><span class="line"><span class="cl"><span class="n">glm</span><span class="o">::</span><span class="n">mat4x4</span> <span class="n">MRot</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="nf">rotate</span><span class="p">(</span><span class="n">MRot</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="nf">radians</span><span class="p">(</span><span class="mf">90.0f</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="nf">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span> <span class="c1">// 生成旋转矩阵
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3摄像机视口矩阵">3、摄像机（视口矩阵）
</h3><p><img src="E:%5cWork%5c001_note%5cimage%5cimage-20250717171129515.png"
	
	
	
	loading="lazy"
	
		alt="image-20250717171129515"
	
	
></p>
<p>image-20250717171129515.png</p>
<h4 id="1摄像机位置">（1）摄像机位置
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2摄像机方向">（2）摄像机方向
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);
</span></span><span class="line"><span class="cl">glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="3摄像机的右轴和上轴">（3）摄像机的右轴和上轴
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); 
</span></span><span class="line"><span class="cl">glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));
</span></span><span class="line"><span class="cl">glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="4lookat矩阵">（4）LookAt矩阵
</h4><p>​	使用矩阵的好处之一是如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。</p>
<p>​	glm::LookAt函数需要一个位置、目标和上向量。它会创建一个和在上一节使用的一样的观察矩阵。</p>
<p>image-20241126162019735.png</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">glm::mat4 view;
</span></span><span class="line"><span class="cl">view = glm::lookAt(cameraPos, cameraTarget,up);
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="二光照">二、光照
</h2><h3 id="1布林恩-冯模型">1、布林恩-冯模型
</h3><ul>
<li>
<p><strong>环境光</strong>: <code>vec3 ambient = ambientStrength * lightColor * objectColor;</code></p>
<ul>
<li>环境光因子一般由一个<strong>较小的因子</strong>乘上光照颜色得到。再由环境光因子与物体颜色相乘，就可以得到环境光照对物体的作用结果。</li>
</ul>
</li>
<li>
<p><strong>漫反射</strong>：<code>vec3 diffuse = max(dot(norm, lightDir), 0.0)* lightColor * objectColor;</code></p>
<ul>
<li>漫反射反应的是光在该平面上的光通量强度，当入射进该平面的光越多，漫反射就越强。
image-20250922094541562.png</li>
</ul>
</li>
<li>
<p><strong>镜面反射</strong>： <code>vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), 32) * lightColor * objectColor;</code>其中：<code>vec3 reflectDir = reflect(-lightDir, norm);</code></p>
<ul>
<li>镜面反射强度，与<strong>光线出射角</strong>以及<strong>观察方向</strong>，直接相关。当两者夹角越小，镜面反射强度越高。同时对该影响因子的幂次越高，高光越集中化。
image-20250922094927976.png
image-20250922100232547.png</li>
</ul>
</li>
</ul>
<p><strong>注意事项</strong>：法线由局部坐标系转换到世界坐标系不能简单的通过模型矩阵来计算。如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。见下图：image-20250922100002164.png&quot;</p>
<p>因此，世界坐标中的法线一般采用<code>Normal = mat3(transpose(inverse(model))) * aNormal;</code>的方式来计算获得。</p>
<h3 id="2直接光源">2、直接光源
</h3><p>采用布林恩冯模型</p>
<ol>
<li>环境光：
<ol>
<li>光源颜色  *  物体颜色</li>
<li>物体颜色可采用漫反射贴图</li>
<li><code>vec3 ambient = light.ambient * objectColor;</code></li>
</ol>
</li>
<li>漫反射：
<ol>
<li>需要考虑<strong>光线入射角</strong>和表面<strong>法线</strong>夹角</li>
<li>物体颜色可采用漫反射贴图</li>
<li><code>vec3 diffuse = max(dot(norm, lightDir), 0.0)* light.diffuse* objectColor;</code></li>
</ol>
</li>
<li>镜面反射 ：
<ol>
<li>考虑<strong>光线出射角</strong>和<strong>观察视线</strong>的夹角</li>
<li>物体颜色可采用镜面反射贴图</li>
<li><code>vec3 specular = pow(max(dot(viewDir, reflectDir), 0.0), 32) * light.specular* objectColor;</code></li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">Material</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">sampler2D</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">sampler2D</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">shininess</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">Dirlight</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">direction</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">CalcDirLight</span><span class="p">(</span><span class="n">Dirlight</span> <span class="n">light</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">viewDir</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">ambient</span> <span class="o">*</span> <span class="n">texture</span><span class="p">(</span><span class="n">uMaterial</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span> <span class="p">;</span>   <span class="c1">//环境光</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">*</span> <span class="n">texture</span><span class="p">(</span><span class="n">uMaterial</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>     <span class="c1">//漫反射</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">reflectDir</span><span class="p">,</span><span class="n">viewDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">),</span> <span class="n">uMaterial</span><span class="p">.</span><span class="n">shininess</span><span class="p">)</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">specular</span> <span class="o">*</span> <span class="n">texture</span><span class="p">(</span><span class="n">uMaterial</span><span class="p">.</span><span class="n">specular</span><span class="p">,</span><span class="n">TexCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>   <span class="c1">//镜面光</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3点光源">3、点光源
</h3><p>采用布林恩冯模型，与平行光仅有微小的差异</p>
<ol>
<li>光线方向需要有点光源位置与片段位置计算得出</li>
<li>点光源的强度会随距离衰减。</li>
</ol>
<p>image-20251014110623598.png</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">Material</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">sampler2D</span> <span class="n">diffuse</span><span class="p">;</span>  <span class="c1">//漫反射贴图</span>
</span></span><span class="line"><span class="cl">    <span class="k">sampler2D</span> <span class="n">specular</span><span class="p">;</span> <span class="c1">//镜面光贴图</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">shininess</span><span class="p">;</span>    <span class="c1">//高光指数</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">PointLight</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">position</span><span class="p">;</span>      <span class="c1">//点光源位置</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">constant</span><span class="p">;</span>     <span class="c1">//常数项</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">linear</span><span class="p">;</span>       <span class="c1">//线性项</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">quadratic</span><span class="p">;</span>    <span class="c1">//二次项</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">ambient</span><span class="p">;</span>       <span class="c1">//环境光</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">;</span>       <span class="c1">//漫反射</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">specular</span><span class="p">;</span>      <span class="c1">//镜面光</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">vec3</span> <span class="n">CalcPointLight</span><span class="p">(</span><span class="n">PointLight</span> <span class="n">light</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">fragPos</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">viewDir</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">fragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">fragPos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">constant</span> <span class="o">+</span> <span class="n">light</span><span class="p">.</span><span class="n">linear</span> <span class="o">*</span> <span class="n">distance</span> <span class="o">+</span> <span class="n">light</span><span class="p">.</span><span class="n">quadratic</span> <span class="o">*</span> <span class="p">(</span><span class="n">distance</span> <span class="o">*</span> <span class="n">distance</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">ambient</span> <span class="o">*</span> <span class="n">texture</span><span class="p">(</span><span class="n">uMaterial</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span> <span class="p">;</span>   <span class="c1">//环境光</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">*</span> <span class="n">texture</span><span class="p">(</span><span class="n">uMaterial</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">TexCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>     <span class="c1">//漫反射</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">reflectDir</span><span class="p">,</span><span class="n">viewDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">),</span> <span class="n">uMaterial</span><span class="p">.</span><span class="n">shininess</span><span class="p">)</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">specular</span> <span class="o">*</span> <span class="n">texture</span><span class="p">(</span><span class="n">uMaterial</span><span class="p">.</span><span class="n">specular</span><span class="p">,</span><span class="n">TexCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>   <span class="c1">//镜面光</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">)</span> <span class="o">*</span> <span class="n">attenuation</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4聚光灯">4、聚光灯
</h3><p>聚光灯是一种位置在环境中的光源，它只在一个特定的方向上发射光线，并且光线会随着距离逐渐衰减。聚光灯通常用于模拟手电筒、车灯等效果。</p>
<p>聚光灯的光照计算需要考虑：</p>
<ol>
<li>光源位置和方向</li>
<li>聚光灯的切光角（Cut-off angle）</li>
<li>聚光灯的外切光角（Outer cut-off angle）</li>
<li>光线衰减</li>
</ol>
<h2 id="三材质">三、材质
</h2><p>在布林恩冯模型下，我们希望更精细的控制光照表现，因此抽象出了材质的概念。</p>
<p>物体材质（Material）包含以下几个属性：</p>
<ol>
<li>ambient：基础颜色。定义了在环境光照下这个表面反射的是什么颜色，通常与表面的颜色相同。</li>
<li>diffuse：漫反射。定义了在漫反射光照下表面的颜色。漫反射颜色（和环境光照一样）也被设置为我们期望的物体颜色。</li>
<li>specular：镜面反射，设置的是表面上镜面高光的颜色（或者甚至可能反映一个特定表面的颜色）。</li>
<li>shininess：镜面反射半径</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#version 330 core
</span></span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Material</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec3</span> <span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">shininess</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">uniform</span> <span class="n">Material</span> <span class="n">material</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;material.ambient&#34;</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.31f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;material.diffuse&#34;</span><span class="p">,</span>  <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.31f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">&#34;material.specular&#34;</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">lightingShader</span><span class="p">.</span><span class="n">setFloat</span><span class="p">(</span><span class="s">&#34;material.shininess&#34;</span><span class="p">,</span> <span class="mf">32.0f</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了物体材质本身，光也具有自身的属性。</p>
<p>一个光源对它的ambient、diffuse和specular光照分量有着不同的强度。<strong>环境光照通常被设置为一个比较低的强度</strong>，因为我们不希望环境光颜色太过主导。光源的<strong>漫反射分量</strong>通常被设置为我们希望光所具有的那个颜色，通常是一个比较明亮的白色。<strong>镜面光分量</strong>通常会保持为<code>vec3(1.0)</code>，以最大强度发光。注意我们也将光源的位置向量加入了结构体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Light</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vec3</span> <span class="n">ambient</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec3</span> <span class="n">diffuse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec3</span> <span class="n">specular</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">uniform</span> <span class="n">Light</span> <span class="n">light</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="glsl">GLSL
</h1><p>GLSL由三部分构成：vertex + fragment</p>
<p>版本指定：<code>#version 310 es</code></p>
<h2 id="零简单的示例">零、简单的示例
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="cm">/** This is a VertexShader */</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">VertexShaderSource</span> <span class="o">=</span> <span class="err">&#34;#</span><span class="n">version</span> <span class="mi">330</span> <span class="n">core</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mo">0</span><span class="p">)</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">aPos</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span><span class="k">void</span> <span class="n">main</span><span class="p">()</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span>   <span class="n">gl_Position</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">aPos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">aPos</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span>   <span class="n">gl_PointSize</span> <span class="o">=</span> <span class="mf">20.0</span><span class="n">f</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span><span class="p">}</span><span class="err">\</span><span class="mo">0</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/** This is a FragmentShader */</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">FragmentShaderSource</span> <span class="o">=</span> <span class="err">&#34;#</span><span class="n">version</span> <span class="mi">330</span> <span class="n">core</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span><span class="k">out</span> <span class="k">vec4</span> <span class="n">FragColor</span><span class="p">;</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span><span class="k">void</span> <span class="n">main</span><span class="p">()</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span><span class="p">{</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span>    <span class="n">FragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span><span class="mf">0.2</span><span class="n">f</span><span class="p">,</span><span class="mf">1.0</span><span class="n">f</span><span class="p">);</span><span class="err">\</span><span class="n">n</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="err">&#34;</span><span class="p">}</span><span class="err">\</span><span class="mo">0</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="一着色器关键字">一、着色器关键字
</h2><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>关键字</th>
          <th>说明</th>
          <th>示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>attribute</td>
          <td>顶点属性，只会在顶点着色器中出现，不会在片段着色器中出现<br />现在已经废弃，而采用in和out</td>
          <td>attribute aVertexPosition</td>
      </tr>
      <tr>
          <td>uniform</td>
          <td>外部变量，全局统一</td>
          <td>uniform uModelViewMatrix</td>
      </tr>
      <tr>
          <td>varing</td>
          <td>可透传到片段着色器的变量，由顶点着色器计算得出</td>
          <td>varing highp vec3 vFragPos</td>
      </tr>
      <tr>
          <td>layout</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>in</td>
          <td>该着色器的输入</td>
          <td>layout (location = 0) in vec3 aPos;<br />layout (location = 1) in vec3 aTangent;</td>
      </tr>
      <tr>
          <td>out</td>
          <td>该着色器的输出</td>
          <td>out type out_variable_name;</td>
      </tr>
  </tbody>
</table></div>
<h2 id="二变量">二、变量
</h2><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>变量类型</th>
          <th>说明</th>
          <th>示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>int / float / double / uint / bool</td>
          <td>基础类型</td>
          <td></td>
      </tr>
      <tr>
          <td>vec</td>
          <td>向量，默认为float，也可以选择bool、double、uint</td>
          <td>bvec3 / vec2</td>
      </tr>
      <tr>
          <td>mat</td>
          <td>矩阵</td>
          <td></td>
      </tr>
      <tr>
          <td>sampler2D</td>
          <td>纹理贴图</td>
          <td></td>
      </tr>
      <tr>
          <td>gl_Position</td>
          <td>顶点着色器中的默认变量</td>
          <td></td>
      </tr>
      <tr>
          <td>gl_FragColor</td>
          <td>片段着色器中的默认变量，可以存在多个，需要用到变种。（一次pass，输出多个结果）</td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<h2 id="三函数">三、函数
</h2><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数名</th>
          <th>说明</th>
          <th>示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>texture2D</td>
          <td>贴图采样器</td>
          <td>texture2D(uSampler,vTextureCoord).rgb</td>
      </tr>
      <tr>
          <td>pow</td>
          <td>乘方，常用：gama矫正</td>
          <td>pow(texture2D(uSampler,vTextureCoord).rgb,vec3(2.2)</td>
      </tr>
      <tr>
          <td>max</td>
          <td>取大值</td>
          <td></td>
      </tr>
      <tr>
          <td>min</td>
          <td>取小值</td>
          <td></td>
      </tr>
      <tr>
          <td>mix</td>
          <td>线性插值/混合</td>
          <td>mix(texture(uTexture0, TexCoord.xy),texture(uTexture1, TexCoord.xy),0.8f);</td>
      </tr>
  </tbody>
</table></div>
<h2 id="四常用函数">四、常用函数
</h2><h3 id="一深度打包函数">一、深度打包函数
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="c1">//Fragment</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">vec4</span> <span class="n">pack</span> <span class="p">(</span><span class="k">float</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用rgba 4字节共32位来存储z值,1个字节精度为1/256</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec4</span> <span class="n">bitShift</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">256.0</span><span class="p">,</span> <span class="mf">256.0</span> <span class="o">*</span> <span class="mf">256.0</span><span class="p">,</span> <span class="mf">256.0</span> <span class="o">*</span> <span class="mf">256.0</span> <span class="o">*</span> <span class="mf">256.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">vec4</span> <span class="n">bitMask</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">256.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">256.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">256.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// gl_FragCoord:片元的坐标,fract():返回数值的小数部分</span>
</span></span><span class="line"><span class="cl">    <span class="k">vec4</span> <span class="n">rgbaDepth</span> <span class="o">=</span> <span class="n">fract</span><span class="p">(</span><span class="n">depth</span> <span class="o">*</span> <span class="n">bitShift</span><span class="p">);</span> <span class="c1">//计算每个点的z值</span>
</span></span><span class="line"><span class="cl">    <span class="n">rgbaDepth</span> <span class="o">-=</span> <span class="n">rgbaDepth</span><span class="p">.</span><span class="n">gbaa</span> <span class="o">*</span> <span class="n">bitMask</span><span class="p">;</span> <span class="c1">// Cut off the value which do not fit in 8 bits</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rgbaDepth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">float</span> <span class="n">unpack</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: 实现解包函数</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="hlsl">HLSL
</h1><p>Vertex + Pixel</p>
<h1 id="glm库">GLM库
</h1><p>GLM（OpenGL Mathematics）是一个专门为 OpenGL 设计的 C++ 数学库，它提供了与 GLSL（OpenGL Shading Language）兼容的数学类型和函数。GLM 的设计目标是让 C++ 代码能够方便地使用与着色器相同的数学运算。</p>
<p>主要特性：</p>
<ul>
<li>提供向量（vec2, vec3, vec4）、矩阵（mat3, mat4）等数据类型</li>
<li>支持常见的数学运算（点积、叉积、归一化等）</li>
<li>提供变换函数（平移、旋转、缩放、透视投影等）</li>
<li>与 GLSL 语法高度兼容</li>
</ul>
<h1 id="stb库">STB库
</h1><p>STB 是一个轻量级的单文件 C/C++ 库集合，由 Sean Barrett 开发。它包含了各种常用功能的实现，如图像加载、文本解析、音频处理等。</p>
<h2 id="一stb_image">一、stb_image
</h2><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数</th>
          <th>作用</th>
          <th>示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>stbi_load()</td>
          <td>加载图片</td>
          <td>int width, height, nrChannels; unsigned char *data = stbi_load(&ldquo;container.jpg&rdquo;, &amp;width, &amp;height, &amp;nrChannels, 0);</td>
      </tr>
  </tbody>
</table></div>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under <a class="link" href="https://github.com/Liyufei1"  target="_blank" rel="noopener"
    >Liyufei1</a></span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        const elementsToRender = [".main-article", ".widget--toc"];

        elementsToRender.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
                renderMathInElement(element, {
                    delimiters: [
                        { left: "$$", right: "$$", display: true },
                        { left: "$", right: "$", display: false },
                        { left: "\\(", right: "\\)", display: false },
                        { left: "\\[", right: "\\]", display: true }
                    ],
                    ignoredClasses: ["gist"]
                });
            }
        });
    });
</script>
    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2026 李宇飞-Liyufei1
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.32.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
