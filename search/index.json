[{"content":"概述 Node3DEditor是Godot内置3D编辑器的核心插件，它是3D场景的编辑界面的主体，包括了：3D物体的齐次线性变换、工具栏、Gizmo、网格等等。\nCanvasItemEditor是Godot内置2D编辑器的核心插件，它是2D场景的编辑界面的主体，包括了：2D物体的变换、工具栏、网格等等。\nNode3DEditor Node3DEditor是Godot内置3D编辑器的核心插件，它是3D场景的编辑界面的主体，包括了：视口、工具栏、Gizmo、网格等等。\n初始化：在main函数的start阶段，会创建一个EditorNode，并且利用add_child挂载到sml（SceneTree_MainLoop）的root根节点（windows）上。而在EditorNode的构造函数中，则会创建一个EditorNode（add_editor_plugin(memnew(Node3DEditorPlugin));）。 UI扩展：往3D编辑器的各种Panel添加控件 1 2 3 4 5 6 7 8 9 10 11 12 13 void add_control_to_menu_panel(Control *p_control); void remove_control_from_menu_panel(Control *p_control); void add_control_to_left_panel(Control *p_control); void remove_control_from_left_panel(Control *p_control); void add_control_to_right_panel(Control *p_control); void remove_control_from_right_panel(Control *p_control); void move_control_to_left_panel(Control *p_control); void move_control_to_right_panel(Control *p_control); VSplitContainer *get_shader_split(); EditorPlugin 在使用编辑器的过程中，我们会选中各种各样的对象，包括：的文件系统中的文件、场景树中的节点、场景中的物体等等。当我们选中其中任意一个时，都会触发一次bool EditorPlugin::handles(Object *p_object)方法，该方法的作用是判断当前选中的对象是否应该被插件处理，当返回true，或上一次调用返回为true时，则会触发处理流程。这种说法有点拗口，通俗的理解就是进入和退出特定对象的编辑时，都会触发一次后续流程。\n触发流程时会依次调用：void EditorPlugin::make_visible(bool p_visible);和void EditorPlugin::edit(Object *p_object)\n进入时，p_visible为true，p_object为选中的对象 退出时，p_visible为false，p_object为nullptr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class LyfTestEditorPlugin : public EditorPlugin { GDCLASS(LyfTestEditorPlugin, EditorPlugin); // MeshInstance3DEditor *mesh_editor = nullptr; public: virtual String get_plugin_name() const override { return \u0026#34;LyfTestEditorPlugin\u0026#34;; } bool has_main_screen() const override { return false; } virtual void edit(Object *p_object) override; virtual bool handles(Object *p_object) const override; virtual void make_visible(bool p_visible) override; LyfTestEditorPlugin(); ~LyfTestEditorPlugin(); }; ","date":"2025-11-20T09:18:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E5%85%ADgodot%E4%B8%AD%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%E6%8F%92%E4%BB%B6editorplugin/","title":"【godot】六、godot中的编辑器插件EditorPlugin"},{"content":"概述 在游戏开发中，动态性和灵活性是至关重要的特性。python，C#，java等编程语言，从语音层面就是支持反射或动态类型系统的，可以运行时动态地查看对象的类型、成员、方法，甚至动态调用或修改它们。而游戏引擎为了追求运行时的效率，一般会采用Cpp语言进行开发，Cpp语言本身不支持反射，所以各大游戏引擎都各显神通地添加了反射系统，以支持运行时动态类型信息。\n在虚幻引擎当中，是通过UObject类来收集元信息的。通过UPROPTERTY()等宏标记，用UHT工具，在编译前进行一次头文件的生成，从而生成UPROPERTY()所标记的属性元信息的U类。对于虚幻的反射实现感兴趣的朋友，可以参考大钊在知乎上的文章：虚幻引擎的元信息机制 在Unity中，反射系统由C#提供的。 在godot中，反射系统则是由名为ClassDB提供，它记录了所有派生自Object类的类型信息。在业务代码层，我们可以通过它提供的一系列静态方法来运行时访问类的类型信息，比如获取类的成员变量、方法、属性等信息。 ClassDB介绍 对于godot来说ClassDB是一个全局类信息库，可以对所有注册类的元数据进行访问。\nClassDB利用静态成员变量来存储类的元数据，比如类的继承关系、成员变量、方法、属性等信息。 ClassDB提供了一系列的静态成员函数给用户来进行元数据查询。 因此ClassDB并没有实例化的需求。 下方截取了4.4版本godot源码中ClassDB类的部分代码，并标注了一些重要的信息，帮助我们去整体的理解ClassDB的运行原理。为了方便理解，方法和属性的顺序，并非与源码严格一致。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class ClassDB { public: //... //读写锁，防止多线程问题 static RWLock lock; //所有注册的类信息 static HashMap\u0026lt;StringName, ClassInfo\u0026gt; classes; // static HashMap\u0026lt;StringName, StringName\u0026gt; resource_base_extensions; static HashMap\u0026lt;StringName, StringName\u0026gt; compat_classes; //... public: //... //查询所有类的名称列表 static void get_class_list(List\u0026lt;StringName\u0026gt; *p_classes); //查询所有GDExtension的类名称列表 static void get_extensions_class_list(List\u0026lt;StringName\u0026gt; *p_classes); //按照名称查询类是否存在 static bool class_exists(const StringName \u0026amp;p_class); //信号接口 static void add_signal(const StringName \u0026amp;p_class, const MethodInfo \u0026amp;p_signal); static bool has_signal(const StringName \u0026amp;p_class, const StringName \u0026amp;p_signal, bool p_no_inheritance = false); static bool get_signal(const StringName \u0026amp;p_class, const StringName \u0026amp;p_signal, MethodInfo *r_signal); static void get_signal_list(const StringName \u0026amp;p_class, List\u0026lt;MethodInfo\u0026gt; *p_signals, bool p_no_inheritance = false); }; 类的查询接口 在理解ClassDB中的静态成员变量static HashMap\u0026lt;StringName, ClassInfo\u0026gt; classes;存储了所有的类信息后，下方两个查询的接口，就非常好理解了。\n接口 作用 一般接口 get_class_list 查询所有类名称 class_exists 查询类是否存在 instantiate 调用实例化函数，并发送通知 向下查询 get_inheriters_from_class 查询所有继承类 get_direct_inheriters_from_class 查询所有继承类(不包含自身) 向上查询 get_parent_class 查询父类 get_parent_class_nocheck 查询父类名称，不做报错 get_inheritance_chain_nocheck 查询继承链 is_parent_class 查询A是否继承自B(包括同一类) 一般接口 get_class_list ：：所有类名称查询，返回一个列表，列表中的元素是所有类的名称。 1 2 3 4 5 6 7 8 9 10 11 12 void ClassDB::get_class_list(List\u0026lt;StringName\u0026gt; *p_classes) { //创建读锁，godot定义的宏，可以不关注它的实现细节 OBJTYPE_RLOCK; //遍历存放所有类信息的HashMap：classes，拿到它的键值，也就是类名，添加进输出列表 for (const KeyValue\u0026lt;StringName, ClassInfo\u0026gt; \u0026amp;E : classes) { p_classes-\u0026gt;push_back(E.key); } //对 p_classes 列表中的所有类名（StringName）按照字母顺序进行排序。 p_classes-\u0026gt;sort_custom\u0026lt;StringName::AlphCompare\u0026gt;(); } class_exists ：：查询类是否存在，返回布尔值。 1 2 3 4 5 6 bool ClassDB::class_exists(const StringName \u0026amp;p_class) { //创建读锁 OBJTYPE_RLOCK; //根据键值查询哈希表 return classes.has(p_class); } 向下查询 get_inheriters_from_class ：： 查询所有继承自指定类的类名称列表。 get_direct_inheriters_from_class ：：查询所有继承自指定类的类名称列表，过滤掉了传入的类本身 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void ClassDB::get_inheriters_from_class(const StringName \u0026amp;p_class, List\u0026lt;StringName\u0026gt; *p_classes) { //锁上读锁 OBJTYPE_RLOCK; //遍历存放所有类信息，如果E为继承自p_class的类，则添加进输出列表 for (const KeyValue\u0026lt;StringName, ClassInfo\u0026gt; \u0026amp;E : classes) { if (E.key != p_class \u0026amp;\u0026amp; _is_parent_class(E.key, p_class)) { p_classes-\u0026gt;push_back(E.key); } } } void ClassDB::get_direct_inheriters_from_class(const StringName \u0026amp;p_class, List\u0026lt;StringName\u0026gt; *p_classes) { //锁上读锁 OBJTYPE_RLOCK; //同上，但是过滤掉了自身 for (const KeyValue\u0026lt;StringName, ClassInfo\u0026gt; \u0026amp;E : classes) { if (E.key != p_class \u0026amp;\u0026amp; _get_parent_class(E.key) == p_class) { p_classes-\u0026gt;push_back(E.key); } } } 向上查询 get_parent_class ：：查询指定类的父类名称 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 StringName ClassDB::get_parent_class(const StringName \u0026amp;p_class) { //锁上读锁 OBJTYPE_RLOCK; //调用实际执行函数 return _get_parent_class(p_class); } StringName ClassDB::_get_parent_class(const StringName \u0026amp;p_class) { ClassInfo *ti = classes.getptr(p_class); //非空判断，为空时报错并返回空字符串 ERR_FAIL_NULL_V_MSG(ti, StringName(), vformat(\u0026#34;Cannot get class \u0026#39;%s\u0026#39;.\u0026#34;, String(p_class))); //返回父类名称 return ti-\u0026gt;inherits; } get_parent_class_nocheck ：：查询指定类的父类名称，不做报错 1 2 3 4 5 6 7 8 9 10 11 12 13 StringName ClassDB::get_parent_class_nocheck(const StringName \u0026amp;p_class) { //锁上读锁 OBJTYPE_RLOCK; //非空判断 ClassInfo *ti = classes.getptr(p_class); if (!ti) { return StringName(); } //返回父类名称 return ti-\u0026gt;inherits; } get_inheritance_chain_nocheck：：查询继承链 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 bool ClassDB::get_inheritance_chain_nocheck(const StringName \u0026amp;p_class, Vector\u0026lt;StringName\u0026gt; \u0026amp;r_result) { //锁上读锁 OBJTYPE_RLOCK; //非空判断 ClassInfo *start = classes.getptr(p_class); if (!start) { return false; } //向上查询，直至父类指针为空 int classes_to_add = 0; for (ClassInfo *ti = start; ti; ti = ti-\u0026gt;inherits_ptr) { classes_to_add++; } //扩容r_result列表，并将父类名列表称添加进列表 //不用push_back，因为push_back会动态扩容，性能表现更差，而resize不会 int64_t old_size = r_result.size(); r_result.resize(old_size + classes_to_add); StringName *w = r_result.ptrw() + old_size; for (ClassInfo *ti = start; ti; ti = ti-\u0026gt;inherits_ptr) { *w++ = ti-\u0026gt;name; } return true; } 信号接口 信号相关的信息，存储在ClassInfo的signal_map当中\n接口 作用 add_signal 为某个类添加一个 信号，普遍使用它的宏ADD_SIGNAL版本 has_signal 检查类是否（含父类）定义了某个信号 get_signal 返回 class 或其祖先的信号数据。 get_signal_list 获取所有信号（可包括父类） 基本使用示例： godot中的signal类似于ue中的动态多播代理。它可以将一个信号（可以带参数）发送到所有监听函数。\n信号的创建一般放在_bind_methods中 监听信号的绑定，则需要结合实际的监听者（Object*），因此不会在静态函数_bind_methods中绑定。 信号的发送，也需要结合实际的发送者。 注意，由于信号功能的实现，依赖了Object内的方法，所以相关的函数需要被注册进类型信息当中，否则Object无法通过call动态的调用绑定的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //信号创建 void MyNode::_bind_methods() { //定义信号的属性 MethodInfo mi(\u0026#34;TestSignal\u0026#34;); //信号名称为TestSignal mi._push_params(PropertyInfo(Variant::INT,\u0026#34;Arg1\u0026#34;)); //具有一个类型为int的参数Arg1 ClassDB::add_signal(\u0026#34;NsTestResource\u0026#34;, mi);\t//添加信号 //宏的实现版本 //信号名称为TestSignal，信号具有一个参数，类型为int ADD_SIGNAL(MethodInfo(\u0026#34;NsTestResource\u0026#34;, PropertyInfo(Variant::INT, \u0026#34;TestSignal\u0026#34;)));\t} //定义被调用函数 void NsTestResource::test_func_for_signal(int AAA){ print_line(\u0026#34;test_func_for_signal::\u0026#34;,AAA); } //绑定信号 void NsTestResource::test_func_for_connect(){ connect(\u0026#34;TestSignal\u0026#34;, Callable(this,\u0026#34;test_func_for_signal\u0026#34;)); } //发射信号 void NsTestResource::test_func_for_emit(int AAA){ emit_signal(\u0026#34;TestSignal\u0026#34;, 2); } add_signal 为某个类添加一个信号,MethodInfo参考链接\n方法签名\n1 2 3 4 void ClassDB::add_signal( const StringName \u0026amp;p_class, //类名 const MethodInfo \u0026amp;p_signal\t//信号信息 ); 常用的宏定义\n1 #define ADD_SIGNAL(m_signal) ::ClassDB::add_signal(get_class_static(), m_signal) 使用示例\n1 2 3 4 5 6 7 8 9 10 void MyNode::_bind_methods() { //定义信号的属性 MethodInfo mi(\u0026#34;TestSignal\u0026#34;); //信号名称为TestSignal mi._push_params(PropertyInfo(Variant::INT,\u0026#34;Arg1\u0026#34;)); //具有一个类型为int的参数Arg1 ClassDB::add_signal(\u0026#34;NsTestResource\u0026#34;, mi);\t//添加信号 //宏的实现版本 //信号名称为TestSignal，信号具有一个参数，类型为int ADD_SIGNAL(MethodInfo(\u0026#34;NsTestResource\u0026#34;, PropertyInfo(Variant::INT, \u0026#34;TestSignal\u0026#34;)));\t} 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void ClassDB::add_signal(const StringName \u0026amp;p_class, const MethodInfo \u0026amp;p_signal) { //锁上写锁 OBJTYPE_WLOCK; //类信息非空判断 ClassInfo *type = classes.getptr(p_class); ERR_FAIL_NULL(type); //获取信号名称 StringName sname = p_signal.name; //同名信号报错 #ifdef DEBUG_METHODS_ENABLED ClassInfo *check = type; while (check) { ERR_FAIL_COND_MSG(check-\u0026gt;signal_map.has(sname), vformat(\u0026#34;Class \u0026#39;%s\u0026#39; already has signal \u0026#39;%s\u0026#39;.\u0026#34;, String(p_class), String(sname))); check = check-\u0026gt;inherits_ptr; } #endif //signal_map中添加信号 type-\u0026gt;signal_map[sname] = p_signal; } has_signal 检查某个类是否定义过某个信号\n方法签名\n1 2 3 4 5 bool ClassDB::has_signal( const StringName \u0026amp;p_class, //类名 const StringName \u0026amp;p_signal, //信号名 bool p_no_inheritance //是否忽略继承关系 ); 使用示例\n1 2 3 4 void testfun(){ bool exists = ClassDB::has_signal(\u0026#34;Node\u0026#34;, \u0026#34;tree_entered\u0026#34;); print_line(vformat(\u0026#34;Has signal? %s\u0026#34;, exists)); } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool ClassDB::has_signal(const StringName \u0026amp;p_class, const StringName \u0026amp;p_signal, bool p_no_inheritance) { //锁上读锁 OBJTYPE_RLOCK; //类信息非空判断 ClassInfo *type = classes.getptr(p_class); ClassInfo *check = type; //向上逐级查询classinfo，直到object类， while (check) { if (check-\u0026gt;signal_map.has(p_signal)) { return true; } //无需向上查询，则返回false if (p_no_inheritance) { return false; } check = check-\u0026gt;inherits_ptr; } return false; } get_signal 获取信号的完整信息存入MethodInfo，如果信号存在返回true 并填充p_signal\nMethodInfo链接\n方法签名\n1 2 3 4 5 bool ClassDB::get_signal( const StringName \u0026amp;p_class, // 类名 const StringName \u0026amp;p_signal, // 信号名 MethodInfo *r_signal // 存储信号的MethodInfo )； 使用示例\n1 2 3 4 5 6 7 8 9 10 void testfun(){ MethodInfo info; if (ClassDB::get_signal(\u0026#34;MyNode\u0026#34;, \u0026#34;hit\u0026#34;, \u0026amp;info)) { print_line(\u0026#34;Signal name: \u0026#34; + info.name); for (auto arg : info.arguments) { print_line(\u0026#34;Arg: \u0026#34; + arg.name); } } } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool ClassDB::get_signal(const StringName \u0026amp;p_class, const StringName \u0026amp;p_signal, MethodInfo *r_signal) { //锁上读锁 OBJTYPE_RLOCK; ClassInfo *type = classes.getptr(p_class); ClassInfo *check = type; //向上逐级查询classinfo，直到object类 while (check) { //获取信号信息 if (check-\u0026gt;signal_map.has(p_signal)) { if (r_signal) { //进行值拷贝 *r_signal = check-\u0026gt;signal_map[p_signal]; } return true; } //父类ClassInfo指针 check = check-\u0026gt;inherits_ptr; } return false; } get_signal_list 获取某个类所有信号,包括父类信号\n方法签名\n1 2 3 4 5 void ClassDB::get_signal_list( const StringName \u0026amp;p_class, //类名 List\u0026lt;MethodInfo\u0026gt; *p_signals, //信号列表引用，用于返回查询结果 bool p_no_inheritance //是否查询父类信号 ); 使用示例\n1 2 3 4 5 6 7 8 void testfun(){ List\u0026lt;MethodInfo\u0026gt; signals; ClassDB::get_signal_list(\u0026#34;Node2D\u0026#34;, \u0026amp;signals); for (List\u0026lt;MethodInfo\u0026gt;::Element *E = signals.front(); E; E = E-\u0026gt;next()) { print_line(\u0026#34;Signal: \u0026#34; + E-\u0026gt;get().name); } } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void ClassDB::get_signal_list(const StringName \u0026amp;p_class, List\u0026lt;MethodInfo\u0026gt; *p_signals, bool p_no_inheritance) { //锁上读锁 非空判断 OBJTYPE_RLOCK; ClassInfo *type = classes.getptr(p_class); ERR_FAIL_NULL(type); //向上逐级查询classinfo，直到object类 ClassInfo *check = type; while (check) { //遍历所有信号，并推入数组 for (KeyValue\u0026lt;StringName, MethodInfo\u0026gt; \u0026amp;E : check-\u0026gt;signal_map) { p_signals-\u0026gt;push_back(E.value); } if (p_no_inheritance) { return; } check = check-\u0026gt;inherits_ptr; } } 属性接口 属性相关的信息，存储在ClassInfo的property_list、property_map和property_setget当中\n接口 作用 add_property 给某个类注册一个“属性”，并把这个属性和对应的 setter/getter 方法绑定起来 add_property_array 为 Inspector 生成“数组式属性组”的辅助函数，本身不创建实际的属性 add_property_array_count 给一个类注册数组属性 add_property_group 为 Inspector中显示的属性分组 add_property_subgroup 创建 缩进更深一级的子分组 add_linked_property 链接属性，将子属下关联到父属性 get_property_list 获取某个类的所有属性列表 get_property_info 获取某个类的某个属性，注意由于是通过ClassInfo：：property_map来进行查询的，因此占位的属性信息会返回false get_property 获取某个实例的属性值，信息存放在ClassInfo::PropertySetGet中 set_property 设置某个实例的属性值，信息存放在ClassInfo::PropertySetGet中 has_property 查询某个类是否定义过某个属性，信息存放在ClassInfo::PropertySetGet中 get_property_index 查询属性索引，信息存放在ClassInfo::PropertySetGet中 get_property_type 获取属性类型，信息存放在ClassInfo::PropertySetGet中 get_property_setter 获取属性setter方法名，信息存放在ClassInfo::PropertySetGet中 get_property_getter 获取属性getter方法名，信息存放在ClassInfo::PropertySetGet中 add_property add_property给某个类注册一个“属性”，并把这个属性和对应的 setter/getter 方法绑定起来。\n一般结合get_class_static()使用，在_bind_methods 中调用，注册本类的属性。\n方法签名\n1 2 3 4 5 6 7 static void add_property( const StringName \u0026amp;p_class,// 类名，使用封装的ADD_PROPERTY宏时，该类名会被自动填入 const PropertyInfo \u0026amp;p_pinfo,// 属性信息 const StringName \u0026amp;p_setter,// setter 方法名 const StringName \u0026amp;p_getter,// getter 方法名 int p_index = -1 // 属性索引，默认使用-1，ADD_PROPERTYI中可以添加索引。配合add_property_array使用 ); 常用的宏定义\n1 2 #define ADD_PROPERTY(m_property, m_setter, m_getter) ::ClassDB::add_property(get_class_static(), m_property, _scs_create(m_setter), _scs_create(m_getter)) #define ADD_PROPERTYI(m_property, m_setter, m_getter, m_index) ::ClassDB::add_property(get_class_static(), m_property, _scs_create(m_setter), _scs_create(m_getter), m_index) 使用示例\n1 2 3 4 5 6 7 8 9 void MyNode::_bind_methods() { ClassDB::bind_method(D_METHOD(\u0026#34;set_value\u0026#34;, \u0026#34;index\u0026#34;, \u0026#34;value\u0026#34;), \u0026amp;MyData::set_value); ClassDB::bind_method(D_METHOD(\u0026#34;get_value\u0026#34;, \u0026#34;index\u0026#34;), \u0026amp;MyData::get_value); // 这里 p_index 分别写 0/1/2 ClassDB::add_property(\u0026#34;MyData\u0026#34;,PropertyInfo(Variant::FLOAT, \u0026#34;value_0\u0026#34;),\u0026#34;set_value\u0026#34;, \u0026#34;get_value\u0026#34;,0); //或者用宏 ADD_PROPERTY(PropertyInfo(Variant::FLOAT, \u0026#34;value_0\u0026#34;),\u0026#34;set_value\u0026#34;, \u0026#34;get_value\u0026#34;); } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 void ClassDB::add_property(const StringName \u0026amp;p_class, const PropertyInfo \u0026amp;p_pinfo, const StringName \u0026amp;p_setter, const StringName \u0026amp;p_getter, int p_index) { //锁上读锁，获取类信息 lock.read_lock(); ClassInfo *type = classes.getptr(p_class); lock.read_unlock(); //类信息非空判断 ERR_FAIL_NULL(type); //获取setter方法 MethodBind *mb_set = nullptr; if (p_setter) { mb_set = get_method(p_class, p_setter); #ifdef DEBUG_METHODS_ENABLED ERR_FAIL_NULL_MSG(mb_set, vformat(\u0026#34;Invalid setter \u0026#39;%s::%s\u0026#39; for property \u0026#39;%s\u0026#39;.\u0026#34;, p_class, p_setter, p_pinfo.name)); int exp_args = 1 + (p_index \u0026gt;= 0 ? 1 : 0); ERR_FAIL_COND_MSG(mb_set-\u0026gt;get_argument_count() != exp_args, vformat(\u0026#34;Invalid function for setter \u0026#39;%s::%s\u0026#39; for property \u0026#39;%s\u0026#39;.\u0026#34;, p_class, p_setter, p_pinfo.name)); #endif } //获取getter方法 MethodBind *mb_get = nullptr; if (p_getter) { mb_get = get_method(p_class, p_getter); #ifdef DEBUG_METHODS_ENABLED ERR_FAIL_NULL_MSG(mb_get, vformat(\u0026#34;Invalid getter \u0026#39;%s::%s\u0026#39; for property \u0026#39;%s\u0026#39;.\u0026#34;, p_class, p_getter, p_pinfo.name)); int exp_args = 0 + (p_index \u0026gt;= 0 ? 1 : 0); ERR_FAIL_COND_MSG(mb_get-\u0026gt;get_argument_count() != exp_args, vformat(\u0026#34;Invalid function for getter \u0026#39;%s::%s\u0026#39; for property \u0026#39;%s\u0026#39;.\u0026#34;, p_class, p_getter, p_pinfo.name)); #endif } //属性名称重复报错 #ifdef DEBUG_METHODS_ENABLED ERR_FAIL_COND_MSG(type-\u0026gt;property_setget.has(p_pinfo.name), vformat(\u0026#34;Object \u0026#39;%s\u0026#39; already has property \u0026#39;%s\u0026#39;.\u0026#34;, p_class, p_pinfo.name)); #endif //锁上写锁，直到函数结束 OBJTYPE_WLOCK //在classinfo中添加属性信息 type-\u0026gt;property_list.push_back(p_pinfo); type-\u0026gt;property_map[p_pinfo.name] = p_pinfo; #ifdef DEBUG_METHODS_ENABLED if (mb_get) { type-\u0026gt;methods_in_properties.insert(p_getter); } if (mb_set) { type-\u0026gt;methods_in_properties.insert(p_setter); } #endif //添加属性的set和get方法，键是属性名称 PropertySetGet psg; psg.setter = p_setter; psg.getter = p_getter; psg._setptr = mb_set; psg._getptr = mb_get; psg.index = p_index; psg.type = p_pinfo.type; type-\u0026gt;property_setget[p_pinfo.name] = psg; } add_property_array 在 Inspector 中创建一个“数组属性组”（array property group），用于显示一组以类似命名规则的属性。\n它不直接存 getter/setter，也不关联实际属性。 它是一个 虚拟属性（Variant::NIL） ，仅用于 UI 分组。 它配合add_property/ADD_PROPERTYI使用，可以创建一个定长数组属性。 它配合_set()/_get()/_get_property_list()使用，可以创建一个动态数组属性。 注意：它的使用非常复杂,需要结合Object的宏get_property_list使用。后续会有专门的章节讲解。此处仅给出一个简短的示例\n方法签名\n1 2 3 4 5 void ClassDB::add_property_array( const StringName \u0026amp;p_class, // 类名 const StringName \u0026amp;p_path, // 属性路径 const String \u0026amp;p_array_element_prefix // 数组元素前缀 ); 常用的宏定义\n1 #define ADD_ARRAY(m_array_path, m_prefix) ClassDB::add_property_array(get_class_static(), m_array_path, m_prefix) 使用示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void MyNode::_bind_methods() { ClassDB::bind_method(D_METHOD(\u0026#34;set_position\u0026#34;, \u0026#34;index\u0026#34;, \u0026#34;value\u0026#34;), \u0026amp;MyNode::set_position); ClassDB::bind_method(D_METHOD(\u0026#34;get_position\u0026#34;, \u0026#34;index\u0026#34;), \u0026amp;MyNode::get_position); // 添加数组属性组（虚拟属性），定长数组 // 添加每个实际属性，简易版本 // 对于变长数组，需要重载函数get_property_list中定义该属性数组的行为 ClassDB::add_property_array(\u0026#34;MyNode\u0026#34;, \u0026#34;positions\u0026#34;, \u0026#34;positions/\u0026#34;); for (int i = 0; i \u0026lt; 3; i++) { String name = \u0026#34;positions/\u0026#34; + itos(i); ClassDB::add_property(\u0026#34;MyNode\u0026#34;, PropertyInfo(Variant::VECTOR3, name), \u0026#34;set_position\u0026#34;, \u0026#34;get_position\u0026#34;, i); } //使用宏的版本实现 ADD_ARRAY(\u0026#34;TestProperty\u0026#34;, \u0026#34;TestProperty/\u0026#34;); ADD_PROPERTYI(PropertyInfo(Variant::COLOR,\u0026#34;TestProperty/0\u0026#34;), \u0026#34;set_TP_color\u0026#34;, \u0026#34;get_TP_color\u0026#34;,1); ADD_PROPERTYI(PropertyInfo(Variant::COLOR,\u0026#34;TestProperty/1\u0026#34;), \u0026#34;set_TP_color\u0026#34;, \u0026#34;get_TP_color\u0026#34;,2); ClassDB::add_property(\u0026#34;NsTestResource\u0026#34;, PropertyInfo(Variant::VECTOR3,\u0026#34;TestProperty/2\u0026#34;), \u0026#34;set_TP_vector3\u0026#34;, \u0026#34;get_TP_vector3\u0026#34;, 0 ); } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 //此处就非常简单，仅做了占位的属性添加 void ClassDB::add_property_array(const StringName \u0026amp;p_class, const StringName \u0026amp;p_path, const String \u0026amp;p_array_element_prefix) { //锁上写锁，直到函数结束，空值判断 OBJTYPE_WLOCK; ClassInfo *type = classes.getptr(p_class); ERR_FAIL_NULL(type); // 添加到属性组，类型为空NIL，用于占位 //注意，此处的usage属性为 PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_ARRAY ，也就是声明为了数组，以及编辑器可见 type-\u0026gt;property_list.push_back(PropertyInfo(Variant::NIL, p_path, PROPERTY_HINT_NONE, \u0026#34;\u0026#34;, PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_ARRAY, p_array_element_prefix)); } add_property_array_count 给一个类注册数组属性（Array Property）;\n通常结合自定义的_setter_ 和 _getter_以及_get_property_list_使用 可以实现自定义的变长数组 它只注册长度属性本身 方法签名\n1 2 3 4 5 6 7 8 9 static void add_property_array_count( const StringName \u0026amp;p_class, //被绑定类的类名 const String \u0026amp;p_label, //Inspector 上显示的 标签（用户可见）。 const StringName \u0026amp;p_count_property, //数组长度属性的 内部属性名。 const StringName \u0026amp;p_count_setter, //对应 setter 函数名 const StringName \u0026amp;p_count_getter, //对应 getter 函数名 const String \u0026amp;p_array_element_prefix, //数组元素的前缀 uint32_t p_count_usage = PROPERTY_USAGE_DEFAULT //属性的PropertyUsage类型 ); 常用的宏定义\n1 2 #define ADD_ARRAY_COUNT(m_label, m_count_property, m_count_property_setter, m_count_property_getter, m_prefix) ClassDB::add_property_array_count(get_class_static(), m_label, m_count_property, _scs_create(m_count_property_setter), _scs_create(m_count_property_getter), m_prefix) #define ADD_ARRAY_COUNT_WITH_USAGE_FLAGS(m_label, m_count_property, m_count_property_setter, m_count_property_getter, m_prefix, m_property_usage_flags) ClassDB::add_property_array_count(get_class_static(), m_label, m_count_property, _scs_create(m_count_property_setter), _scs_create(m_count_property_getter), m_prefix, m_property_usage_flags) 使用示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 注册数组组：名字“Colors”，长度属性名“color_count”，元素前缀“color_” //此处仅对数组长度进行注册，其他属性不注册 // _bind_methods()中 ADD_ARRAY_COUNT(\u0026#34;Colors\u0026#34;, \u0026#34;color_count\u0026#34;, \u0026#34;set_color_count\u0026#34;, \u0026#34;get_color_count\u0026#34;, \u0026#34;color_\u0026#34;); // 下方是三个配套函数：_set()、_get()、_get_property_list() // 此处真正定义的数组中属性的行为 bool NsTestResource::_set(const StringName \u0026amp;p_name, const Variant \u0026amp;p_value){ Vector\u0026lt;String\u0026gt; components = String(p_name).split(\u0026#34;/\u0026#34;, true, 2); if (components.size() \u0026gt;= 2 \u0026amp;\u0026amp; components[0].begins_with(\u0026#34;color_\u0026#34;) \u0026amp;\u0026amp; components[0].trim_prefix(\u0026#34;color_\u0026#34;).is_valid_int()) { int index = components[0].trim_prefix(\u0026#34;color_\u0026#34;).to_int(); const String \u0026amp;property = components[1]; if (property == \u0026#34;color\u0026#34;) { // set_point_position(point_index, p_value); set_color(index, p_value); return true; } if (property == \u0026#34;shader\u0026#34;) { set_shader(index,p_value); return true; } } return false; } bool NsTestResource::_get(const StringName \u0026amp;p_name, Variant \u0026amp;r_ret)const { Vector\u0026lt;String\u0026gt; components = String(p_name).split(\u0026#34;/\u0026#34;, true, 2); if (components.size() \u0026gt;= 2 \u0026amp;\u0026amp; components[0].begins_with(\u0026#34;color_\u0026#34;) \u0026amp;\u0026amp; components[0].trim_prefix(\u0026#34;color_\u0026#34;).is_valid_int()) { int index = components[0].trim_prefix(\u0026#34;color_\u0026#34;).to_int(); const String \u0026amp;property = components[1]; if (property == \u0026#34;color\u0026#34;) { r_ret = get_color(index); return true; } if (property == \u0026#34;shader\u0026#34;) { r_ret = get_shader(index); return true; } } return false; } void NsTestResource::_get_property_list(List\u0026lt;PropertyInfo\u0026gt; *p_list)const { print_line(\u0026#34;NsTestResource::_get_property_list\u0026#34;); for (int i = 0; i \u0026lt; colors.size();i++) { PropertyInfo pi = PropertyInfo(Variant::COLOR, vformat(\u0026#34;color_%d/color\u0026#34;,i)); p_list-\u0026gt;push_back(pi); pi = PropertyInfo(Variant::OBJECT, vformat(\u0026#34;color_%d/shader\u0026#34;,i),PROPERTY_HINT_RESOURCE_TYPE, \u0026#34;Shader\u0026#34;); p_list-\u0026gt;push_back(pi); } } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 void ClassDB::add_property_array_count(const StringName \u0026amp;p_class, const String \u0026amp;p_label, const StringName \u0026amp;p_count_property, const StringName \u0026amp;p_count_setter, const StringName \u0026amp;p_count_getter, const String \u0026amp;p_array_element_prefix, uint32_t p_count_usage) { add_property(p_class, PropertyInfo(Variant::INT, //属性类型为INT p_count_property, //属性名 PROPERTY_HINT_NONE, //提示为无提示 \u0026#34;\u0026#34;, //提示信息为空 p_count_usage | PROPERTY_USAGE_ARRAY, //数组属性 vformat(\u0026#34;%s,%s\u0026#34;, p_label, p_array_element_prefix) //类名为标签和前缀的组装 ), p_count_setter, //属性设置函数 p_count_getter //属性获取函数 ); } add_property_group ClassDB::add_property_group()用于在 Godot Inspector（属性面板）中创建一条分组标题，让多个属性显示在同一个折叠组下，从而让 Inspector 清晰整洁。 方法签名\n1 2 3 4 5 6 void ClassDB::add_property_group( const StringName \u0026amp;p_class, //自身类名 const String \u0026amp;p_name, const //分组标题 String \u0026amp;p_prefix, //分组前缀，其他具有该前缀的属性将显示在本分组下 int p_indent_depth = 0 //分组缩进深度 ); 常用的宏定义\n1 2 3 4 //使用默认缩进 0 #define ADD_GROUP(m_name, m_prefix) ::ClassDB::add_property_group(get_class_static(), m_name, m_prefix) //使用自定义缩进 #define ADD_GROUP_INDENT(m_name, m_prefix, m_depth) ::ClassDB::add_property_group(get_class_static(), m_name, m_prefix, m_depth) 使用示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void Resource::_bind_methods() { ADD_GROUP(\u0026#34;AddGroup1\u0026#34;, \u0026#34;addGroup1_\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup1_Color0\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup1_Color1\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_GROUP_INDENT(\u0026#34;AddGroup2\u0026#34;, \u0026#34;AddGroup2_\u0026#34;,1); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;AddGroup2_Color2\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;AddGroup2_Color3\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_SUBGROUP(\u0026#34;AddGroup3\u0026#34;, \u0026#34;addGroup3_\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup3_Color4\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup3_Color5\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_SUBGROUP_INDENT(\u0026#34;AddGroup4\u0026#34;, \u0026#34;addGroup4_\u0026#34;,2); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup4_Color6\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup4_Color7\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void ClassDB::add_property_group(const StringName \u0026amp;p_class, const String \u0026amp;p_name, const String \u0026amp;p_prefix, int p_indent_depth) { // 锁上读锁，获取类型信息指针，非空检测 OBJTYPE_WLOCK; ClassInfo *type = classes.getptr(p_class); ERR_FAIL_NULL(type); //根据缩进，进行前缀拼接 String prefix = p_prefix; if (p_indent_depth \u0026gt; 0) { prefix = vformat(\u0026#34;%s,%d\u0026#34;, p_prefix, p_indent_depth); } //在类型信息的property_list中，填入分组的属性 type-\u0026gt;property_list.push_back( PropertyInfo(Variant::NIL, //占位 p_name, //分组名 PROPERTY_HINT_NONE, //无提示 prefix, //前缀 PROPERTY_USAGE_GROUP//使用类型为 分组 ) ); } get_property_list 本质还是对ClassInfo中的property_list的遍历读.\n注意，此处的ClassDB::get_property_list仅有查询的功能，并不会触发我们自己重写的_get_property_list()函数。\n如果需要走自定义的_get_property_list()函数，请使用YourObject.get_property_list()的方式来查询。\nobject中的GDCLASS(m_class, m_inherits)宏中包装了_get_property_listv方法，用于获取属性列表时调用自定义的_get_property_list()函数。\n方法签名\n1 2 3 4 5 6 static void get_property_list( const StringName \u0026amp;p_class, //需要查询类的名称 List\u0026lt;PropertyInfo\u0026gt; *p_list, //返回的属性列表 bool p_no_inheritance = false,//是否向上查询父类,默认查询 const Object *p_validator = nullptr)//关联的实际类，可以不关联 ; 使用示例\n1 2 List\u0026lt;PropertyInfo\u0026gt; list; ClassDB::get_property_list(\u0026#34;YourObject\u0026#34;, \u0026amp;list,true); 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void ClassDB::get_property_list(const StringName \u0026amp;p_class, List\u0026lt;PropertyInfo\u0026gt; *p_list, bool p_no_inheritance, const Object *p_validator) { //锁上读锁,直到出作用域 OBJTYPE_RLOCK; //逐级向父类查询类型信息 ClassInfo *type = classes.getptr(p_class); ClassInfo *check = type; while (check) { //遍历属性列表信息 for (const PropertyInfo \u0026amp;pi : check-\u0026gt;property_list) { //是否关联实例 if (p_validator) { // Making a copy as we may modify it. PropertyInfo pi_mut = pi; p_validator-\u0026gt;validate_property(pi_mut); p_list-\u0026gt;push_back(pi_mut); } else { //不关联就将property_list直接推入列表p_list p_list-\u0026gt;push_back(pi); } } //是否查询父类，如果不查询，直接返回 if (p_no_inheritance) { return; } //变更为父类类型信息指针 check = check-\u0026gt;inherits_ptr; } } get_property 方法签名\n1 2 3 4 5 bool ClassDB::get_property( Object *p_object, //被查询的实例 const StringName \u0026amp;p_property, //属性名 Variant \u0026amp;r_value//属性值 ); 使用示例\n1 bool ret = ClassDB::get_property(\u0026#34;MyObject\u0026#34;, \u0026#34;property_name\u0026#34;, value); 源码解读（带注释）\n注：PropertySetGet定义详见此处\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 bool ClassDB::get_property(Object *p_object, const StringName \u0026amp;p_property, Variant \u0026amp;r_value) { //空指针检测 ERR_FAIL_NULL_V(p_object, false); //向上逐级查询类型信息 ClassInfo *type = classes.getptr(p_object-\u0026gt;get_class_name()); ClassInfo *check = type; while (check) { //查询类型信息中的property_setget const PropertySetGet *psg = check-\u0026gt;property_setget.getptr(p_property); if (psg) { //存在PropertySetGet，但是没有getter方法 if (!psg-\u0026gt;getter) { return true; //return true but do nothing } if (psg-\u0026gt;index \u0026gt;= 0) { Variant index = psg-\u0026gt;index; const Variant *arg[1] = { \u0026amp;index }; Callable::CallError ce; //利用对象实例的callp方法，动态调用该属性的getter方法 //对于索引不为-1（数组）的属性值，需要传入索引参数 const Variant value = p_object-\u0026gt;callp(psg-\u0026gt;getter, arg, 1, ce); r_value = (ce.error == Callable::CallError::CALL_OK) ? value : Variant(); } else { Callable::CallError ce; if (psg-\u0026gt;_getptr) { //通过MethodBind指针_getptr调用getter方法 r_value = psg-\u0026gt;_getptr-\u0026gt;call(p_object, nullptr, 0, ce); } else { const Variant value = p_object-\u0026gt;callp(psg-\u0026gt;getter, nullptr, 0, ce); r_value = (ce.error == Callable::CallError::CALL_OK) ? value : Variant(); } } return true; } const int64_t *c = check-\u0026gt;constant_map.getptr(p_property); //constants count if (c) { r_value = *c; return true; } if (check-\u0026gt;method_map.has(p_property)) { //methods count r_value = Callable(p_object, p_property); return true; } if (check-\u0026gt;signal_map.has(p_property)) { //signals count r_value = Signal(p_object, p_property); return true; } check = check-\u0026gt;inherits_ptr; } // The \u0026#34;free()\u0026#34; method is special, so we assume it exists and return a Callable. if (p_property == CoreStringName(free_)) { r_value = Callable(p_object, p_property); return true; } return false; } 函数接口 函数相关的接口，是ClassDB中最复杂的一组，涉及到函数的绑定，所以godot用了非常多的模板来实现。 它的信息存储在ClassInfo的下面两个成员变量中：\nHashMap\u0026lt;StringName, MethodBind *\u0026gt; method_map; HashMap\u0026lt;StringName, LocalVector\u0026lt;MethodBind *\u0026gt;\u0026gt; method_map_compatibility; 接口 作用 bind_method 类型注册时的函数绑定方法，用的非常广泛 has_method 查询是类否包含某个函数，通过classinfo的method_map来查询 get_method_list 查询某个类的所有函数信息MethodInfo,通过classinfo的method_map来查询 bind_method bind_method的主要作用是把一个C++成员函数，封装成一个MethodBind，然后再注册进ClassDB的类型信息中，路径为：classdb::classes-\u0026gt;ClassInfo::method_map\n该方法使用非常简单，但是内部实现极其复杂，笔者代码能力有限，仅能做部分代码的解读。因此该函数的介绍，会更偏向使用。\nMethodDefinition 在下方有详细描述，它仅是字符串的描述 方法签名\n1 2 3 4 5 6 template \u0026lt;typename N, typename M, typename... VarArgs\u0026gt; static MethodBind *bind_method( N p_method_name, //函数名、参数列表的描述，MethodDefinition类型，利用D_METHOD()生成 M p_method, //成员函数指针，例如 \u0026amp;Input::warp_mouse VarArgs... p_args //函数默认值参数包 ); 使用示例\nDEFVAL用于函数默认值参数的包装，它的排序对应函数签名的后N位。\n以下方testfunc的函数绑定为例：\narg4 = 0.0f arg5 = -1.0f 1 2 3 4 void Input::_bind_methods() { ClassDB::bind_method(D_METHOD(\u0026#34;is_anything_pressed\u0026#34;), \u0026amp;Input::is_anything_pressed); ClassDB::bind_method(D_METHOD(\u0026#34;testfunc\u0026#34;, \u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;, \u0026#34;arg3\u0026#34;, \u0026#34;arg4\u0026#34;, \u0026#34;arg5\u0026#34;), \u0026amp;Input::testfunc, DEFVAL(0.0f),DEFVAL(-1.0f)); } 源码解读（带注释）\n通过上面的示例代码，可以看到要正确绑定一个函数，需要使用两个函数\nD_METHOD 创建MethodDefinition，用于描述函数的参数列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template \u0026lt;typename... VarArgs\u0026gt; MethodDefinition D_METHOD(const char *p_name, const VarArgs... p_args) { //创建参数列表args,利用列表初始化展开参数包p_args //收集所有参数名称 const char *args[sizeof...(p_args) + 1] = { p_args..., nullptr }; // +1 makes sure zero sized arrays are also supported. const char *const *argptrs[sizeof...(p_args) + 1]; for (uint32_t i = 0; i \u0026lt; sizeof...(p_args); i++) { argptrs[i] = \u0026amp;args[i]; } //将收集的参数列表，传入D_METHODP()进行MD的创建 return D_METHODP(p_name, sizeof...(p_args) == 0 ? nullptr : (const char *const **)argptrs, sizeof...(p_args)); } MethodDefinition D_METHODP(const char *p_name, const char *const **p_args, uint32_t p_argcount) { //实际创建MethodDefinition，填入函数名称和参数名称列表 MethodDefinition md; md.name = StaticCString::create(p_name); md.args.resize(p_argcount); for (uint32_t i = 0; i \u0026lt; p_argcount; i++) { md.args.write[i] = StaticCString::create(*p_args[i]); } return md; } ClassDB::bind_method 执行函数绑定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;typename N, typename M, typename... VarArgs\u0026gt; static MethodBind *bind_method(N p_method_name, M p_method, VarArgs... p_args) { //创建参数列表args,利用列表初始化展开参数包p_args Variant args[sizeof...(p_args) + 1] = { p_args..., Variant() }; // +1 makes sure zero sized arrays are also supported. //创建参数指针列表argptrs const Variant *argptrs[sizeof...(p_args) + 1]; //遍历参数列表args，并将参数指针保存到argptrs中 for (uint32_t i = 0; i \u0026lt; sizeof...(p_args); i++) { argptrs[i] = \u0026amp;args[i]; } //创建函数绑定MethodBind //此处比较复杂，暂时不展开 MethodBind *bind = create_method_bind(p_method); if constexpr (std::is_same_v\u0026lt;typename member_function_traits\u0026lt;M\u0026gt;::return_type, Object *\u0026gt;) { bind-\u0026gt;set_return_type_is_raw_object_ptr(true); } //将函数绑定信息的注册到ClassDB中 return bind_methodfi(METHOD_FLAGS_DEFAULT, bind, false, p_method_name, sizeof...(p_args) == 0 ? nullptr : (const Variant **)argptrs, sizeof...(p_args)); } get_method_list 信息类 ClassInfo ClassInfo是ClassDB中定义的类信息结构体，它保存了类的元数据，比如类的名称、继承关系、成员变量、方法、属性等信息。下方截取了4.4版本godot源码中ClassInfo类的部分代码，并标注了一些重要的信息，帮助我们去整体的理解ClassInfo的运行原理。为了方便理解，方法和属性的顺序，并非与源码严格一致。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct ClassInfo { // 根据注册的时机和接口不同，API类型有以下5种： // API_CORE、 // API_EDITOR、 // API_EXTENSION、 // API_EDITOR_EXTENSION、 // API_NONE APIType api = API_NONE; //父类的类信息指针 ClassInfo *inherits_ptr = nullptr; void *class_ptr = nullptr; //gdextension指针 ObjectGDExtension *gdextension = nullptr; //类的方法信息，键是方法名，值是方法绑定 HashMap\u0026lt;StringName, MethodBind *\u0026gt; method_map; HashMap\u0026lt;StringName, LocalVector\u0026lt;MethodBind *\u0026gt;\u0026gt; method_map_compatibility; HashMap\u0026lt;StringName, int64_t\u0026gt; constant_map; struct EnumInfo { List\u0026lt;StringName\u0026gt; constants; bool is_bitfield = false; }; HashMap\u0026lt;StringName, EnumInfo\u0026gt; enum_map; //类信号信息，键是信号名 HashMap\u0026lt;StringName, MethodInfo\u0026gt; signal_map; //类属性信息列表 List\u0026lt;PropertyInfo\u0026gt; property_list; //类属性信息，键是属性名称，值是属性信息 HashMap\u0026lt;StringName, PropertyInfo\u0026gt; property_map; //类属性set/get信息，键是属性名称，值是属性设置和获取方法信息 HashMap\u0026lt;StringName, PropertySetGet\u0026gt; property_setget; HashMap\u0026lt;StringName, Vector\u0026lt;uint32_t\u0026gt;\u0026gt; virtual_methods_compat; //父类名称 StringName inherits; //自身类名 StringName name; bool disabled = false; bool exposed = false; bool reloadable = false; bool is_virtual = false; bool is_runtime = false; // The bool argument indicates the need to postinitialize. Object *(*creation_func)(bool) = nullptr; ClassInfo() {} ~ClassInfo() {} }; MethodDefinition 1 2 3 4 5 6 7 8 9 struct MethodDefinition { StringName name;//方法名称 Vector\u0026lt;StringName\u0026gt; args;//方法参数名称列表 MethodDefinition() {} MethodDefinition(const char *p_name) : name(p_name) {} MethodDefinition(const StringName \u0026amp;p_name) : name(p_name) {} }; MethodInfo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 struct MethodInfo { String name; PropertyInfo return_val; uint32_t flags = METHOD_FLAGS_DEFAULT; int id = 0; List\u0026lt;PropertyInfo\u0026gt; arguments; Vector\u0026lt;Variant\u0026gt; default_arguments; int return_val_metadata = 0; Vector\u0026lt;int\u0026gt; arguments_metadata; int get_argument_meta(int p_arg) const { ERR_FAIL_COND_V(p_arg \u0026lt; -1 || p_arg \u0026gt; arguments.size(), 0); if (p_arg == -1) { return return_val_metadata; } return arguments_metadata.size() \u0026gt; p_arg ? arguments_metadata[p_arg] : 0; } inline bool operator==(const MethodInfo \u0026amp;p_method) const { return id == p_method.id \u0026amp;\u0026amp; name == p_method.name; } inline bool operator\u0026lt;(const MethodInfo \u0026amp;p_method) const { return id == p_method.id ? (name \u0026lt; p_method.name) : (id \u0026lt; p_method.id); } operator Dictionary() const; static MethodInfo from_dict(const Dictionary \u0026amp;p_dict); uint32_t get_compatibility_hash() const; MethodInfo() {} explicit MethodInfo(const GDExtensionMethodInfo \u0026amp;pinfo) : name(*reinterpret_cast\u0026lt;StringName *\u0026gt;(pinfo.name)), return_val(PropertyInfo(pinfo.return_value)), flags(pinfo.flags), id(pinfo.id) { for (uint32_t j = 0; j \u0026lt; pinfo.argument_count; j++) { arguments.push_back(PropertyInfo(pinfo.arguments[j])); } const Variant *def_values = (const Variant *)pinfo.default_arguments; for (uint32_t j = 0; j \u0026lt; pinfo.default_argument_count; j++) { default_arguments.push_back(def_values[j]); } } void _push_params(const PropertyInfo \u0026amp;p_param) { arguments.push_back(p_param); } template \u0026lt;typename... VarArgs\u0026gt; void _push_params(const PropertyInfo \u0026amp;p_param, VarArgs... p_params) { arguments.push_back(p_param); _push_params(p_params...); } MethodInfo(const String \u0026amp;p_name) { name = p_name; } template \u0026lt;typename... VarArgs\u0026gt; MethodInfo(const String \u0026amp;p_name, VarArgs... p_params) { name = p_name; _push_params(p_params...); } MethodInfo(Variant::Type ret) { return_val.type = ret; } MethodInfo(Variant::Type ret, const String \u0026amp;p_name) { return_val.type = ret; name = p_name; } template \u0026lt;typename... VarArgs\u0026gt; MethodInfo(Variant::Type ret, const String \u0026amp;p_name, VarArgs... p_params) { name = p_name; return_val.type = ret; _push_params(p_params...); } MethodInfo(const PropertyInfo \u0026amp;p_ret, const String \u0026amp;p_name) { return_val = p_ret; name = p_name; } template \u0026lt;typename... VarArgs\u0026gt; MethodInfo(const PropertyInfo \u0026amp;p_ret, const String \u0026amp;p_name, VarArgs... p_params) { return_val = p_ret; name = p_name; _push_params(p_params...); } }; MethodBind MethodBind实现比较复杂，此处仅列出部分成员函数和成员变量，用于理解它的作用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MethodBind { int method_id; uint32_t hint_flags = METHOD_FLAGS_DEFAULT; StringName name; StringName instance_class; Vector\u0026lt;Variant\u0026gt; default_arguments; int default_argument_count = 0; int argument_count = 0; bool _static = false; bool _const = false; bool _returns = false; bool _returns_raw_obj_ptr = false; // ... } PropertyInfo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 struct PropertyInfo { Variant::Type type = Variant::NIL; String name; StringName class_name; // For classes PropertyHint hint = PROPERTY_HINT_NONE; String hint_string; uint32_t usage = PROPERTY_USAGE_DEFAULT; // If you are thinking about adding another member to this class, ask the maintainer (Juan) first. _FORCE_INLINE_ PropertyInfo added_usage(uint32_t p_fl) const { PropertyInfo pi = *this; pi.usage |= p_fl; return pi; } operator Dictionary() const; static PropertyInfo from_dict(const Dictionary \u0026amp;p_dict); PropertyInfo() {} PropertyInfo(const Variant::Type p_type, const String \u0026amp;p_name, const PropertyHint p_hint = PROPERTY_HINT_NONE, const String \u0026amp;p_hint_string = \u0026#34;\u0026#34;, const uint32_t p_usage = PROPERTY_USAGE_DEFAULT, const StringName \u0026amp;p_class_name = StringName()) : type(p_type), name(p_name), hint(p_hint), hint_string(p_hint_string), usage(p_usage) { if (hint == PROPERTY_HINT_RESOURCE_TYPE) { class_name = hint_string; } else { class_name = p_class_name; } } PropertyInfo(const StringName \u0026amp;p_class_name) : type(Variant::OBJECT), class_name(p_class_name) {} explicit PropertyInfo(const GDExtensionPropertyInfo \u0026amp;pinfo) : type((Variant::Type)pinfo.type), name(*reinterpret_cast\u0026lt;StringName *\u0026gt;(pinfo.name)), class_name(*reinterpret_cast\u0026lt;StringName *\u0026gt;(pinfo.class_name)), hint((PropertyHint)pinfo.hint), hint_string(*reinterpret_cast\u0026lt;String *\u0026gt;(pinfo.hint_string)), usage(pinfo.usage) {} bool operator==(const PropertyInfo \u0026amp;p_info) const { return ((type == p_info.type) \u0026amp;\u0026amp; (name == p_info.name) \u0026amp;\u0026amp; (class_name == p_info.class_name) \u0026amp;\u0026amp; (hint == p_info.hint) \u0026amp;\u0026amp; (hint_string == p_info.hint_string) \u0026amp;\u0026amp; (usage == p_info.usage)); } bool operator\u0026lt;(const PropertyInfo \u0026amp;p_info) const { return name \u0026lt; p_info.name; } }; PropertySetGet 1 2 3 4 5 6 7 8 struct PropertySetGet { int index;\t//属性索引，默认为-1，数组索引从0开始 StringName setter;\t//setter函数名 StringName getter;\t//getter函数名 MethodBind *_setptr = nullptr; //setter函数包指针 MethodBind *_getptr = nullptr; //getter函数包指针 Variant::Type type;\t//属性类型 }; ","date":"2025-11-07T09:18:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E4%BA%94godot%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9Frtti/","title":"【godot】五、godot中的动态类型信息系统RTTI"},{"content":"性能分析相关 godot作为相对成熟的游戏引擎，其本身就提供了相对完善的运行时性能监测工具。本文将对常用的运行时性能参数的获取和使用进行一个简易的说明，旨在帮助大家了解获取及理解这些参数。\nPerformance Performance是godot内置的性能数据存储器，它提供对许多与性能相关的不同监视器的访问，例如贴图内存使用情况 :RENDER_BUFFER_MEM_USED（在glbufferData的时候，会对申请的size进行累加）、绘制调用:RENDER_TOTAL_DRAW_CALLS_IN_FRAME （gldraw的时候加一）FPS。\n这些值与编辑器的调试器面板中的监视选项卡中显示的值相同。通过使用该类的 get_monitor() 方法，你可以从代码中访问该数据。\n注意：某些内置监视器仅在调试模式下可用，并且在以发布模式导出的项目中使用时，将始终返回 0。\n注意：出于性能原因，某些内置监视器不会实时更新，所以在更改之间可能会有长达 1 秒的延迟。\n注意：自定义监视器不支持负值。负值被钳制为 0\n1 2 //Performance::TIME_FPS是提前内置的Monitor Performance::get_singleton()-\u0026gt;get_monitor(Performance::TIME_FPS); 名称 作用 TIME_FPS 帧率（每秒帧数） TIME_PROCESS 每帧的处理时间（不包括物理和导航过程），c++/Gdscript TIME_PHYSICS_PROCESS 物理处理的时间 MEMORY_STATIC 静态内存使用量（不包括动态内存） MEMORY_STATIC_MAX 静态内存的最大使用量 MEMORY_MESSAGE_BUFFER_MAX 消息缓冲区的最大内存使用量 OBJECT_COUNT 当前场景中的总对象数 OBJECT_RESOURCE_COUNT 当前场景中资源的数量 OBJECT_NODE_COUNT 当前场景中节点的数量 OBJECT_ORPHAN_NODE_COUNT 孤立节点的数量（没有父节点的节点） RENDER_TOTAL_OBJECTS_IN_FRAME 每帧渲染的总对象数量 RENDER_TOTAL_PRIMITIVES_IN_FRAME 每帧渲染的总图形原语数量（如三角形、线条） RENDER_TOTAL_DRAW_CALLS_IN_FRAME 每帧渲染的总绘制调用次数 RENDER_TEXTURE_MEM_USED 渲染使用的纹理内存量 RENDER_BUFFER_MEM_USED 渲染使用的缓冲区内存量 MEMORY_STATIC Performance中的静态内存数据，包含了godot体系下的所有用户申请的内存，也即Variant中被标注的变量。\n**注意：**cpp原生类型申请的内存空间并不会被统计进去。\n该数据被实际存储在Memary类中，出于线程安全考虑，它被包装在一个原子类型中：\nRENDER_TEXTURE_MEM_USED 在gl渲染模式下，由于并没有RenderDevice层，都是直接使用的gl接口，因此数据的记录相对更加直接。\nperformancce中访问的RENDER_TEXTURE_MEM_USED是通过**RenderingServer提供的get_rendering_info**接口来获取的。\n在往下走就是RGS::RendererUtilities提供的**get_rendering_info**接口，在Utilities中，管理着gl申请出来的所有内存。\n在每一次申请和删除渲染gl内存时，Utilities都会对内存大小的统计数字做出相应的增减。\n我们在日常开发中遇到的资源泄露报错，就来自于Utilities的析构函数。\n当Utilities发生析构时，如果gl申请的内存未被完全释放，就会打印该条报错日志。（常由于孤立节点未被正确释放导致）\nRENDER_TOTAL_DRAW_CALLS_IN_FRAME performancce中访问的RENDER_TOTAL_DRAW_CALLS_IN_FRAME也是通过**RenderingServer提供的get_rendering_info接口来获取的。而RenderingServer查询的数据，则来自RendererViewport**的total_draw_calls_used。\nRendererViewport中这组数据，则是在绘制阶段draw_viewports()时，收集累加激活状态的Viewport中的render_info中的数据。\n对于每个激活的Viewport中的drawcall，会在gl光栅化的阶段，也就是实际调用gl绘制函数的时候，进行一次增加。\n**注意：**基于这一点，手动调用的绘制操作glDrawElements等，不会被统计进godot的Drawcall中。因此应尽量避免gl相关函数的直接调用。而应该通过godot的封装层RenderingServer来调用。\nRenderingServer Godot当中的RenderingServer相当于Unreal中的RHI，它是底层的渲染抽象层，负责与图形 API（如 OpenGL、Vulkan、DirectX、Metal 等）交互。\n同时它也存储了渲染相关的数据，并且提供了对应的获取接口。\nget_rendering_info get_rendering_info可以查询渲染绘制相关的信息，有以下几种：\n名称 说明 RENDERING_INFO_TOTAL_OBJECTS_IN_FRAME 绘制对象数量 RENDERING_INFO_TOTAL_PRIMITIVES_IN_FRAME 绘制图元数量 RENDERING_INFO_TOTAL_DRAW_CALLS_IN_FRAME DrawCall RENDERING_INFO_TEXTURE_MEM_USED 贴图内存 RENDERING_INFO_BUFFER_MEM_USED glbuffer RENDERING_INFO_VIDEO_MEM_USED RENDERING_INFO_PIPELINE_COMPILATIONS_CANVAS 渲染管线（Pipeline）编译的次数 RENDERING_INFO_PIPELINE_COMPILATIONS_MESH RENDERING_INFO_PIPELINE_COMPILATIONS_SURFACE RENDERING_INFO_PIPELINE_COMPILATIONS_DRAW RENDERING_INFO_PIPELINE_COMPILATIONS_SPECIALIZATION viewport_get_render_info 与上方接口差不多，但是针对某个视口，而非所有。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enum ViewportRenderInfo { VIEWPORT_RENDER_INFO_OBJECTS_IN_FRAME, VIEWPORT_RENDER_INFO_PRIMITIVES_IN_FRAME, VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME, VIEWPORT_RENDER_INFO_MAX, }; enum ViewportRenderInfoType { VIEWPORT_RENDER_INFO_TYPE_VISIBLE, VIEWPORT_RENDER_INFO_TYPE_SHADOW, VIEWPORT_RENDER_INFO_TYPE_CANVAS, VIEWPORT_RENDER_INFO_TYPE_MAX }; virtual int viewport_get_render_info(RID p_viewport, ViewportRenderInfoType p_type, ViewportRenderInfo p_info) = 0; Rander GPU and CPU Time 注意，需要利用下面两个接口时，需要利用viewport_set_measure_render_time()接口提前开启时间统计，否则始终返回0.\nviewport_get_measured_render_time_cpu，CPU 在指定 Viewport 上执行渲染的耗时 viewport_get_measured_render_time_gpu，GPU 在指定 Viewport 上执行渲染的耗时 get_frame_setup_time_cpu 准备渲染命令 阶段所消耗的时间 场景剔除（Culling） 渲染对象排序 光源与阴影的分配 材质/渲染状态设置 将渲染数据写入命令缓冲（command buffer） time .get_ticks_usec()获取godot主线程时间\nRenderingDevice(gl不支持) RENDER_TIMESTAMP 其实是引擎渲染管线里的一类 GPU 时间戳 (Timestamp) 标记。\n通过**RenderingDevice**可以获取某个阶段的时间戳。具体方法如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;godot_cpp/classes/rendering_server.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/rendering_device.hpp\u0026gt; using namespace godot; void dump_gpu_pass_times_ms() { Ref\u0026lt;RenderingDevice\u0026gt; rd = RenderingServer::get_singleton()-\u0026gt;get_rendering_device(); if (rd.is_null()) return; const uint32_t count = rd-\u0026gt;get_captured_timestamps_count(); // 采集到的标签数 const uint64_t frame = rd-\u0026gt;get_captured_timestamps_frame(); // 对应的帧号（可选） for (uint32_t i = 0; i \u0026lt; count; i++) { String name = rd-\u0026gt;get_captured_timestamp_name(i); // 例如 \u0026#34;Depth Prepass\u0026#34; double gpu_ms = rd-\u0026gt;get_captured_timestamp_gpu_time(i) / 1e6; // 纳秒→毫秒 double cpu_ms = rd-\u0026gt;get_captured_timestamp_cpu_time(i) / 1e6; // 你可以筛选/重命名/累加到自己的统计里 UtilityFunctions::print(vformat(\u0026#34;[%s] GPU %.3f ms, CPU %.3f ms (frame %d)\u0026#34;, name, gpu_ms, cpu_ms, (int)frame)); } } godott-benchmark godott-benchmark是godot官方提供的测试工程，它可以针对不同芯片，测试当前godot版本的各项功能耗时。\n可以利用它作为性能基准。\n渲染CPU：渲染每帧所花费的平均CPU时间（例如设置绘制调用）。这个度量不考虑过程/物理过程功能。 渲染GPU：每帧平均花费的GPU时间。 空闲：c++和GDScript进程函数每秒所花费的平均CPU时间。 物理：每秒在c++和GDScript物理处理函数中花费的平均CPU时间。 主线程时间：在主线程上设置场景所花费的时间。对于渲染基准测试，它作为加载时间度量。 ","date":"2025-11-05T09:18:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E5%9B%9B%E6%80%A7%E8%83%BD%E7%BB%9F%E8%AE%A1/","title":"【godot】四、性能统计"},{"content":"一、SRC编写 Godot中不推荐使用#pragma once，而是推荐使用**#ifndef**的方式，来保证头文件的单次引用，参考下方行1。 类内第一行，必须打上Godot的对应宏GDCLASS(SelfClass,BaseClass)，参考下方行12。 对于需要暴露到脚本的函数，需要在**_bind_methods**中用 ClassDB::bind_method进行绑定，参考行178、179 对于需要暴露到脚本的属性，需要在**_bind_methods中用ADD_PROPERTY**进行绑定，参考行181、182、183 对于需要暴露到脚本的枚举，需要用VARIANT_ENUM_CAST以及在**_bind_methods中用BIND_ENUM_CONSTANT**进行注册，参考行：63、166、199 对于需要暴露到脚本的位域，需要用VARIANT_BITFIELD_CAST以及在**_bind_methods中用BIND_BITFIELD_FLAG**进行注册，参考行：64、171、203 对于需要信号（回调），需要用ADD_SIGNAL注册并用emit_signal发送，以及可以用connect绑定，参考行：78、100、176 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/texture2d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: enum ETest{ None, Enum1, Enum2, Num }; enum EFlag{ FlagNone = 0, Flag1 = 1 \u0026lt;\u0026lt; 0, Flag2 = 1 \u0026lt;\u0026lt; 1, Flag3 = 1 \u0026lt;\u0026lt; 2, }; public: Test(); ~Test(); void StartTest(); void StartTest2(); int GetIValue(); void SetIValue(int input); float GetFValue(); void SetFValue(float input); String GetSValue(); void SetSValue(String input); Ref\u0026lt;Texture2D\u0026gt; GetTValue(); void SetTValue(Ref\u0026lt;Texture2D\u0026gt; input); ETest GetEValue(); void SetEValue(ETest input); BitField\u0026lt;EFlag\u0026gt; GetFlagValue(); void SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input); protected: static void _bind_methods(); private: int IValue = 0; float FValue = 0.0f; String SValue = \u0026#34;Hello\u0026#34;; Ref\u0026lt;Texture2D\u0026gt; TValue; ETest EValue = ETest::None; BitField\u0026lt;EFlag\u0026gt; flag = EFlag::FlagNone; }; VARIANT_ENUM_CAST(Test::ETest); VARIANT_BITFIELD_CAST(Test::EFlag); #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/image_texture.hpp\u0026gt; Test::Test() { connect(\u0026#34;ready\u0026#34;,Callable(this,\u0026#34;StartTest2\u0026#34;)); } Test::~Test() { } void Test::StartTest() { UtilityFunctions::print(\u0026#34;AAAAAAAAAAAAAAAA\u0026#34;); Ref\u0026lt;ImageTexture\u0026gt; AA(memnew(ImageTexture)); UtilityFunctions::print(\u0026#34;AAAAAAAAAAAAAAAA:\u0026#34;,AA-\u0026gt;get_reference_count()); auto format = AA-\u0026gt;get_format(); Ref\u0026lt;ImageTexture\u0026gt; BB = AA; UtilityFunctions::print(\u0026#34;AAAAAAAAAAAAAAAA:\u0026#34;,AA-\u0026gt;get_reference_count()); } void Test::StartTest2() { UtilityFunctions::print(\u0026#34;BBBBBBBBBBBBBBB:\u0026#34;,IValue); emit_signal(\u0026#34;HelloSignal\u0026#34;,\u0026#34;CCCCCCCCCCCCCCCCCCC\u0026#34;); // UtilityFunctions::print(\u0026#34;BBBBBBBBBBBBBBB:\u0026#34;,IValue,\u0026#34;---\u0026#34;,FValue,\u0026#34;---\u0026#34;,SValue,\u0026#34;---\u0026#34;,TValue-\u0026gt;get_name()); } int Test::GetIValue() { return IValue; } void Test::SetIValue(int input) { IValue = input; } float Test::GetFValue() { return FValue; } void Test::SetFValue(float input) { FValue = input; } String Test::GetSValue() { return SValue; } void Test::SetSValue(String input) { SValue = input; } Ref\u0026lt;Texture2D\u0026gt; Test::GetTValue() { return TValue; } void Test::SetTValue(Ref\u0026lt;Texture2D\u0026gt; input) { TValue = input; } Test::ETest Test::GetEValue() { return EValue; } void Test::SetEValue(ETest input) { EValue = input; } BitField\u0026lt;Test::EFlag\u0026gt; Test::GetFlagValue() { return flag; } void Test::SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input) { flag = input; } void Test::_bind_methods() { BIND_ENUM_CONSTANT(None); BIND_ENUM_CONSTANT(Enum1); BIND_ENUM_CONSTANT(Enum2); BIND_ENUM_CONSTANT(Num); BIND_BITFIELD_FLAG(FlagNone); BIND_BITFIELD_FLAG(Flag1); BIND_BITFIELD_FLAG(Flag2); BIND_BITFIELD_FLAG(Flag3); ADD_SIGNAL(MethodInfo(\u0026#34;HelloSignal\u0026#34;,PropertyInfo(Variant::STRING,\u0026#34;message\u0026#34;))); ClassDB::bind_method(D_METHOD(\u0026#34;StartTest\u0026#34;),\u0026amp;Test::StartTest); ClassDB::bind_method(D_METHOD(\u0026#34;StartTest2\u0026#34;),\u0026amp;Test::StartTest2); ClassDB::bind_method(D_METHOD(\u0026#34;GetIValue\u0026#34;),\u0026amp;Test::GetIValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetIValue\u0026#34;,\u0026#34;IValue\u0026#34;),\u0026amp;Test::SetIValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;IValue\u0026#34;),\u0026#34;SetIValue\u0026#34;,\u0026#34;GetIValue\u0026#34;); ClassDB::bind_method(D_METHOD(\u0026#34;GetFValue\u0026#34;),\u0026amp;Test::GetFValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetFValue\u0026#34;,\u0026#34;FValue\u0026#34;),\u0026amp;Test::SetFValue); ADD_PROPERTY(PropertyInfo(Variant::FLOAT,\u0026#34;FValue\u0026#34;),\u0026#34;SetFValue\u0026#34;,\u0026#34;GetFValue\u0026#34;); ClassDB::bind_method(D_METHOD(\u0026#34;GetSValue\u0026#34;),\u0026amp;Test::GetSValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetSValue\u0026#34;,\u0026#34;SValue\u0026#34;),\u0026amp;Test::SetSValue); ADD_PROPERTY(PropertyInfo(Variant::STRING,\u0026#34;SValue\u0026#34;),\u0026#34;SetSValue\u0026#34;,\u0026#34;GetSValue\u0026#34;); ClassDB::bind_method(D_METHOD(\u0026#34;GetTValue\u0026#34;),\u0026amp;Test::GetTValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetTValue\u0026#34;,\u0026#34;TValue\u0026#34;),\u0026amp;Test::SetTValue); ADD_PROPERTY(PropertyInfo(Variant::OBJECT,\u0026#34;TValue\u0026#34;,PROPERTY_HINT_RESOURCE_TYPE,\u0026#34;Texture2D\u0026#34;),\u0026#34;SetIValue\u0026#34;,\u0026#34;GetIValue\u0026#34;); ClassDB::bind_method(D_METHOD(\u0026#34;GetEValue\u0026#34;),\u0026amp;Test::GetEValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetEValue\u0026#34;,\u0026#34;EValue\u0026#34;),\u0026amp;Test::SetEValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;EValue\u0026#34;,PROPERTY_HINT_ENUM,\u0026#34;None , Enum1 , Enum2\u0026#34;),\u0026#34;SetEValue\u0026#34;,\u0026#34;GetEValue\u0026#34;); ClassDB::bind_method(D_METHOD(\u0026#34;GetFlagValue\u0026#34;),\u0026amp;Test::GetFlagValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetFlagValue\u0026#34;,\u0026#34;flag\u0026#34;),\u0026amp;Test::SetFlagValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;flag\u0026#34;,PROPERTY_HINT_FLAGS,\u0026#34;FlagNone , Flag1 , Flag2 , Flag3\u0026#34;),\u0026#34;SetFlagValue\u0026#34;,\u0026#34;GetFlagValue\u0026#34;); } （一）函数暴露 ​\t对于需要暴露到脚本的函数，需要在**_bind_methods**中用 ClassDB::bind_method进行绑定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: void StartTest(); protected: static void _bind_methods(); }; #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; void Test::StartTest() { UtilityFunctions::print(\u0026#34;StartTest:1111); } void Test::_bind_methods() { ClassDB::bind_method(D_METHOD(\u0026#34;StartTest\u0026#34;),\u0026amp;Test::StartTest); } （二）属性暴露 对于需要暴露到脚本的属性，需要在**_bind_methods中用ADD_PROPERTY进行绑定，同时需要暴露它对应的Get和Set**方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/texture2d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: enum ETest{ None, Enum1, Enum2, Num }; enum EFlag{ FlagNone = 0, Flag1 = 1 \u0026lt;\u0026lt; 0, Flag2 = 1 \u0026lt;\u0026lt; 1, Flag3 = 1 \u0026lt;\u0026lt; 2, }; public: int GetIValue(); void SetIValue(int input); Ref\u0026lt;Texture2D\u0026gt; GetTValue(); void SetTValue(Ref\u0026lt;Texture2D\u0026gt; input); ETest GetEValue(); void SetEValue(ETest input); BitField\u0026lt;EFlag\u0026gt; GetFlagValue(); void SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input); protected: static void _bind_methods(); private: int IValue = 0; Ref\u0026lt;Texture2D\u0026gt; TValue; ETest EValue = ETest::None; BitField\u0026lt;EFlag\u0026gt; flag = EFlag::FlagNone; }; VARIANT_ENUM_CAST(Test::ETest); VARIANT_BITFIELD_CAST(Test::EFlag); #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/image_texture.hpp\u0026gt; int Test::GetIValue() { return IValue; } void Test::SetIValue(int input) { IValue = input; } Ref\u0026lt;Texture2D\u0026gt; Test::GetTValue() { return TValue; } void Test::SetTValue(Ref\u0026lt;Texture2D\u0026gt; input) { TValue = input; } Test::ETest Test::GetEValue() { return EValue; } void Test::SetEValue(ETest input) { EValue = input; } BitField\u0026lt;Test::EFlag\u0026gt; Test::GetFlagValue() { return flag; } void Test::SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input) { flag = input; } void Test::_bind_methods() { //int变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetIValue\u0026#34;),\u0026amp;Test::GetIValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetIValue\u0026#34;,\u0026#34;IValue\u0026#34;),\u0026amp;Test::SetIValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;IValue\u0026#34;),\u0026#34;SetIValue\u0026#34;,\u0026#34;GetIValue\u0026#34;); //资源变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetTValue\u0026#34;),\u0026amp;Test::GetTValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetTValue\u0026#34;,\u0026#34;TValue\u0026#34;),\u0026amp;Test::SetTValue); ADD_PROPERTY(PropertyInfo(Variant::OBJECT,\u0026#34;TValue\u0026#34;,PROPERTY_HINT_RESOURCE_TYPE,\u0026#34;Texture2D\u0026#34;),\u0026#34;SetIValue\u0026#34;,\u0026#34;GetIValue\u0026#34;); //枚举变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetEValue\u0026#34;),\u0026amp;Test::GetEValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetEValue\u0026#34;,\u0026#34;EValue\u0026#34;),\u0026amp;Test::SetEValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;EValue\u0026#34;,PROPERTY_HINT_ENUM,\u0026#34;None , Enum1 , Enum2\u0026#34;),\u0026#34;SetEValue\u0026#34;,\u0026#34;GetEValue\u0026#34;); //位域变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetFlagValue\u0026#34;),\u0026amp;Test::GetFlagValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetFlagValue\u0026#34;,\u0026#34;flag\u0026#34;),\u0026amp;Test::SetFlagValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;flag\u0026#34;,PROPERTY_HINT_FLAGS,\u0026#34;FlagNone , Flag1 , Flag2 , Flag3\u0026#34;),\u0026#34;SetFlagValue\u0026#34;,\u0026#34;GetFlagValue\u0026#34;); } （三）枚举 对于需要暴露到脚本的枚举，需要用VARIANT_ENUM_CAST以及在**_bind_methods中用BIND_ENUM_CONSTANT**进行注册\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/texture2d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: enum ETest{ None, Enum1, Enum2, Num }; public: ETest GetEValue(); void SetEValue(ETest input); protected: static void _bind_methods(); private: ETest EValue = ETest::None; }; VARIANT_ENUM_CAST(Test::ETest); #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/image_texture.hpp\u0026gt; Test::ETest Test::GetEValue() { return EValue; } void Test::SetEValue(ETest input) { EValue = input; } void Test::_bind_methods() { BIND_ENUM_CONSTANT(None); BIND_ENUM_CONSTANT(Enum1); BIND_ENUM_CONSTANT(Enum2); BIND_ENUM_CONSTANT(Num); //枚举变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetEValue\u0026#34;),\u0026amp;Test::GetEValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetEValue\u0026#34;,\u0026#34;EValue\u0026#34;),\u0026amp;Test::SetEValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;EValue\u0026#34;,PROPERTY_HINT_ENUM,\u0026#34;None , Enum1 , Enum2\u0026#34;),\u0026#34;SetEValue\u0026#34;,\u0026#34;GetEValue\u0026#34;); } （四）位域 对于需要暴露到脚本的位域，需要用VARIANT_BITFIELD_CAST以及在**_bind_methods中用BIND_BITFIELD_FLAG**进行注册\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/texture2d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: enum EFlag{ FlagNone = 0, Flag1 = 1 \u0026lt;\u0026lt; 0, Flag2 = 1 \u0026lt;\u0026lt; 1, Flag3 = 1 \u0026lt;\u0026lt; 2, }; public: BitField\u0026lt;EFlag\u0026gt; GetFlagValue(); void SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input); protected: static void _bind_methods(); private: BitField\u0026lt;EFlag\u0026gt; flag = EFlag::FlagNone; }; VARIANT_BITFIELD_CAST(Test::EFlag); #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/image_texture.hpp\u0026gt; BitField\u0026lt;Test::EFlag\u0026gt; Test::GetFlagValue() { return flag; } void Test::SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input) { flag = input; } void Test::_bind_methods() { BIND_BITFIELD_FLAG(FlagNone); BIND_BITFIELD_FLAG(Flag1); BIND_BITFIELD_FLAG(Flag2); BIND_BITFIELD_FLAG(Flag3); //位域变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetFlagValue\u0026#34;),\u0026amp;Test::GetFlagValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetFlagValue\u0026#34;,\u0026#34;flag\u0026#34;),\u0026amp;Test::SetFlagValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;flag\u0026#34;,PROPERTY_HINT_FLAGS,\u0026#34;FlagNone , Flag1 , Flag2 , Flag3\u0026#34;),\u0026#34;SetFlagValue\u0026#34;,\u0026#34;GetFlagValue\u0026#34;); } （五）信号/回调 1、ADD_SIGNAL 对于需要信号（回调），需要用ADD_SIGNAL注册并用emit_signal发送，以及可以用connect绑定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/texture2d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: void StartTest2(); protected: static void _bind_methods(); }; #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; Test::Test() { connect(\u0026#34;ready\u0026#34;,Callable(this,\u0026#34;StartTest2\u0026#34;)); } void Test::StartTest2() { UtilityFunctions::print(\u0026#34;BBBBBBBBBBBBBBB:\u0026#34;,IValue); emit_signal(\u0026#34;HelloSignal\u0026#34;,\u0026#34;CCCCCCCCCCCCCCCCCCC\u0026#34;); } void Test::_bind_methods() { ADD_SIGNAL(MethodInfo(\u0026#34;HelloSignal\u0026#34;,PropertyInfo(Variant::STRING,\u0026#34;message\u0026#34;))); } 2、call_deferred 1 2 this-\u0026gt;call_deferred(\u0026#34;method_name\u0026#34;, arg1, arg2); //注意method_name方法需要被注册过才能正确调用 二、常用函数 （一）引用计数、memnew、memdelete 1 2 3 4 5 6 7 //godot对于内存管理有自己的封装，所以对于非原生类，需要用它定义的创建/删除方法。 memnew(ImageTexture); memdelete(); //一般使用引用计数来控制资源生命周期，而非手动管理 Ref\u0026lt;ImageTexture\u0026gt; AA(memnew(ImageTexture)); UtilityFunctions::print(\u0026#34;reference count:\u0026#34;,AA-\u0026gt;get_reference_count()); （二）计时器 1、Timer\n2、Tween\n轻量化的计时器，godot会自动回收。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 备注：没有内存泄漏风险。Ref自动管理了内存 Ref\u0026lt;Tween\u0026gt; tween = create_tween(); double Index = Duration / (2.0f * Times); // Times是闪烁次数也是循环次数，Index是闪烁间隔 for (int i = 0; i \u0026lt; Times; i++) { tween-\u0026gt;tween_property(this, \u0026#34;modulate:a\u0026#34;, 0.0f, Index); tween-\u0026gt;tween_property(this, \u0026#34;modulate:a\u0026#34;, 1.0f, Index); } if (true) { tween-\u0026gt;tween_property(this, \u0026#34;modulate:a\u0026#34;, 0.0f, Index); } tween-\u0026gt;set_trans(Tween::TRANS_LINEAR); 三、编辑器3D小工具插件Gizmo Gizmo是godot自带的编辑器界面的3D小工具。\n它是附加式的，即不会影响原节点，同时也不会被原节点所感知 支持点、线、网格的绘制 支持点击和拖拽事件 该功能主要由：控制器EditorNode3DGizmoPlugin，组件EditorNode3DGizmo。两大部分组成。但需要使用的话，就需要在统一的插件管理器中，进行注册和初始化。\n（一）、EditorNode3DGizmoPlugin EditorNode3DGizmoPlugin 是 Godot 编辑器中的一个 插件基类，用于扩展和注册自定义的 3D Gizmo 工具。它允许开发者在 3D 视口中为特定类型的节点绘制自定义辅助图形、控制柄、交互部件。\n注册 Gizmo 类型：关联到某个节点类（如 Camera3D、Light3D、自定义节点等） 生成 Gizmo 实例：通过 create_gizmo() 创建对应的 EditorNode3DGizmo 对象 定义外观与行为：create_handle_material（）、create_material（）等 注意事项： 当_has_gizmo被重载时，会根据返回的bool值，创建默认的EditorNode3DGizmo。 当__create_gizmo被重载时，创建自定义的EditorNode3DGizmo。 当他们同时被重载时，仅会生效__create_gizmo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 //======================头文件======================== #pragma once #ifndef SPLINE_GIZMO_PLUGIN_H #define SPLINE_GIZMO_PLUGIN_H #include \u0026#34;godot_cpp/classes/editor_node3d_gizmo_plugin.hpp\u0026#34; using namespace godot; class SplineGizmoPlugin : public EditorNode3DGizmoPlugin { GDCLASS(SplineGizmoPlugin, EditorNode3DGizmoPlugin); protected: static void _bind_methods(){} public: // virtual bool _has_gizmo(Node3D *p_for_node_3d) const override; virtual Ref\u0026lt;EditorNode3DGizmo\u0026gt; _create_gizmo(Node3D *p_for_node_3d) const override; virtual void _redraw(const Ref\u0026lt;EditorNode3DGizmo\u0026gt; \u0026amp;p_gizmo) override; virtual String _get_gizmo_name() const override{ return \u0026#34;SplineGizmo\u0026#34;; } // virtual int32_t _get_priority() const override{ // return -1; // } }; #endif //======================源文件======================== #include \u0026#34;SplineGizmoPlugin.h\u0026#34; #include \u0026#34;Spline.h\u0026#34; #include \u0026#34;SplineGizmo.h\u0026#34; #include \u0026#34;godot_cpp/classes/object.hpp\u0026#34; #include \u0026#34;godot_cpp/core/memory.hpp\u0026#34; #include \u0026#34;godot_cpp/variant/utility_functions.hpp\u0026#34; // bool SplineGizmoPlugin::_has_gizmo(Node3D *p_for_node_3d) const { // UtilityFunctions::print(\u0026#34;SplineGizmoPlugin::_has_gizmo :: AAAAAAAAAAAA\u0026#34;); // UtilityFunctions::print(__FUNCTION__,p_for_node_3d-\u0026gt;get_name()); // return Object::cast_to\u0026lt;Spline\u0026gt;(p_for_node_3d) != nullptr; // } Ref\u0026lt;EditorNode3DGizmo\u0026gt; SplineGizmoPlugin::_create_gizmo(Node3D *p_for_node_3d) const{ UtilityFunctions::print(\u0026#34;SplineGizmoPlugin::_create_gizmo :: Try to create gizmo for :: \u0026#34;,p_for_node_3d-\u0026gt;get_name()); bool bIsSpline = Object::cast_to\u0026lt;Spline\u0026gt;(p_for_node_3d) != nullptr; if (bIsSpline) { UtilityFunctions::print(\u0026#34;SplineGizmoPlugin::_create_gizmo :: \u0026#34;,p_for_node_3d-\u0026gt;get_name()); Ref\u0026lt;EditorNode3DGizmo\u0026gt; Gizmo = memnew(SplineGizmo(p_for_node_3d)); return Gizmo; } return nullptr; } void SplineGizmoPlugin::_redraw(const Ref\u0026lt;EditorNode3DGizmo\u0026gt; \u0026amp;p_gizmo){ UtilityFunctions::print(\u0026#34;SplineGizmoPlugin::_redraw :: \u0026#34; , p_gizmo-\u0026gt;get_node_3d()-\u0026gt;get_name()); p_gizmo-\u0026gt;_redraw(); } （二）、EditorNode3DGizmo EditorNode3DGizmo 是实际在 3D 视口中绘制和交互的对象。由 EditorNode3DGizmoPlugin 创建，它负责管理绘制内容和交互点。\n添加可见元素：通过 add_mesh()、add_lines()、add_unscaled_billboard() 等方法绘制不同类型的辅助几何\n添加交互句柄（Handles）：\nadd_handles() 用于添加可拖拽的控制点 在编辑器中用户可以直接用鼠标操作这些点 交互与更新\n在插件中重写 redraw(gizmo)，可根据节点属性变化实时刷新 使用 set_handle() 与 commit_handle() 响应用户操作，将变动写回节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 //======================头文件======================== #pragma once #ifndef SPLINE_GIZMO_H #define SPLINE_GIZMO_H #include \u0026#34;Spline.h\u0026#34; #include \u0026#34;godot_cpp/classes/node3d.hpp\u0026#34; // #include \u0026#34;godot_cpp/classes/editor_node3d_gizmo_plugin.hpp\u0026#34; #include \u0026#34;godot_cpp/classes/editor_node3d_gizmo.hpp\u0026#34; // #include \u0026#34;godot_cpp/classes/node3d_gizmo.hpp\u0026#34; #include \u0026#34;godot_cpp/classes/camera3d.hpp\u0026#34; using namespace godot; class SplineGizmo : public EditorNode3DGizmo { GDCLASS(SplineGizmo, EditorNode3DGizmo); protected: static void _bind_methods(){} public: SplineGizmo(){} SplineGizmo(Node3D *p_node); ~SplineGizmo(); virtual void _redraw() override; virtual void _commit_handle(int32_t p_id, bool p_secondary, const Variant \u0026amp;p_restore, bool p_cancel) override; virtual void _set_handle(int32_t p_id, bool p_secondary, Camera3D *p_camera, const Vector2 \u0026amp;p_point) override; private: Spline * SplineInstance; Ref\u0026lt;Material\u0026gt; RedMaterial; Ref\u0026lt;Material\u0026gt; GreenMaterial; Ref\u0026lt;Material\u0026gt; BlueMaterial; }; #endif //======================源文件======================== #include \u0026#34;SplineGizmo.h\u0026#34; #include \u0026#34;Spline.h\u0026#34; #include \u0026#34;godot_cpp/classes/object.hpp\u0026#34; #include \u0026#34;godot_cpp/classes/editor_node3d_gizmo_plugin.hpp\u0026#34; #include \u0026#34;godot_cpp/classes/standard_material3d.hpp\u0026#34; #include \u0026#34;godot_cpp/core/error_macros.hpp\u0026#34; #include \u0026#34;godot_cpp/core/memory.hpp\u0026#34; #include \u0026#34;godot_cpp/variant/array.hpp\u0026#34; #include \u0026#34;godot_cpp/variant/utility_functions.hpp\u0026#34; #include \u0026#34;godot_cpp/variant/vector3.hpp\u0026#34; SplineGizmo::SplineGizmo(Node3D *p_node){ set_node_3d(p_node); SplineInstance = Object::cast_to\u0026lt;Spline\u0026gt;(p_node); } SplineGizmo::~SplineGizmo(){ } void SplineGizmo::_redraw(){ UtilityFunctions::print(__FUNCTION__,\u0026#34;redraw::CCCCCCC :: \u0026#34;,get_node_3d()-\u0026gt;get_name()); clear(); PackedVector3Array points; PackedInt32Array ids; PackedVector3Array lines; ERR_FAIL_COND(!SplineInstance); int numPoints = SplineInstance-\u0026gt;GetControlPoints().size(); ERR_FAIL_COND(numPoints == 0); for (int i = 0; i \u0026lt; numPoints; i++) { Vector3 CurPoint = SplineInstance-\u0026gt;GetControlPoints()[i]; points.append(CurPoint); ids.append(i); } int segNum = 100; Array TempP = SplineInstance-\u0026gt;GetBezierCurve(segNum); for (int i = 0; i \u0026lt; segNum - 1; i++) { Vector3 CurPoint0 = TempP[i]; Vector3 CurPoint1 = TempP[i + 1]; lines.append(CurPoint0); lines.append(CurPoint1); } add_handles(points, get_plugin()-\u0026gt;get_material(\u0026#34;HandleMat\u0026#34;,this),ids); add_lines(lines, get_plugin()-\u0026gt;get_material(\u0026#34;RedMat\u0026#34;,this)); } void SplineGizmo::_commit_handle(int32_t p_id, bool p_secondary, const Variant \u0026amp;p_restore, bool p_cancel){ UtilityFunctions::print(\u0026#34;SplineGizmo::_commit_handle :: id :: \u0026#34;, p_id , \u0026#34; , Restore :: \u0026#34;, p_restore ,\u0026#34;NewPosition :: \u0026#34;); } void SplineGizmo::_set_handle(int32_t p_id, bool p_secondary, Camera3D *p_camera, const Vector2 \u0026amp;p_point){ // UtilityFunctions::print(\u0026#34;SplineGizmo::_set_handle :: id :: \u0026#34;, p_id , \u0026#34; , Screen Point :: \u0026#34;, p_point ); if (!SplineInstance || !p_camera ) { return; } Array points = SplineInstance-\u0026gt;GetControlPoints(); Vector3 LocalLocation = points[p_id]; Vector3 WorldLocation = SplineInstance-\u0026gt;get_transform().xform(LocalLocation); UtilityFunctions::print(\u0026#34;LocalLocation :: \u0026#34;, LocalLocation , \u0026#34; , WorldLocation :: \u0026#34;, WorldLocation ); const Vector3 ray_o = p_camera-\u0026gt;project_ray_origin(p_point); const Vector3 ray_d = p_camera-\u0026gt;project_ray_normal(p_point); // UtilityFunctions::print(\u0026#34;SplineGizmo::_set_handle :: id :: \u0026#34;, p_id , \u0026#34; , ray_o :: \u0026#34;,ray_o,\u0026#34; , ray_d :: \u0026#34;,ray_d); // 构造“屏幕平面”：过当前把手点，法线 = 相机前向（-Z 列） const Vector3 cam_fwd = -p_camera-\u0026gt;get_global_transform().basis.get_column(2).normalized(); Plane view_plane(cam_fwd, WorldLocation); // UtilityFunctions::print(\u0026#34;cam_fwd :: \u0026#34;, cam_fwd ); Vector3 hit; if (!view_plane.intersects_ray(ray_o, ray_d, \u0026amp;hit)) { // 射线与平面近平行，忽略这帧 return; } UtilityFunctions::print(\u0026#34;Hit :: \u0026#34;,hit); points[p_id] = SplineInstance-\u0026gt;get_transform().xform_inv(hit); SplineInstance-\u0026gt;SetControlPoints(points); _redraw(); } （三）、EditorPlugin EditorPlugin 是 Godot 中所有编辑器插件的基类，负责：\n注册和卸载 EditorNode3DGizmoPlugin 处理插件的生命周期 与编辑器 UI、场景树、Inspector 等交互 接口 作用 说明 add_node_3d_gizmo_plugin 把自定义 Gizmo 插件注册到编辑器 remove_node_3d_gizmo_plugin 把自定义 Gizmo 插件移除 enable_plugin 开启插件 disable_plugin 关闭插件 handles 判断是否接管某类型节点的编辑逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 //=================类的定义======================= class MyEditorPlugin : public EditorPlugin { GDCLASS(MyEditorPlugin, EditorPlugin); Ref\u0026lt;SplineGizmoPlugin\u0026gt; gizmo_plugin; protected: static void _bind_methods() { } public: virtual void _enter_tree() override { UtilityFunctions::print(\u0026#34;Init :: MyEditorPlugin :: _enter_tree\u0026#34;); gizmo_plugin.instantiate(); gizmo_plugin-\u0026gt;create_handle_material(\u0026#34;HandleMat\u0026#34;); gizmo_plugin-\u0026gt;create_material(\u0026#34;RedMat\u0026#34;, Color(1.0f, 0.0f, 0.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;GreenMat\u0026#34;, Color(0.0f, 1.0f, 0.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;BlueMat\u0026#34;, Color(0.0f, 0.0f, 1.0f)); add_node_3d_gizmo_plugin(gizmo_plugin); } virtual void _exit_tree() override { UtilityFunctions::print(\u0026#34;UnInit :: MyEditorPlugin :: _exit_tree\u0026#34;); remove_node_3d_gizmo_plugin(gizmo_plugin); } }; //==================使用示例======================= //==================register_types.cpp======================= void initialize_GodotTest_module(ModuleInitializationLevel p_level) { if (p_level == MODULE_INITIALIZATION_LEVEL_SCENE) { UtilityFunctions::print(\u0026#34;Init :: Scene\u0026#34;); GDREGISTER_CLASS(FowTexture); GDREGISTER_CLASS(Spline); } if (p_level == MODULE_INITIALIZATION_LEVEL_EDITOR) { UtilityFunctions::print(\u0026#34;Init :: Editor\u0026#34;); GDREGISTER_CLASS(SplineGizmo); GDREGISTER_CLASS(SplineGizmoPlugin); GDREGISTER_CLASS(MyEditorPlugin); EditorPlugins::add_by_type\u0026lt;MyEditorPlugin\u0026gt;(); } UtilityFunctions::print(\u0026#34;Init :: None :: \u0026#34;, p_level); } ","date":"2025-11-04T16:38:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E4%B8%89gdextension%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","title":"【godot】三、GDExtension开发指南"},{"content":"常用头文件 print 路径：#include \u0026ldquo;core/string/print_string.h\u0026rdquo;\n用于标准日志的输出。在做引擎开发时使用。\n在做GDExtension开发时，使用Utility_function头文件，进行日志打印。\n接口 作用 示例 void print_line(const Variant \u0026amp;v） 打印日志 __print_line(\u0026ldquo;AAA\u0026rdquo;,10.0); void print_error(const String \u0026amp;p_string) 打印错误 print_error(\u0026ldquo;BBBB\u0026rdquo;) class_db 路径：#include \u0026ldquo;core/object/class_db.h\u0026rdquo;\n在_bind_methods中进行类型和函数注册的时候，使用到的类型注册函数就来自该头文件\n接口 作用 示例 ClassDB::bind_method 注册函数到脚本 ClassDB::bind_method(D_METHOD(\u0026ldquo;test_print\u0026rdquo;), \u0026amp;CommandTool::test_print); OS 路径：#include \u0026ldquo;sence/gui/xxx.h\u0026rdquo;\n提供了一系列操作系统层级的API，比如打印日、获取引擎运行时长等。\n接口 作用 示例 get_ticks_usec 获取引擎运行时长，单位为微秒 get_ticks_msec 获取引擎运行时长，单位为毫秒 callable 路径：#include \u0026ldquo;core/variant/callable.h\u0026rdquo;\ngodot自身提供了一套用于安全、类型检查的函数回调机制，也就是Callable，在进行信号连接时，我们就需要使用到它。\n类似 C++ 的 std::function\u0026lt;void()\u0026gt;，但它能在 Godot 对象系统中序列化、连接信号、跨语言调用。\n1 2 3 4 5 //基础构造函数，注意此处的method需要在_bind_method中被注册才能够通过字符串访问。 Callable c = Callable(this, \u0026#34;_on_something\u0026#34;); //更安全高效的绑定 Callable c = callable_mp(this, \u0026amp;MyClass::_on_timeout); gui 路径：#include \u0026ldquo;sence/gui/xxx.h\u0026rdquo;\nLabel Label是godot提供的UI控件，可以自适应内容的大小\nRichTextLabel RichTextLabel是godot提供的UI控件，可以使用BBcode来控制显示的内容，比如设置当行文本颜色等\n1 2 3 4 screen_output_label-\u0026gt;set_use_bbcode(true);\t//使用bbcode，开启才能正确显示[color=red]XXXX[\\color]的bbcode格式文本 screen_output_label-\u0026gt;set_fit_content(true);\t//自适应文本高度 screen_output_label-\u0026gt;set_autowrap_mode(TextServer::AutowrapMode::AUTOWRAP_OFF);//关闭宽度调整，与上方设置相结合，可以自适应宽高。 timer 1 2 3 4 5 6 7 8 9 //1.通过场景树（mainloop）设置简单的时间回调函数 // timer to show text for 3 seconds auto timer = get_scene_tree()-\u0026gt;create_timer(time); timer-\u0026gt;connect(\u0026#34;timeout\u0026#34;, callable_mp(this,\u0026amp;CommandTool::reduce_screen_output_buffer)); //2.c++原生的线程调用也可以实现，但是需要call_deferred来回到主线程 //3.tween，更加复杂，但是可以链式调用，以及设置缓动 ","date":"2025-11-04T16:18:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E4%BA%8Cmodules%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","title":"【godot】二、Modules开发指南"},{"content":"引擎编译 官方源码仓库：godot\n官方godot-cpp仓库：godot-cpp\n编译指令 在Godot_Engine根目录下，执行下方编译指令scons,有以下可选参数\n指定目标平台 ：：platform=windows/android/macos 是否带符号表 ：：debug_symbols=yes/no 构建目标类型 ：：target=editor/template_debug/template_release 是否输出编译指令：：verbose=yes 目标平台芯片架构：：arch=x86_64/arm64v8 是否生成编译json：：compiledb=true 指定编译线程数量：：-j8/-j16 使用 LLVM/Clang 编译器而非 GCC ：：use_llvm=yes/no 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 1.windows平台编译 生成路径：E:\\Godot\\Godot_Engine\\bin 编译路径：E:\\Godot\\Godot_Engine 编译指令：scons compiledb=true debug_symbols=yes verbose=yes -j16 2.android的libgodot_android.so编译 生成路径：E:\\Godot\\Godot_Engine\\platform\\android\\java\\lib\\libs\\debug\\arm64-v8a 编译路径：E:\\Godot\\Godot_Engine 编译指令：scons platform=android target=template_debug debug_symbols=yes compiledb=true 或scons platform=android store_release=true production=true dev_mode=false dev_build=false debug_symbols=true tests=false target=template_release arch=arm64 compiledb=true 3.生成Android导出模板 前置生成： 生成debug的so：scons platform=android target=template_debug arch=arm64 dev_build=yes generate_android_binaries=yes 生成release的so：scons platform=android target=template_release arch=arm64 dev_build=yes generate_android_binaries=yes 生成路径：E:\\Godot\\Godot_Engine\\bin\\android_release.apk 编译路径：E:\\Godot\\Godot_Engine\\platform\\android\\java 编译指令：./gradlew.bat generateGodotTemplates 4.android的aar的编译，godot-lib.template_debug.aar 生成路径：E:\\Godot\\Godot_Engine\\platform\\android\\java\\lib\\build\\outputs\\aar 编译路径：E:\\Godot\\Godot_Engine\\platform\\android\\java 编译指令：gradlew.bat :lib:bundleTemplateDebugAar 5.生成sln文件 scons vsproj=yes 6.生成GDExtension的胶水代码 1. 编译extension_api.json文件： bin\\godot.windows.editor.x86_64.exe --dump-extension-api 2. 在godot-cpp中执行代码生成： scons debug_symbols=yes verbose=yes generate_bindings=yes custom_api_file=E:\\Godot\\godot-cpp\\gdextension\\extension_api.json 7.导出资源包zip/pck 生成路径：${YourProjectPath} 编译路径：${YourProjectPath} 1. E:\\Godot\\Godot_Engine\\bin\\godot.windows.editor.x86_64.exe --headless --export-pack \u0026#34;Android\u0026#34; game.zip 2. E:\\Godot\\Godot_Engine\\bin\\godot.windows.editor.x86_64.exe --headless --export-pack \u0026#34;Android\u0026#34; game.pck 运行指令 1 2 3 4 5 //运行编辑器 \u0026#34;godot.exe --path ${PgmPath} -v -e\u0026#34; //直接运行runtime \u0026#34;godot.exe --path ${PgmPath} -v\u0026#34; JNI路径 文件路径：E:\\Godot\\Godot_Engine\\platform\\android\\java_godot_lib_jni.h\n模块(Module)开发 参考文档：自定义 C++ 模块 — Godot Engine (4.x) 简体中文文档\n文件及结构 新建一个模块需要以下文件及结构，存放在E:\\Godot\\Godot_Engine\\modules目录底下 。\n在E:\\Godot\\Godot_Engine\\modules\\register_module_types.gen.cpp文件中，会根据我们模块中的SCsub文件，自动生成实际的模块注册代码，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //register_module_types.gen.cpp 中自动生成的代码，用于模块的实际注册。 #include \u0026#34;modules/ns_test_module/register_types.h\u0026#34; //... #ifdef MODULE_NS_TEST_MODULE_ENABLED initialize_ns_test_module_module(p_level); #endif //... #ifdef MODULE_NS_TEST_MODULE_ENABLED uninitialize_ns_test_module_module(p_level); #endif SCsub和config.py SCsub是这个模块的编译指令，包括源码的收集、头文件路径添加、静态库的链接等。\n与config.py结合使用，可以动态的管理该模块的编译选项，以及将该模块自动的生成到E:\\Godot\\Godot_Engine\\modules\\register_module_types.gen.cpp进行模块的注册。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #====SCsub====== from misc.utility.scons_hints import * Import(\u0026#34;env\u0026#34;) Import(\u0026#34;env_modules\u0026#34;) env_nstest = env_modules.Clone() # 添加第三方库的头文件路径 env.Append(CPPPATH=[\u0026#34;#modules/matrix_data_pipeline/include\u0026#34;]) env.Append(CPPPATH=[\u0026#34;#modules/matrix_data_pipeline/include/NSCppData\u0026#34;]) env.Append(CPPPATH=[\u0026#34;#modules/matrix_data_pipeline/include/NSCppData/ProtoGen\u0026#34;]) # 添加库文件路径 if env[\u0026#34;platform\u0026#34;] == \u0026#34;windows\u0026#34;: env.Append(LIBPATH=[\u0026#34;#modules/matrix_data_pipeline/lib/windows\u0026#34;]) env.Append(LIBS=[\u0026#34;NSCppData\u0026#34;,\u0026#34;libprotobuf\u0026#34;]) elif env[\u0026#34;platform\u0026#34;] == \u0026#34;android\u0026#34;: env.Append(LIBPATH=[\u0026#34;#modules/matrix_data_pipeline/lib/android\u0026#34;]) env.Append(LIBS=[\u0026#34;mylib\u0026#34;]) # Godot source files module_obj = [] env_nstest.add_source_files(module_obj, \u0026#34;*.cpp\u0026#34;) # env_nstest.add_source_files(module_obj, \u0026#34;editor/*.cpp\u0026#34;) env.modules_sources += module_obj 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #====config.py====== def can_build(env, platform): return True def configure(env): pass # def get_doc_classes(): # return [ # \u0026#34;OggPacketSequence\u0026#34;, # \u0026#34;OggPacketSequencePlayback\u0026#34;, # ] # def get_doc_path(): # return \u0026#34;doc_classes\u0026#34; register_types 该文件负责对自身模块中声明的godot类型进行类型注册，同时也可以在相对较早的阶段（main函数的setup阶段）进行一些单例类的实例化。 如果在进行编辑器工具类的开发，则工具类的实例化和注册，也是在该阶段进行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //==============register_types.h============ #ifndef NSTEST_REGISTER_TYPES_H #define NSTEST_REGISTER_TYPES_H #include \u0026#34;modules/register_module_types.h\u0026#34; void initialize_ns_test_module_module(ModuleInitializationLevel p_level); void uninitialize_ns_test_module_module(ModuleInitializationLevel p_level); #endif //==============register_types.cpp============ #include \u0026#34;register_types.h\u0026#34; #include \u0026#34;core/object/object.h\u0026#34; #include \u0026#34;ns_test_module.h\u0026#34; void initialize_ns_test_module_module(ModuleInitializationLevel p_level) { if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) { return; } GDREGISTER_CLASS(NsTestModule) //注册类型 GDREGISTER_CLASS(NsTestResource) } void uninitialize_ns_test_module_module(ModuleInitializationLevel p_level) { if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) { return; } } GDExtension开发 参考文档：入门 — Godot Engine (4.x) 简体中文文档\n对于GDExtension中编写的c++代码，需要进行特定的注册和编译流程，才能形成给godot用的动态链接库\n项目组织结构 对于带GDExtension的godot项目，它具有以下的基本结构\nexample.gdextension 1 2 3 4 5 6 7 8 9 10 11 12 [configuration] //注意此处的entry_symbol名，应该与regisiter_types中的入口函数名保持一致 entry_symbol = \u0026#34;GodotTest_library_init\u0026#34; compatibility_minimum = \u0026#34;4.1\u0026#34; reloadable = true [libraries] windows.debug.x86_64 = \u0026#34;res://bin/GodotTest.windows.template_debug.x86_64.dll\u0026#34; android.debug.arm64 = \u0026#34;res://bin/GodotTest.android.template_release.arm64.so\u0026#34; android.arm64 = \u0026#34;res://bin/GodotTest.android.template_release.arm64.so\u0026#34; register_types 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /* godot-cpp integration testing project. * * This is free and unencumbered software released into the public domain. */ #include \u0026#34;register_types.h\u0026#34; #include \u0026lt;gdextension_interface.h\u0026gt; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/core/defs.hpp\u0026gt; #include \u0026lt;godot_cpp/godot.hpp\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026#34;godot_cpp/classes/editor_interface.hpp\u0026#34; #include \u0026#34;godot_cpp/classes/editor_plugin.hpp\u0026#34; #include \u0026#34;godot_cpp/variant/utility_functions.hpp\u0026#34; #include \u0026#34;Test/Fow.h\u0026#34; // Spline #include \u0026#34;Spline/Spline.h\u0026#34; #include \u0026#34;Spline/SplineGizmo.h\u0026#34; #include \u0026#34;Spline/SplineGizmoPlugin.h\u0026#34; //Profiler #include \u0026#34;ProfilerLib/ProfilerUI.h\u0026#34; #include \u0026#34;ProfilerLib/ProfilerTest.h\u0026#34; using namespace godot; class MyEditorPlugin : public EditorPlugin { GDCLASS(MyEditorPlugin, EditorPlugin); Ref\u0026lt;SplineGizmoPlugin\u0026gt; gizmo_plugin; protected: static void _bind_methods() { } public: virtual void _enter_tree() override { UtilityFunctions::print(\u0026#34;Init :: MyEditorPlugin :: _enter_tree\u0026#34;); gizmo_plugin.instantiate(); gizmo_plugin-\u0026gt;create_handle_material(\u0026#34;HandleMat\u0026#34;); gizmo_plugin-\u0026gt;create_material(\u0026#34;RedMat\u0026#34;, Color(1.0f, 0.0f, 0.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;GreenMat\u0026#34;, Color(0.0f, 1.0f, 0.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;BlueMat\u0026#34;, Color(0.0f, 0.0f, 1.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;Color1\u0026#34;, Color(0.0f, 1.0f, 1.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;Color2\u0026#34;, Color(1.0f, 0.0f, 1.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;Color3\u0026#34;, Color(1.0f, 1.0f, 0.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;Color4\u0026#34;, Color(1.0f, 1.0f, 1.0f)); add_node_3d_gizmo_plugin(gizmo_plugin); } virtual void _exit_tree() override { UtilityFunctions::print(\u0026#34;UnInit :: MyEditorPlugin :: _exit_tree\u0026#34;); remove_node_3d_gizmo_plugin(gizmo_plugin); } }; void initialize_GodotTest_module(ModuleInitializationLevel p_level) { if (p_level == MODULE_INITIALIZATION_LEVEL_SCENE) { UtilityFunctions::print(\u0026#34;Init :: Scene\u0026#34;); GDREGISTER_CLASS(FowTexture); GDREGISTER_CLASS(Spline); GDREGISTER_CLASS(ProfilerContext); GDREGISTER_CLASS(ProfilerUI); GDREGISTER_CLASS(ProfilerTest); } if (p_level == MODULE_INITIALIZATION_LEVEL_EDITOR) { UtilityFunctions::print(\u0026#34;Init :: Editor\u0026#34;); GDREGISTER_CLASS(SplineGizmo); GDREGISTER_CLASS(SplineGizmoPlugin); GDREGISTER_CLASS(MyEditorPlugin); EditorPlugins::add_by_type\u0026lt;MyEditorPlugin\u0026gt;(); } UtilityFunctions::print(\u0026#34;Init :: None :: \u0026#34;, p_level); } void uninitialize_GodotTest_module(ModuleInitializationLevel p_level) { if (p_level == MODULE_INITIALIZATION_LEVEL_SCENE) { UtilityFunctions::print(\u0026#34;UnInit :: Scene\u0026#34;); // return; } if (p_level == MODULE_INITIALIZATION_LEVEL_EDITOR) { UtilityFunctions::print(\u0026#34;UnInit :: Editor\u0026#34;); EditorPlugins::remove_by_type\u0026lt;MyEditorPlugin\u0026gt;(); // return; } } extern \u0026#34;C\u0026#34; { // Initialization. GDExtensionBool GDE_EXPORT GodotTest_library_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization) { godot::GDExtensionBinding::InitObject init_obj(p_get_proc_address, p_library, r_initialization); init_obj.register_initializer(initialize_GodotTest_module); init_obj.register_terminator(uninitialize_GodotTest_module); init_obj.set_minimum_library_initialization_level( MODULE_INITIALIZATION_LEVEL_SCENE); return init_obj.init(); } } SConstruct SConstruct用于配置GDExtension的编译环境，\n可以指定编译的中间文件的放置路径， 以及最终输出的链接库的名称和位置 还有引入的三方库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python import os import sys def log_env(env,key): print(f\u0026#34;{key}:{env[key]}\u0026#34;) env = SConscript(\u0026#34;godot-cpp/SConstruct\u0026#34;) project_name = \u0026#34;Godot_DemoSR\u0026#34; # For reference: # - CCFLAGS are compilation flags shared between C and C++ # - CFLAGS are for C-specific compilation flags # - CXXFLAGS are for C++-specific compilation flags # - CPPFLAGS are for pre-processor flags # - CPPDEFINES are for pre-processor defines # - LINKFLAGS are for linking flags # tweak this if you want to use different folders, or more folders, to store your source code in. env.VariantDir(\u0026#39;build\u0026#39;, \u0026#39;src\u0026#39;, duplicate=0) env.Append(CPPPATH=[\u0026#34;build/\u0026#34;]) sources = Glob(\u0026#34;build/*.cpp\u0026#34;) + Glob(\u0026#34;build/**/*.cpp\u0026#34;) + Glob(\u0026#34;build/**/**/*.cpp\u0026#34;) if env[\u0026#34;platform\u0026#34;] == \u0026#34;macos\u0026#34;: library = env.SharedLibrary( \u0026#34;{}/bin/libgdDemoSR.{}.{}.framework/libgdDemoSR.{}.{}\u0026#34;.format( project_name, env[\u0026#34;platform\u0026#34;], env[\u0026#34;target\u0026#34;], env[\u0026#34;platform\u0026#34;], env[\u0026#34;target\u0026#34;] ), source=sources, ) elif env[\u0026#34;platform\u0026#34;] == \u0026#34;windows\u0026#34;: env[\u0026#34;CXXFLAGS\u0026#34;].remove(\u0026#34;/std:c++17\u0026#34;) env.Append(CXXFLAGS = [\u0026#34;/std:c++20\u0026#34;,\u0026#34;/W4\u0026#34;, \u0026#34;/WX\u0026#34;, \u0026#34;/wd4100\u0026#34;,\u0026#34;/wd4244\u0026#34;,\u0026#34;/wd4305\u0026#34;,\u0026#34;/wd4201\u0026#34;,\u0026#34;/wd4127\u0026#34;,\u0026#34;/wd4267\u0026#34;,\u0026#34;/wd5054\u0026#34;,\u0026#34;/wd4996\u0026#34;,\u0026#34;/Zi\u0026#34;,\u0026#34;/FS\u0026#34;]) env.Append(LIBS = [\u0026#34;libzmq\u0026#34;]) env.Append(CPPDEFINES=[\u0026#34;ZMQ_STATIC\u0026#34;]) env.Append(LIBPATH = [\u0026#34;./lib/windows\u0026#34;]) library = env.SharedLibrary( \u0026#34;{}/bin/libgdDemoSR{}{}\u0026#34;.format(project_name, env[\u0026#34;suffix\u0026#34;], env[\u0026#34;SHLIBSUFFIX\u0026#34;]), source=sources, ) elif env[\u0026#34;platform\u0026#34;] == \u0026#34;android\u0026#34;: env[\u0026#34;CXXFLAGS\u0026#34;].remove(\u0026#34;-std=c++17\u0026#34;) env[\u0026#34;CXXFLAGS\u0026#34;].remove(\u0026#34;-fno-exceptions\u0026#34;) # env[\u0026#34;CXX\u0026#34;] = env[\u0026#34;CXX\u0026#34;].replace(\u0026#34;23.2.8568313\u0026#34;,\u0026#34;27.0.12077973\u0026#34;) env.Append(CXXFLAGS = [\u0026#34;-std=c++20\u0026#34;,\u0026#34;-fexceptions\u0026#34;,\u0026#39;-Wall\u0026#39;, \u0026#39;-Wextra\u0026#39;, \u0026#39;-Werror\u0026#39;,\u0026#34;-Wno-unused-parameter\u0026#34;]) env.Append(LIBS = [\u0026#34;libzmq\u0026#34;,\u0026#34;GLESv3\u0026#34;]) env.Append(CPPDEFINES=[\u0026#34;ZMQ_STATIC\u0026#34;,\u0026#34;NS_ANDROID\u0026#34;]) env.Append(LIBPATH = [\u0026#34;./lib/android\u0026#34;]) library = env.SharedLibrary( \u0026#34;{}/bin/libgdDemoSR{}{}\u0026#34;.format(project_name, env[\u0026#34;suffix\u0026#34;], env[\u0026#34;SHLIBSUFFIX\u0026#34;]), source=sources, ) else: env[\u0026#34;CXXFLAGS\u0026#34;].remove(\u0026#34;-std=c++17\u0026#34;) env[\u0026#34;CXXFLAGS\u0026#34;].remove(\u0026#34;-fno-exceptions\u0026#34;) env.Append(CXXFLAGS = [\u0026#34;-std=c++20\u0026#34;,\u0026#34;-fexceptions\u0026#34;,\u0026#39;-Wall\u0026#39;, \u0026#39;-Wextra\u0026#39;, \u0026#34;-Wno-unused-parameter\u0026#34;,\u0026#34;-Wno-changes-meaning\u0026#34;]) env.Append(LIBS = [\u0026#34;libzmq\u0026#34;,\u0026#34;GLESv3\u0026#34;]) env.Append(CPPDEFINES=[\u0026#34;ZMQ_STATIC\u0026#34;]) env.Append(LIBPATH = [\u0026#34;./lib\u0026#34;]) library = env.SharedLibrary( \u0026#34;{}/bin/libgdDemoSR{}{}\u0026#34;.format(project_name, env[\u0026#34;suffix\u0026#34;], env[\u0026#34;SHLIBSUFFIX\u0026#34;]), source=sources, ) Default(library) ","date":"2025-11-04T16:08:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E4%B8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%8F%8A%E7%A4%BA%E4%BE%8B/","title":"【godot】一、开发环境部署及示例"},{"content":"前置工具 网站前端工具-hugo软件 ：hugo hugo主题下载线仓库：hugo-theme 参考教程：教程 hugo hugo指令 下方列举了hugo常用指令\n1 2 3 4 5 6 7 8 9 // 创建新站点 hugo new site myblog // 启动服务 hugo server -D hugo server --buildDrafts // 生成新的页面 hugo new Content \u0026#34;posts/new-post.md\u0026#34; hugo.yaml hugo.yaml是hugo网站的配置文件，在其中我们可以配置网站的标题、描述、作者、主题等等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //配置每页文章数量 pagination: pagerSize: 3 //配置链接 baseurl: https://example.com/ //页面标签的小图标设置 favicon: /favicon.png article: math: true //数学公式 toc: true //目录 readingTime: true //阅读时间 license: enabled: true //许可说明 default: Licensed under [Liyufei1](https://github.com/Liyufei1) markdown语法 官方文档链接： markdown语法\n下方为常用的语法，可以快速生成\n常用 名称 语法 示例 加粗 \u0026quot; **加粗** \u0026quot; 加粗 倾斜 \u0026quot; *倾斜* \u0026quot; 倾斜 删除线 \u0026quot; ~~删除线~~ \u0026quot; 删除线 代码块 \u0026quot; ```shell 代码块\n``` \u0026quot; shell 代码块 代码行 \u0026quot; `代码行` \u0026quot; 代码行 标题 \u0026quot; # 标题 \u0026quot; # 标题 序列 \u0026quot; 1. 序列 \u0026quot; 1. 序列 无序序列 \u0026quot; - 无序序列 \u0026quot; - 无序序列 引用 \u0026quot; \u0026gt; 引用 \u0026quot; \u0026gt; 引用 链接 \u0026quot; [链接](https://www.baidu.com) \u0026quot; 链接 列表 效果如下：\n左对齐 居中 右对齐 a b c 1 2 3 代码如下：\n1 2 3 4 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | a | b | c | | 1 | 2 | 3 | 图片 ![图片说明](guidao2.jpg)\n步骤 创建本地新站点 运行命令hugo new site dev，利用hugo创建本地新站点。创建完成后，可以运行命令hugo server -D来运行新建的站点，在浏览器中可以验证是否创建成功。 到上hugo-theme下载中意的主题（本博客采用stack），将下载的主题复制到新站点的themes文件夹下。 此时执行命令hugo server -D启动服务，在浏览器中访问本地地址，可以看到新建的模板网页 部署到github 运行指令hugo -D利用hugo构建静态网页，此时在我们的本地网站文件夹下方，可以看到生成了一个名为public的文件夹，里面存放了静态网页。 创建github仓库，需要注意仓库命名为：\u0026lt;github用户名\u0026gt;.github.io，只有按照这个规范命名，github才会将静态网页部署到githubPages中。 将public文件夹下的所有文件上传到步骤2中创建的github仓库中。然后在仓库中运行Pages配置，等待一段时间，即可看到静态网页。 githug的自动构建 创建github仓库，此仓库建议为私有仓库，用于保存本地的hugo网站，即真正的博客仓库（上方发布的仅为静态网页仓库）。 创建.github/workflows/hugo.yml文件，并添加以下内容：\n需要注意的是TOKEN为github的token，需要在github的setting中创建。同时注意同步的分支。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 name: deploy on: push: branches: - master jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.TOKEN }} EXTERNAL_REPOSITORY: Liyufei1/Liyufei1.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: auto deploy 在github中创建TOKEN，并添加到blog仓库中。创建token时需要勾选repo权限以及workflow权限。创建完毕后，在blog仓库中配置该TOKEN。后续有代码提交时，就会自动构建静态网页并部署到githubPages中。 ","date":"2025-11-03T16:08:31+08:00","image":"https://Liyufei1.github.io/p/blog-build/guidao3_hu_b46614b8b19cebf7.jpg","permalink":"https://Liyufei1.github.io/p/blog-build/","title":"Blog Build"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://Liyufei1.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://Liyufei1.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://Liyufei1.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://Liyufei1.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://Liyufei1.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://Liyufei1.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://Liyufei1.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://Liyufei1.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://Liyufei1.github.io/p/emoji-support/","title":"Emoji Support"}]