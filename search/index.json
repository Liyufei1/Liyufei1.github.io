[{"content":"1. 创建一个agent工作流 ","date":"2026-01-15T00:00:00Z","image":"https://Liyufei1.github.io/guidao5.jpg","permalink":"https://Liyufei1.github.io/p/iflow-in-development/","title":"Iflow在开发中的进阶教程"},{"content":"环境搭建 依赖库 GLFW GLFW（OpenGL FrameWork）是一个专门为 OpenGL 和 Vulkan 设计的开源、跨平台的窗口和输入库。它提供了一组简单、直观的 API，用于创建窗口、处理输入（键盘、鼠标、游戏手柄）以及管理 OpenGL 上下文。\n主要特性：\n跨平台支持：支持 Windows、macOS、Linux、FreeBSD 和其他类 Unix 系统 OpenGL 上下文管理：支持创建和管理 OpenGL 上下文，包括核心模式和兼容模式 窗口管理：提供窗口创建、调整大小、位置控制等功能 输入处理：支持键盘、鼠标、游戏手柄等多种输入设备 事件驱动：采用回调机制处理窗口事件、输入事件等 时间管理：提供高精度的时间查询功能 多显示器支持：支持多显示器环境下的窗口管理 与其他窗口库（如 GLUT、SDL）相比，GLFW 更加轻量级，专注于提供 OpenGL 开发所需的核心功能，API 设计简洁，易于使用。它不提供渲染功能，只负责窗口和输入管理，让开发者可以完全专注于 OpenGL 的图形编程。\n接口\n函数 作用 glfwInit() 初始化 GLFW 库，必须在调用其他 GLFW 函数之前调用。成功返回 GLFW_TRUE，失败返回 GLFW_FALSE glfwWindowHint() 设置窗口创建提示，用于配置窗口的属性（如 OpenGL 版本、窗口模式、采样数等）。必须在 glfwCreateWindow 之前调用 glfwCreateWindow() 创建窗口和 OpenGL 上下文。返回窗口指针，失败返回 NULL。参数包括宽度、高度、窗口标题、监视器和共享上下文 glfwMakeContextCurrent() 将指定窗口的 OpenGL 上下文设为当前上下文。必须在调用 OpenGL 函数之前调用，确保 OpenGL 操作作用于正确的窗口 glfwSetFramebufferSizeCallback() 注册帧缓冲大小改变的回调函数。当窗口大小改变时，自动调用该函数，用于更新视口大小等操作 glfwSetInputMode() 设置输入模式。常用配置包括光标模式（正常、隐藏、禁用）、粘滞按键模式等 glfwSetCursorPosCallback() 注册光标位置改变的回调函数。当光标移动时，自动调用该函数，传入光标的屏幕坐标 glfwSetScrollCallback() 注册滚动事件的回调函数。当鼠标滚轮滚动时，自动调用该函数，传入滚动偏移量 glfwWindowShouldClose() 检查窗口是否应该关闭。当用户点击关闭按钮或调用 glfwSetWindowShouldClose 时返回 GLFW_TRUE glfwSwapBuffers() 交换颜色缓冲区。使用双缓冲机制，将渲染好的图像显示到屏幕上，避免闪烁 glfwPollEvents() 处理所有待处理事件。包括键盘输入、鼠标移动、窗口调整大小等。必须在渲染循环中调用 glfwTerminate() 终止 GLFW 库，释放所有分配的资源。在程序退出前调用，清理 GLFW 相关的所有资源 glfwGetTime() 获取自 glfwInit 被调用以来的时间，单位为秒。返回高精度的双精度浮点数，用于动画和计时 GLAD 对OpenGL的接口封装。\n1 2 3 4 5 6 7 8 // 定义函数原型 typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*); // 找到正确的函数并赋值给函数指针 GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)wglGetProcAddress(\u0026#34;glGenBuffers\u0026#34;); // 现在函数可以被正常调用了 GLuint buffer; glGenBuffers(1, \u0026amp;buffer); 窗口搭建 下方是使用GLFW创建窗口的最简示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;glad/glad.h\u0026gt; #include \u0026lt;GLFW/glfw3.h\u0026gt;\t//初始化GLFW glfwInit(); //设置主要和次要版本,本文档使用3.3版本OpenGL的核心模式 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,3); glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE); //新建一个窗口 GLFWwindow * MyWindows = glfwCreateWindow(800,600,\u0026#34;Title\u0026#34;,NULL,NULL); if (MyWindows == NULL){ std::cout \u0026lt;\u0026lt; \u0026#34;Create Windows Failed!\u0026#34; \u0026lt;\u0026lt; std::endl; glfwTerminate(); return -1; } //创建上下文关联 glfwMakeContextCurrent(MyWindows); //初始化GLAD，用于管理OpenGL的函数指针 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){ std::cout \u0026lt;\u0026lt; \u0026#34;Failed to initiallize GLAD \u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } //设置视口,左下角位置为(0,0),宽800，高600 glViewport(0,0,800,600); glEnable(GL_PROGRAM_POINT_SIZE); //注册监听 glfwSetFramebufferSizeCallback(MyWindows,FrameBufferSizeCallback);//监听函数（1）定义在下方 //渲染循环 while (!glfwWindowShouldClose(MyWindows)){ //~Input Begin ProcessInput(MyWindows);//输入函数（2） //~Input End //~Render command Begin glClearColor(0.4f,0.9f,0.8f,1.0f); glClear(GL_COLOR_BUFFER_BIT); //~Render command End //检查并调用事件，交换缓冲 glfwSwapBuffers(MyWindows);//采用双缓存机制，保证帧与帧之间不会闪烁 glfwPollEvents();//检测事件输入：键盘输入、鼠标点击、Window缩放等,并更新Window } glfwTerminate();//释放/删除 分配的资源 监听函数\n1 2 3 4 5 /** When the user changes the size of GlfwWindow , it will change the size of Viewport*/ void FrameBufferSizeCallback(GLFWwindow *Window, int Width, int Height) { glViewport(0,0,Width,Height); } 输入函数\n1 2 3 4 5 6 7 8 9 /** When the user press the \u0026#34;ESC\u0026#34; ,quit the Window */ void ProcessInput(GLFWwindow* Window) { if (glfwGetKey(Window,GLFW_KEY_ESCAPE) == GLFW_PRESS) { glfwSetWindowShouldClose(Window,true); } } OpenGL OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。\n零、杂项 1、glEnable 一、内存相关接口 0、常用示例 1 2 3 4 unsigned int VBO; glGenBuffers(1, \u0026amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 1、glGenBuffers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * @brief 生成一个或多个缓冲区对象的名称（ID）。 * * 该函数会创建一个或多个新的缓冲区对象的标识符（GLuint 类型），这些名称可用于之后的缓冲区绑定和数据传输操作。 * 它仅生成名称，不会分配或初始化任何数据，必须与 glBindBuffer 和 glBufferData 搭配使用。 * * @param n 指定要生成的缓冲区对象名称的数量。 * * @param buffers 指向一个 GLuint 类型的数组，用于存储生成的缓冲区对象名称。 * 调用者需要为该数组分配足够的空间（例如 n 个 GLuint）。 * * @return 无返回值。 * * @note 生成的缓冲区对象在使用前必须通过 glBindBuffer 绑定到合适的目标。 * 若传入的 buffers 数组无效或未分配，可能导致未定义行为。 * * @see glBindBuffer, glBufferData, glDeleteBuffers */ void glGenBuffers(GLsizei n, GLuint *buffers); 2、glBindBuffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * @brief 绑定一个命名的缓冲区对象到指定的缓冲区目标。 * * 该函数将指定的缓冲区对象绑定到给定的缓冲区目标上，使得后续对该目标的缓冲区操作（如数据分配或更新）会作用于此缓冲区对象。 * 如果传入的 buffer 为 0，则会解绑当前绑定的缓冲区对象。 * * @param target 指定要绑定的缓冲区目标。常用的目标包括： * - GL_ARRAY_BUFFER：用于顶点属性数据（VBO） * - GL_ELEMENT_ARRAY_BUFFER：用于索引数据（EBO/IBO） * - GL_UNIFORM_BUFFER、GL_SHADER_STORAGE_BUFFER 等高级用途 * * @param buffer 要绑定的缓冲区对象的名称（ID），由 glGenBuffers 生成。 * 如果设置为 0，表示解绑当前目标的缓冲区对象。 * * @return 无返回值。 * * @note 每个缓冲区目标在任意时刻只能绑定一个缓冲区对象。绑定之后，所有对该目标的操作都作用于当前绑定的对象。 * * @see glGenBuffers, glBufferData, glDeleteBuffers */ void glBindBuffer(GLenum target, GLuint buffer); 3、glBufferData 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * @brief 向当前绑定的缓冲区对象分配内存并可选地传入数据。 * * 该函数用于为当前绑定到指定目标的缓冲区对象分配存储空间，并可将指定的数据复制到缓冲区中。 * 它通常在 glGenBuffers 和 glBindBuffer 之后调用，用于初始化缓冲区数据。 * * @param target 指定缓冲区对象的目标类型。常用值包括： * - GL_ARRAY_BUFFER：用于顶点属性数据 * - GL_ELEMENT_ARRAY_BUFFER：用于索引数据 * * @param size 要分配的缓冲区大小，以字节为单位。 * * @param data 指向包含初始化数据的指针。如果为 NULL，仅分配内存而不初始化数据。 * * @param usage 提示数据的使用方式，帮助 OpenGL 优化性能。常用值包括： * - GL_STATIC_DRAW：数据将很少更改，主要用于绘制 * - GL_DYNAMIC_DRAW：数据会频繁更改，仍用于绘制 * - GL_STREAM_DRAW：数据每帧都可能更新 * * @return 无返回值。 * * @note 如果缓冲区已经有数据，此调用会替换原有内容。 */ void glBufferData(GLenum target, GLsizeiptr size, const void *data, GLenum usage); eg.1 glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 二、着色器 0、代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //eg.1 创建着色器 unsigned int vertexShader; vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, \u0026amp;vertexShaderSource, NULL); glCompileShader(vertexShader); GLint success; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, \u0026amp;success); if (!success) { char infoLog[512]; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); printf(\u0026#34;Shader compilation failed:\\n%s\\n\u0026#34;, infoLog); } //eg.2\t着色器程序 unsigned int shaderProgram; shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); glGetProgramiv(shaderProgram, GL_LINK_STATUS, \u0026amp;success); if(!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); ... } glUseProgram(shaderProgram); glDeleteShader(vertexShader); glDeleteShader(fragmentShader); 1、glCreateShader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * @brief 创建一个着色器对象并返回其 ID。 * * 该函数用于创建一个空的着色器对象。创建后，你需要使用 glShaderSource 提供源代码， * 然后使用 glCompileShader 对其进行编译。 * * @param shaderType 指定要创建的着色器类型。常见的类型包括： * - GL_VERTEX_SHADER：顶点着色器 * - GL_FRAGMENT_SHADER：片段（像素）着色器 * - GL_GEOMETRY_SHADER：几何着色器（可选） * - GL_COMPUTE_SHADER：计算着色器 * - GL_TESS_CONTROL_SHADER / GL_TESS_EVALUATION_SHADER：细分着色器（可选） * * @return 返回一个非零的 GLuint 值，表示新创建的着色器对象的 ID。 * 如果返回值为 0，则表示创建失败（可能是因为上下文错误或 shaderType 无效）。 * * @note 着色器创建后必须手动释放，使用 glDeleteShader 删除不再使用的着色器对象。 * * @see glShaderSource, glCompileShader, glAttachShader, glDeleteShader */ GLuint glCreateShader(GLenum shaderType); 2、glShaderSource 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * @brief 将源代码字符串传递给指定的着色器对象。 * * 该函数用于设置着色器对象的源代码，通常在调用 glCreateShader 创建着色器对象之后使用。 * 设置完成后，需要使用 glCompileShader 对该着色器进行编译。 * * @param shader 着色器对象的 ID，由 glCreateShader 创建。 * * @param count 源码字符串的数量。如果你只传入一个字符串，可以设置为 1。 * * @param string 包含源代码字符串的指针数组（每个元素是一个 C 风格字符串的指针）。 * * @param length 每个字符串的长度数组。可以为 NULL（此时字符串以 null 结尾）， * 否则必须提供一个包含 count 个元素的整型数组，指明每个字符串的长度。 * * @return 无返回值。 * * @note 设置源代码并不会自动编译，需要手动调用 glCompileShader 进行编译。 * * @see glCreateShader, glCompileShader, glGetShaderiv, glGetShaderInfoLog */ void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length); 4、glCompileShader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief 编译一个着色器对象。 * * 此函数用于编译通过 glShaderSource 设置了源代码的着色器对象。编译成功后， * 着色器对象可以被附加到程序对象（Program Object）中。 * * @param shader 要编译的着色器对象 ID，由 glCreateShader 创建，并通过 glShaderSource 设置了源代码。 * * @return 无返回值。 * * @note 编译完成后应使用 glGetShaderiv 和 glGetShaderInfoLog 检查是否编译成功以及获取可能的错误信息。 * 着色器编译失败不会导致 OpenGL 抛出错误，必须手动检查状态。 * * @see glCreateShader, glShaderSource, glGetShaderiv, glAttachShader, glLinkProgram */ void glCompileShader(GLuint shader); 5、glGetShaderiv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * @brief 获取着色器对象的参数信息。 * * 此函数用于查询着色器对象的编译状态或其他相关属性。最常用于检测编译是否成功， * 通常在调用 glCompileShader 后立即使用。 * * @param shader 要查询的着色器对象 ID，由 glCreateShader 创建。 * * @param pname 指定要获取的参数类型。常用值包括： * - GL_COMPILE_STATUS：编译是否成功（GL_TRUE 或 GL_FALSE） * - GL_SHADER_TYPE：着色器类型（如 GL_VERTEX_SHADER） * - GL_DELETE_STATUS：是否已被标记删除 * - GL_INFO_LOG_LENGTH：信息日志的长度（可用于分配 glGetShaderInfoLog 所需的缓冲区） * * @param params 指向整数变量的指针，用于接收查询结果。 * * @return 无返回值。 * * @see glCompileShader, glGetShaderInfoLog, glCreateShader, glShaderSource */ void glGetShaderiv(GLuint shader, GLenum pname, GLint *params); 6、glGetShaderInfoLog 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * @brief 获取着色器编译过程中的信息日志（如错误或警告信息）。 * * 此函数通常在着色器编译失败后调用，用于获取编译错误或警告的详细文本信息。 * * @param shader 要查询的着色器对象 ID，由 glCreateShader 创建并已调用 glCompileShader 编译。 * * @param maxLength 指定 infoLog 缓冲区的最大长度（以字符数计，包括结尾的 null 字符）。 * * @param length 可为 NULL，或者指向一个整数的指针，用于接收实际写入 infoLog 的字符串长度（不包含结尾 null）。 * * @param infoLog 一个字符数组，用于接收信息日志字符串。 * * @return 无返回值。 * * @note 只有在编译失败或编译时出现警告时，信息日志才可能包含内容。 * 建议在编译后始终调用此函数，以便及时发现潜在问题。 * * @see glCompileShader, glGetShaderiv, glCreateShader */ void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog); 7、glDeleteShader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * @brief 删除一个着色器对象。 * * 此函数标记一个着色器对象以供删除。当该着色器不再附加到任何程序对象时，它将被真正释放。 * * @param shader 要删除的着色器对象 ID，由 glCreateShader 创建。 * * @return 无返回值。 * * @note * - 如果该着色器仍然附加到某个程序对象中，它不会立即被删除，而是在分离或删除程序对象后才真正销毁。 * - 即使着色器已经删除，只要程序仍然链接成功，使用该程序对象依然有效。 * - 在成功链接后，你通常可以安全地调用 glDeleteShader 释放中间的 shader 资源。 * * @see glCreateShader, glAttachShader, glCompileShader, glDeleteProgram */ void glDeleteShader(GLuint shader); 三、着色器程序 0、代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //eg.2\t着色器程序 unsigned int shaderProgram; shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); glGetProgramiv(shaderProgram, GL_LINK_STATUS, \u0026amp;success); if(!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); ... } glUseProgram(shaderProgram); glDeleteShader(vertexShader); glDeleteShader(fragmentShader); 1、glCreateProgram 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * @brief 创建一个新的程序对象（Program Object）。 * * 程序对象用于将多个着色器（如顶点着色器、片段着色器等）链接在一起，形成一个完整的 GPU 渲染管线。 * 创建后，可以通过 glAttachShader 附加已编译的着色器，并使用 glLinkProgram 进行链接。 * * @return 返回一个非零的程序对象 ID（GLuint 类型）。如果返回值为 0，表示创建失败。 * * @note 创建的程序对象在使用完毕后应通过 glDeleteProgram 释放。 * 必须先链接（glLinkProgram）后才能使用（glUseProgram）。 * * @see glAttachShader, glLinkProgram, glUseProgram, glDeleteProgram */ GLuint glCreateProgram(void); 2、glAttachShader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * @brief 将一个已编译的着色器对象附加到程序对象上。可以附加多种着色器，但是每种着色器仅支持一个， *\t特别的计算着色器与其他不混用 * glAttachShader(program, vertexShader); // 顶点着色器 glAttachShader(program, fragmentShader); // 片段着色器 glAttachShader(program, geometryShader); // 几何着色器（可选） glAttachShader(program, tessCtrlShader); // 曲面细分控制（可选） glAttachShader(program, tessEvalShader); // 曲面细分评估（可选） * 此函数用于将已经编译成功的着色器附加到一个 OpenGL 程序对象（program object）中。 * 一个程序可以附加多个不同类型的着色器（例如顶点和片段着色器），在链接程序时将它们组合成一个完整的渲染管线。 * * @param program 要附加着色器的程序对象 ID，由 glCreateProgram 创建。 * * @param shader 要附加的着色器对象 ID，需由 glCreateShader 创建并通过 glCompileShader 编译。 * * @return 无返回值。 * * @note * - 一个着色器对象可以附加到多个程序对象中。 * - 必须在 glLinkProgram 之前调用 glAttachShader。 * - 可以多次调用以附加多个不同类型的着色器。 * - 调用 glDeleteShader 删除着色器不会立即销毁它，只要它仍然被附加到程序上。 * * @see glCreateProgram, glCreateShader, glCompileShader, glLinkProgram, glDetachShader, glDeleteShader */ void glAttachShader(GLuint program, GLuint shader); 3、glLinkProgram 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * @brief 链接一个程序对象，将附加的着色器组合为一个可执行的 GPU 程序。 * * 此函数用于将通过 glAttachShader 附加到程序对象的各个着色器进行链接。 * 链接成功后，该程序对象可以通过 glUseProgram 启用用于渲染或计算任务。 * * @param program 程序对象的 ID，由 glCreateProgram 创建，且已附加所需的着色器对象。 * * @return 无返回值。 * * @note * - 链接前必须附加至少一个着色器对象（通常是顶点和片段着色器）。 * - 链接后可以调用 glGetProgramiv 和 glGetProgramInfoLog 检查是否成功。 * - 成功链接后，可以分离或删除着色器对象（glDetachShader、glDeleteShader），不会影响程序对象。 * * @see glCreateProgram, glAttachShader, glUseProgram, glGetProgramiv, glGetProgramInfoLog */ void glLinkProgram(GLuint program); 4、glGetProgramiv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * @brief 获取程序对象的参数信息（如链接状态、日志长度等）。 * * 此函数用于查询 OpenGL 程序对象的状态或属性，常用于在 glLinkProgram 后检查是否链接成功。 * * @param program 要查询的程序对象 ID，由 glCreateProgram 创建。 * * @param pname 指定要获取的参数类型。常用值包括： * - GL_LINK_STATUS：链接是否成功（GL_TRUE 或 GL_FALSE） * - GL_VALIDATE_STATUS：验证状态是否成功 * - GL_INFO_LOG_LENGTH：信息日志的长度（用于分配 glGetProgramInfoLog 的缓冲区） * - GL_ATTACHED_SHADERS：附加的着色器数量 * - GL_ACTIVE_ATTRIBUTES：活跃的顶点属性数量 * - GL_ACTIVE_UNIFORMS：活跃的 uniform 数量 * * @param params 指向整数变量的指针，用于接收查询结果。 * * @return 无返回值。 * * @note 通常与 glGetProgramInfoLog 配合使用，用于在程序链接失败时获取错误信息。 * * @see glLinkProgram, glGetProgramInfoLog, glAttachShader */ void glGetProgramiv(GLuint program, GLenum pname, GLint *params); 5、glGetProgramInfoLog 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * @brief 获取程序对象的链接或验证阶段的错误或警告信息日志。 * * 此函数用于在调用 glLinkProgram 或 glValidateProgram 后获取程序对象的编译/链接日志， * 主要用于调试失败的着色器程序。 * * @param program 要查询的程序对象 ID，由 glCreateProgram 创建。 * * @param maxLength infoLog 缓冲区的最大长度（以字符数为单位，包括结尾 null 字符）。 * * @param length 可为 NULL，或者指向整数变量的指针，用于接收写入 infoLog 的实际长度（不包括结尾 null）。 * * @param infoLog 接收日志字符串的字符数组（必须由用户分配内存）。 * * @return 无返回值。 * * @note * - 在 glLinkProgram 或 glValidateProgram 之后调用此函数。 * - 如果程序对象没有信息日志（如链接成功且无警告），返回的 infoLog 可能是空字符串。 * * @see glLinkProgram, glValidateProgram, glGetProgramiv */ void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog); 6、glUseProgram 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * @brief 激活指定的程序对象，使其成为当前使用的着色器程序。 * * 此函数将一个已成功链接的程序对象设为当前 OpenGL 状态下使用的着色器程序， * 后续所有绘图操作将使用该程序中的着色器执行渲染。 * * @param program 程序对象的 ID，由 glCreateProgram 创建并成功链接。如果设置为 0，表示取消当前着色器程序（使用固定功能管线，如果支持）。 * * @return 无返回值。 * * @note * - 程序必须在调用 glLinkProgram 后才能使用。 * - 每次只能激活一个程序对象，重复调用会替换之前的。 * - 在绘制前必须调用 glUseProgram 激活程序，否则顶点和片段着色器不会生效。 * * @see glCreateProgram, glAttachShader, glLinkProgram, glDeleteProgram */ void glUseProgram(GLuint program); 四、缓存 0.示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 unsigned int VBO, VAO; glGenVertexArrays(1, \u0026amp;VAO); glGenBuffers(1, \u0026amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0); 1. glVertexAttribPointer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * @brief 定义一个顶点属性数组中单个属性的内存布局。 * * 此函数用于告诉 OpenGL 如何从当前绑定的顶点缓冲区对象中读取顶点属性（如位置、颜色、法线等）。 * 它定义了顶点属性在缓冲区中的数据格式和偏移方式。 * * @param index 顶点着色器中输入变量的位置（location），由 layout(location = x) 指定或通过 glGetAttribLocation 查询。 * * @param size 每个顶点属性的数据数量（1~4）。如 vec3 则为 3。 * * @param type 数据类型。常见的有： * - GL_FLOAT * - GL_INT * - GL_UNSIGNED_BYTE 等 * * @param normalized 指定数据是否在送入着色器前需要归一化（如 GL_UNSIGNED_BYTE 转换为 [0,1]）。 * 通常为 GL_FALSE。 * * @param stride 每个顶点的字节间隔（步长）。如果数据是紧密排列的，可以传 0。 * * @param pointer 指向第一个顶点属性数据在缓冲区中的偏移量（可以是偏移量值或 (void*)0 表示起始）。 * * @return 无返回值。 * * @note * - 调用前必须绑定一个对应的缓冲区到 `GL_ARRAY_BUFFER`。 * - 调用后需启用该属性：`glEnableVertexAttribArray(index)`。 * - 所有配置只影响当前绑定的 VAO（顶点数组对象）。 * * @see glEnableVertexAttribArray, glDisableVertexAttribArray, glBindBuffer, glVertexAttribDivisor */ void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer); 2.glEnableVertexAttribArray 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * @brief 启用一个顶点属性数组。 * * 此函数用于启用通过 glVertexAttribPointer 定义的顶点属性，使其在渲染时被 GPU 使用。 * 如果没有启用，对应属性即使定义了也不会生效。 * * @param index 顶点属性的位置（location），对应着色器中 layout(location = x) 或 glGetAttribLocation 的返回值。 * * @return 无返回值。 * * @note * - 顶点属性默认是禁用的，必须手动启用。 * - 启用后，GPU 会从绑定的 VBO 中按 glVertexAttribPointer 定义读取该属性。 * - 绑定的 VAO 会记录该状态，因此建议在设置 VAO 时启用。 * * @see glVertexAttribPointer, glDisableVertexAttribArray, glBindVertexArray */ void glEnableVertexAttribArray(GLuint index); 3.glGenBuffers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * @brief 生成一个或多个缓冲区对象名称（ID）。 * * 该函数用于创建一个或多个新的 OpenGL 缓冲区对象标识符（名称），这些对象可用于存储顶点数据、 * 索引数据、统一变量等。生成的名称可用于后续的 glBindBuffer 和 glBufferData 等操作。 * * @param n 要生成的缓冲区对象数量。 * @param buffers 指向 GLuint 数组的指针，用于存储生成的缓冲区对象名称。 * 调用者必须预先为该数组分配至少 n 个元素的空间。 * * @return 无返回值。 * * @note * - 此函数只分配名称（ID），不分配 GPU 内存。必须通过 glBindBuffer + glBufferData 才能真正使用。 * - 创建后可使用 glDeleteBuffers 删除对象，释放资源。 * * @see glBindBuffer, glBufferData, glDeleteBuffers */ void glGenBuffers(GLsizei n, GLuint *buffers); 4.glBindBuffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * @brief 将一个缓冲区对象绑定到指定的缓冲区目标。 * * 此函数将给定的缓冲区对象 ID 绑定到指定目标，使其成为当前活跃的缓冲区。 * 后续对该目标的操作（如 glBufferData、glVertexAttribPointer）将作用于此绑定对象。 * * @param target 指定要绑定的缓冲区目标。常见目标包括： * - GL_ARRAY_BUFFER：顶点缓冲对象（VBO） * - GL_ELEMENT_ARRAY_BUFFER：索引缓冲对象（EBO/IBO） * - GL_UNIFORM_BUFFER：统一变量缓冲区 * - GL_SHADER_STORAGE_BUFFER：着色器存储缓冲区 * * @param buffer 要绑定的缓冲区对象 ID，由 glGenBuffers 创建。如果为 0，则解绑当前目标的缓冲区对象。 * * @return 无返回值。 * * @note * - 每个缓冲区目标在任一时刻只能绑定一个缓冲区对象。 * - 调用 glBindBuffer 后的所有缓冲区操作将作用于当前绑定的目标。 * - VAO（顶点数组对象）会记录对 GL_ARRAY_BUFFER 和 GL_ELEMENT_ARRAY_BUFFER 的绑定状态。 * * @see glGenBuffers, glBufferData, glDeleteBuffers, glBindVertexArray */ void glBindBuffer(GLenum target, GLuint buffer); 5.glGenVertexArrays 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * @brief 生成一个或多个顶点数组对象（VAO）的名称（ID）。 * * 顶点数组对象用于封装所有与顶点输入有关的状态，包括顶点属性指针（如位置、颜色、法线等）、 * 顶点缓冲绑定和索引缓冲绑定等。使用 VAO 可以简化绘制调用，并提高渲染效率。 * * @param n 要生成的 VAO 数量。 * @param arrays 指向 GLuint 数组的指针，用于存储生成的 VAO 名称。 * * @return 无返回值。 * * @note * - 生成的 VAO 名称本身没有分配实际资源，只有在绑定并配置时才真正记录状态。 * - 每次绘制前应绑定对应的 VAO。 * - VAO 的状态包括：glVertexAttribPointer 设置、glEnableVertexAttribArray 状态、绑定的 VBO 和 EBO。 * * @see glBindVertexArray, glDeleteVertexArrays, glVertexAttribPointer, glEnableVertexAttribArray */ void glGenVertexArrays(GLsizei n, GLuint *arrays); 6.glBindVertexArray 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * @brief 绑定一个顶点数组对象（VAO）。 * * 此函数将指定的顶点数组对象绑定为当前使用的 VAO。绑定后，所有与顶点输入相关的状态设置（如属性指针、启用状态、缓冲区绑定等）将记录在此 VAO 中。 * * @param array 要绑定的 VAO 的 ID，由 glGenVertexArrays 生成。传入 0 表示解绑当前 VAO。 * * @return 无返回值。 * * @note * - VAO 会记录：glVertexAttribPointer 设置、glEnableVertexAttribArray 状态、当前绑定的 GL_ARRAY_BUFFER 和 GL_ELEMENT_ARRAY_BUFFER。 * - 绘图前必须绑定正确的 VAO。 * - VAO 状态与绑定缓冲区对象是绑定在一起的，必须在绑定 VAO 后设置缓冲区。 * * @see glGenVertexArrays, glVertexAttribPointer, glEnableVertexAttribArray, glDrawArrays, glDrawElements */ void glBindVertexArray(GLuint array); 7.glBufferData 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * @brief 创建并初始化缓冲区对象的数据存储。 * * 此函数为当前绑定的缓冲区对象（如 GL_ARRAY_BUFFER 或 GL_ELEMENT_ARRAY_BUFFER）分配内存，并可以选择性地初始化数据。它是设置顶点数据或索引数据的关键步骤。 * * @param target 指定要操作的缓冲区类型，常用值有 GL_ARRAY_BUFFER、GL_ELEMENT_ARRAY_BUFFER、GL_UNIFORM_BUFFER 等。 * @param size 分配的内存大小（以字节为单位）。 * @param data 指向要复制到缓冲区的数据指针，传入 NULL 表示只分配内存不初始化。 * @param usage 指定缓冲区的预期用途模式，例如 GL_STATIC_DRAW、GL_DYNAMIC_DRAW、GL_STREAM_DRAW。 * * @return 无返回值。 * * @note * - 此函数会使之前缓冲区中的内容失效（即使大小不变）。 * - `usage` 参数不会影响渲染结果，仅用于驱动优化内存管理。 * - 使用前应绑定对应的缓冲区目标；绑定点由 `target` 参数指定。 * - 若要更新已有缓冲数据的局部内容，应使用 glBufferSubData。 * * @see glGenBuffers, glBindBuffer, glBufferSubData, glDeleteBuffers */ void glBufferData(GLenum target, GLsizeiptr size, const void *data, GLenum usage); 五、绘制 0.示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // ------------------------------------------------------------------ float vertices[] = { 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left }; unsigned int indices[] = { // note that we start from 0! 0, 1, 3, // first Triangle 1, 2, 3 // second Triangle }; unsigned int VBO, VAO, EBO; glGenVertexArrays(1, \u0026amp;VAO); glGenBuffers(1, \u0026amp;VBO); glGenBuffers(1, \u0026amp;EBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0); while (!glfwWindowShouldClose(window)) { processInput(window); glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // draw our first triangle glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glfwSwapBuffers(window); glfwPollEvents(); } 1.glDrawElements 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * @brief 使用索引数组渲染图元（基于索引的绘制）。 * * glDrawElements 根据当前绑定的顶点数组对象（VAO）和索引缓冲对象（EBO）中的索引， * 从已绑定的顶点缓冲对象（VBO）中读取顶点数据，并按指定的绘制模式渲染图元。 * * @param mode 指定要渲染的图元类型。可选值包括： * - GL_POINTS * - GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES * - GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES * - 以及其他从 OpenGL 扩展中支持的模式。 * @param count 指定将要渲染的索引数量（元素数量），即索引数组中元素的个数。 * @param type 指定索引数组中每个索引的数据类型。可选值为： * - GL_UNSIGNED_BYTE * - GL_UNSIGNED_SHORT * - GL_UNSIGNED_INT * （注意：部分旧版硬件可能不支持 32 位无符号整型索引） * @param indices 指定索引数据的偏移量或指针： * - 当已绑定 GL_ELEMENT_ARRAY_BUFFER（EBO）时，此参数被视为字节偏移量（const void* offset）。 * - 若未绑定 EBO，则此参数为指向客户端内存中索引数组的指针（已废弃，现代 OpenGL 建议使用 EBO）。 * * @return 无返回值。 * * @note * - 渲染前必须绑定相应的 VAO，并确保该 VAO 已记录了正确的顶点属性和 EBO 绑定状态。 * - 索引读取的位置基于当前绑定的 GL_ELEMENT_ARRAY_BUFFER 对象，并受 type 参数指定的字节大小影响。 * - 如果 indices 为非零指针且未绑定 EBO，则索引数据会从客户端内存读取，但此用法在核心模式下已不推荐。 * - glDrawElements 是一次性绘制，若需多实例绘制，请使用 glDrawElementsInstanced。 * - 绘制完成后，OpenGL 会根据当前上下文状态（剔除、深度测试、混合等）对图元进行处理。 * * @see glDrawArrays, glDrawElementsInstanced, glBindBuffer, glBindVertexArray */ void glDrawElements(GLenum mode,GLsizei count,GLenum type,const void *indices); 2. glUniform1f 设置单个浮点数 uniform 变量的值。\n3. glUniform3f 设置三个浮点数 uniform 变量的值。\n4. glUniform3fv 设置浮点数向量 uniform 变量的值。\n六、纹理 贴图的UV坐标如下分布：\n0.代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //创建和绑定 mData = stbi_load(path, \u0026amp;mWidth, \u0026amp;mHeight, \u0026amp;mChannels, 0); //利用stb_image读取图片 glGenTextures(1, \u0026amp;mTextureID); glBindTexture(GL_TEXTURE_2D, mTextureID); //设置环绕方式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, mSurroundMode); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, mSurroundMode); //设置滤波方式（采样） glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, mFilterMode); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, mFilterMode); //绑定原始数据 switch (mChannels) { default: case 3: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, mWidth, mHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, mData); break; case 4: glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, mData); break; } //生成mipmap glGenerateMipmap(GL_TEXTURE_2D); //使用 glUniform1i(\u0026#34;uTexture\u0026#34;,0);//需要先设置贴图通道 glActiveTexture(GL_TEXTURE0 + i); glBindTexture(GL_TEXTURE_2D, mTextureID); glBindVertexArray(mVAO); glDrawElements(GL_TRIANGLES, mMeshBatch.indexs.size(), GL_UNSIGNED_INT, 0); 1. glTexParameteri image-20250716134350990.png\nimage-20250716133617973\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * @brief 设置纹理对象的参数属性（如过滤方式和环绕模式）。 * * glTexParameteri 用于为当前绑定的纹理对象指定特定的行为参数，常用于定义纹理在缩放、 * 环绕等情况下的表现方式。该函数只适用于绑定到当前激活纹理目标的纹理对象。 * * @param target 指定纹理目标类型。可选值包括： * - GL_TEXTURE_1D * - GL_TEXTURE_2D * - GL_TEXTURE_3D * - GL_TEXTURE_CUBE_MAP * - 以及其他 OpenGL 扩展支持的目标。 * * @param pname 指定要设置的纹理参数名。常用值包括： * - GL_TEXTURE_MIN_FILTER：纹理缩小时的过滤方式 * - GL_TEXTURE_MAG_FILTER：纹理放大时的过滤方式 * - GL_TEXTURE_WRAP_S：纹理在 S（U）轴的环绕模式 * - GL_TEXTURE_WRAP_T：纹理在 T（V）轴的环绕模式 * - GL_TEXTURE_WRAP_R：纹理在 R（W）轴的环绕模式（仅适用于 3D/立方体贴图） * * @param param 指定 pname 所对应的参数值。取值依赖于 pname 的类型： * - 过滤方式常用值： * - GL_NEAREST：最近点采样 * - GL_LINEAR：线性插值采样 * - GL_NEAREST_MIPMAP_NEAREST / GL_LINEAR_MIPMAP_LINEAR 等（用于 mipmap） * - 环绕模式常用值： * - GL_REPEAT：重复纹理 * - GL_CLAMP_TO_EDGE：边缘钳制 * - GL_MIRRORED_REPEAT：镜像重复 * * @return 无返回值。 * * @note * - glTexParameteri 必须在绑定了相应纹理（通过 glBindTexture）之后调用，否则无效。 * - 对于 mipmap 过滤方式，需要使用 glGenerateMipmap 或手动指定每级 mipmap 层。 * - 若未设置合适的过滤和环绕模式，可能会导致纹理显示异常或性能下降。 * - 纹理参数是纹理对象状态的一部分，一旦设置便会被该纹理一直使用，除非再次修改。 * * @see glTexParameterf, glBindTexture, glTexImage2D, glGenerateMipmap */ void glTexParameteri(GLenum target, GLenum pname, GLint param); 2.glTexParameterfv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * @brief 设置纹理对象的参数属性（以浮点数组形式传入）。 * * glTexParameterfv 用于为当前绑定的纹理对象指定某个纹理参数，其值通过一个浮点数组传入。 * 适用于参数值为浮点向量类型的纹理属性（如边界颜色等）。 * * @param target 指定纹理目标类型。可选值包括： * - GL_TEXTURE_1D * - GL_TEXTURE_2D * - GL_TEXTURE_3D * - GL_TEXTURE_CUBE_MAP * - 以及其他 OpenGL 扩展支持的目标。 * * @param pname 指定要设置的纹理参数名。常用值包括： * - GL_TEXTURE_BORDER_COLOR：纹理边界颜色（需传入4个float） * - 其他接受浮点数组作为参数的扩展参数 * * @param params 指向浮点值数组的指针，其内容依赖于 pname 的要求： * - 若 pname 为 GL_TEXTURE_BORDER_COLOR，则应提供 4 个元素的 RGBA 数组（例如：{1.0f, 1.0f, 1.0f, 1.0f}）。 * - 其他 pname 可根据具体 OpenGL 扩展需求设置对应数量的 float。 * * @return 无返回值。 * * @note * - glTexParameterfv 与 glTexParameteri 用法类似，但参数类型为浮点数组。 * - 在设置 GL_TEXTURE_BORDER_COLOR 时，纹理环绕模式需配合 GL_CLAMP_TO_BORDER 使用才能生效。 * - 请确保已正确绑定纹理对象，否则调用将不会产生效果。 * - 不支持的 pname 值可能在不同硬件或 OpenGL 版本下导致行为未定义。 * * @see glTexParameteri, glTexParameterf, glBindTexture, glTexImage2D, glTexParameteriv */ void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params); 3.glGenTextures 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * @brief 生成一个或多个新的纹理对象名称。 * * glGenTextures 用于请求 OpenGL 创建一个或多个唯一的纹理对象 ID（名称），这些纹理对象 * 可通过 glBindTexture 绑定并进一步配置。生成的纹理对象尚未初始化，需通过绑定后使用。 * * @param n 指定要生成的纹理对象名称数量（即纹理数量）。 * @param textures 指向 GLuint 类型数组的指针，用于接收生成的纹理名称（ID）。 * - 该数组的大小应至少为 n。 * - 得到的纹理 ID 可通过 glBindTexture 绑定至指定纹理目标。 * * @return 无返回值。 * * @note * - 生成的纹理对象名称在首次绑定前是“未初始化状态”，OpenGL 不会自动分配存储或属性。 * - 调用 glGenTextures 只生成名称，不会做任何资源分配，资源分配将在 glTexImage* 发生。 * - 可以通过 glDeleteTextures 删除不再使用的纹理对象，释放资源。 * - 不应在未初始化的纹理对象上调用渲染操作，否则结果未定义。 * * @see glBindTexture, glDeleteTextures, glTexImage2D, glTexParameteri */ void glGenTextures(GLsizei n, GLuint *textures); 4.glTexImage2D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * @brief 为当前绑定的二维纹理对象指定二维像素图像数据。 * * glTexImage2D 用于向当前绑定到 target 的二维纹理对象上传图像数据， * 并为该纹理分配存储空间。可用于初始化纹理或替换指定 mipmap 级别的数据。 * * @param target 指定纹理目标类型。常用值： * - GL_TEXTURE_2D * - GL_PROXY_TEXTURE_2D（仅用于查询纹理规格，不分配内存） * - GL_TEXTURE_CUBE_MAP_POSITIVE_X 等立方体贴图面（若用二维调用） * @param level 指定 mipmap 级别。0 为基准级（最高分辨率），n 为第 n 级 mipmap。 * @param internalFormat 指定纹理在 GPU 中的内部存储格式，例如： * - GL_RGB, GL_RGBA * - GL_R8, GL_RG16F * - GL_DEPTH_COMPONENT24 等 * @param width 指定纹理图像的宽度（像素数），必须为正整数。 * @param height 指定纹理图像的高度（像素数），对于一维纹理应为 1。 * @param border 指定边框宽度，必须为 0（核心模式不支持非零边框）。 * @param format 指定像素数据的布局格式，例如： * - GL_RGB, GL_RGBA, GL_RED, GL_DEPTH_COMPONENT 等 * @param type 指定像素数据的类型，例如： * - GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_FLOAT 等 * （取决于 format 支持的数据类型） * @param data 指向客户端内存中图像数据的指针；若为 NULL，则只分配存储，不上传数据。 * * @return 无返回值。 * * @note * - 调用前必须已绑定纹理对象：glBindTexture(target, texID)。 * - internalFormat 与 format/type 组合必须受硬件支持，否则可能产生错误或降级行为。 * - 若需要创建完整 mipmap 级别，可多次调用 glTexImage2D 上传每个 level，或在上传基准级后调用 glGenerateMipmap。 * - GL_PROXY_TEXTURE_2D 可用于测试指定格式/尺寸是否被支持，查询后不分配实际存储。 * - 对于子区域更新，可改用 glTexSubImage2D 以避免重分配存储。 * * @see glBindTexture, glTexSubImage2D, glGenerateMipmap, glTexImage3D */ void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *data); 图形学相关 一、坐标空间 0、GLM的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 1、矢量和矩阵的初始化 glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f); glm::mat4x4 MView = glm::mat4(1.0f); // 2、变换矩阵 // 平移 Mtrans = glm::translate(Mtrans, glm::vec3(1.0f, 1.0f, 0.0f)); // 缩放 MScale = glm::scale(MScale, glm::vec3(1.0f, 1.5f, 1.0f)); // 旋转（欧拉角） MRot = glm::rotate(MRot, glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f)); // 转置 MTranspose = glm::transpose(Mx); // 3、模型矩阵 MModel = MTran * MRota; // 表示在本地坐标系下，模型自身的变换 // 4、观察矩阵 MView = MrT * M-t; // 表示摄像机的变换，并将其反变换作用在模型上 // 5、投影透视矩阵 Mpersp = glm::perspective(glm::radians(45.0f), 1.0f, 0.1f, 100.0f); // 投影盒子+透视 // 6、总矩阵 M = Mpersp * MView * MModel; 1、简介 将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个过渡坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：\n局部空间(Local Space，或者称为物体空间(Object Space)) 世界空间(World Space) 观察空间(View Space，或者称为视觉空间(Eye Space)) 裁剪空间(Clip Space) 屏幕空间(Screen Space) coordinate_systems.png\n模型(Model)、观察(View)、投影(Projection)三个矩阵 $$ M_{Total}=M_{Projection}*M_{View}*M_{Model} $$2、局部空间（模型矩阵） 平移矩阵：$T_{t_x,t_y}=\\left( \\begin{matrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x \\ 0 \u0026amp; 1 \u0026amp; 0\u0026amp; t_y \\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z \\ 0\u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right) \\tag{3}$\n旋转矩阵：\n绕$\\hat z$方向逆时针旋转矩阵:$R_{\\theta}=\\left( \\begin{matrix} \\cos \\theta \u0026amp; -\\sin \\theta \u0026amp; 0 \u0026amp; 0 \\ \\sin \\theta \u0026amp; \\cos \\theta \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\ 0 \u0026amp; 0\u0026amp;0\u0026amp;1 \\end{matrix} \\right) \\tag{4}$\n绕$\\hat x$方向逆时针旋转矩阵:$R_{\\theta}=\\left( \\begin{matrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; \\cos \\theta \u0026amp; \\sin \\theta \u0026amp; 0 \\ 0 \u0026amp; -\\sin \\theta \u0026amp; \\cos \\theta \u0026amp; 0 \\ 0 \u0026amp; 0\u0026amp;0\u0026amp;1 \\end{matrix} \\right) \\tag{4}$\n绕$\\hat y$方向逆时针旋转矩阵:$R_{\\theta}=\\left( \\begin{matrix} \\cos \\theta \u0026amp; 0 \u0026amp; \\sin \\theta \u0026amp; 0 \\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\ -\\sin \\theta \u0026amp; 0 \u0026amp; \\cos \\theta \u0026amp; 0 \\ 0 \u0026amp; 0\u0026amp;0\u0026amp;1 \\end{matrix} \\right) \\tag{4}$\n对于旋转矩阵R，有以下性质$R^{-1}\\theta =R{-\\theta}=R_\\theta ^T$\n缩放矩阵：$S_{s_x,s_y}=\\left( \\begin{matrix} s_x \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; s_y \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; s_z \u0026amp; 0\\ 0 \u0026amp;0 \u0026amp;0 \u0026amp;1 \\end{matrix} \\right) \\tag{3}$\n切变：$S_{s_x,s_y}=\\left( \\begin{matrix} 1 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\ 0 \u0026amp;0\u0026amp;0\u0026amp;1 \\end{matrix} \\right) $\n模型矩阵一般由平移矩阵、缩放矩阵、旋转矩阵相乘得到。\n$$ M_{model}=M_{transform}*M_{Scale}*M_{rotarion} $$ 1 2 3 4 5 6 7 8 glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f); glm::mat4x4 Mtrans = glm::mat4(1.0f); glm::mat4x4 MProject = glm::perspective(glm::radians(90.0f), 1.0f, 0.1f, 100.0f); // 投影矩阵 glm::mat4x4 Mtrans = glm::translate(Mtrans, glm::vec3(0.0f, 0.0f, -3.0f)); // 生成平移矩阵 glm::mat4x4 MScale = glm::scale(MScale, glm::vec3(1.0f, 1.0f, 1.0f)); // 生成缩放矩阵 glm::mat4x4 MRot = glm::rotate(MRot, glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f)); // 生成旋转矩阵 3、摄像机（视口矩阵） image-20250717171129515.png\n（1）摄像机位置 1 glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f); （2）摄像机方向 1 2 glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f); glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget); （3）摄像机的右轴和上轴 1 2 3 glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection)); glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight); （4）LookAt矩阵 ​\t使用矩阵的好处之一是如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。\n​\tglm::LookAt函数需要一个位置、目标和上向量。它会创建一个和在上一节使用的一样的观察矩阵。\nimage-20241126162019735.png\n1 2 glm::mat4 view; view = glm::lookAt(cameraPos, cameraTarget,up); 二、光照 1、布林恩-冯模型 环境光: vec3 ambient = ambientStrength * lightColor * objectColor;\n环境光因子一般由一个较小的因子乘上光照颜色得到。再由环境光因子与物体颜色相乘，就可以得到环境光照对物体的作用结果。 漫反射：vec3 diffuse = max(dot(norm, lightDir), 0.0)* lightColor * objectColor;\n漫反射反应的是光在该平面上的光通量强度，当入射进该平面的光越多，漫反射就越强。 image-20250922094541562.png 镜面反射： vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), 32) * lightColor * objectColor;其中：vec3 reflectDir = reflect(-lightDir, norm);\n镜面反射强度，与光线出射角以及观察方向，直接相关。当两者夹角越小，镜面反射强度越高。同时对该影响因子的幂次越高，高光越集中化。 image-20250922094927976.png image-20250922100232547.png 注意事项：法线由局部坐标系转换到世界坐标系不能简单的通过模型矩阵来计算。如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。见下图：image-20250922100002164.png\u0026quot;\n因此，世界坐标中的法线一般采用Normal = mat3(transpose(inverse(model))) * aNormal;的方式来计算获得。\n2、直接光源 采用布林恩冯模型\n环境光： 光源颜色 * 物体颜色 物体颜色可采用漫反射贴图 vec3 ambient = light.ambient * objectColor; 漫反射： 需要考虑光线入射角和表面法线夹角 物体颜色可采用漫反射贴图 vec3 diffuse = max(dot(norm, lightDir), 0.0)* light.diffuse* objectColor; 镜面反射 ： 考虑光线出射角和观察视线的夹角 物体颜色可采用镜面反射贴图 vec3 specular = pow(max(dot(viewDir, reflectDir), 0.0), 32) * light.specular* objectColor; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct Material { sampler2D diffuse; sampler2D specular; float shininess; }; struct Dirlight { vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular; }; vec3 CalcDirLight(Dirlight light, vec3 normal, vec3 viewDir) { vec3 lightDir = normalize(-light.direction); vec3 reflectDir = reflect(light.direction, normal); vec3 ambient = light.ambient * texture(uMaterial.diffuse, TexCoord.xy).rgb ; //环境光 vec3 diffuse = max(dot(normal, lightDir), 0.0f) * light.diffuse * texture(uMaterial.diffuse, TexCoord.xy).rgb; //漫反射 vec3 specular = pow(max(dot(reflectDir,viewDir), 0.0f), uMaterial.shininess) * light.specular * texture(uMaterial.specular,TexCoord.xy).rgb; //镜面光 return (ambient + diffuse + specular); } 3、点光源 采用布林恩冯模型，与平行光仅有微小的差异\n光线方向需要有点光源位置与片段位置计算得出 点光源的强度会随距离衰减。 image-20251014110623598.png\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct Material { sampler2D diffuse; //漫反射贴图 sampler2D specular; //镜面光贴图 float shininess; //高光指数 }; struct PointLight { vec3 position; //点光源位置 float constant; //常数项 float linear; //线性项 float quadratic; //二次项 vec3 ambient; //环境光 vec3 diffuse; //漫反射 vec3 specular; //镜面光 }; vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir) { vec3 lightDir = normalize(light.position - fragPos); vec3 reflectDir = reflect(-lightDir, normal); float distance = length(light.position - fragPos); float attenuation = 1.0f / (light.constant + light.linear * distance + light.quadratic * (distance * distance)); vec3 ambient = light.ambient * texture(uMaterial.diffuse, TexCoord.xy).rgb ; //环境光 vec3 diffuse = max(dot(normal, lightDir), 0.0f) * light.diffuse * texture(uMaterial.diffuse, TexCoord.xy).rgb; //漫反射 vec3 specular = pow(max(dot(reflectDir,viewDir), 0.0f), uMaterial.shininess) * light.specular * texture(uMaterial.specular,TexCoord.xy).rgb; //镜面光 return (ambient + diffuse + specular) * attenuation; } 4、聚光灯 聚光灯是一种位置在环境中的光源，它只在一个特定的方向上发射光线，并且光线会随着距离逐渐衰减。聚光灯通常用于模拟手电筒、车灯等效果。\n聚光灯的光照计算需要考虑：\n光源位置和方向 聚光灯的切光角（Cut-off angle） 聚光灯的外切光角（Outer cut-off angle） 光线衰减 三、材质 在布林恩冯模型下，我们希望更精细的控制光照表现，因此抽象出了材质的概念。\n物体材质（Material）包含以下几个属性：\nambient：基础颜色。定义了在环境光照下这个表面反射的是什么颜色，通常与表面的颜色相同。 diffuse：漫反射。定义了在漫反射光照下表面的颜色。漫反射颜色（和环境光照一样）也被设置为我们期望的物体颜色。 specular：镜面反射，设置的是表面上镜面高光的颜色（或者甚至可能反映一个特定表面的颜色）。 shininess：镜面反射半径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #version 330 core struct Material { vec3 ambient; vec3 diffuse; vec3 specular; float shininess; }; uniform Material material; lightingShader.setVec3(\u0026#34;material.ambient\u0026#34;, 1.0f, 0.5f, 0.31f); lightingShader.setVec3(\u0026#34;material.diffuse\u0026#34;, 1.0f, 0.5f, 0.31f); lightingShader.setVec3(\u0026#34;material.specular\u0026#34;, 0.5f, 0.5f, 0.5f); lightingShader.setFloat(\u0026#34;material.shininess\u0026#34;, 32.0f); 除了物体材质本身，光也具有自身的属性。\n一个光源对它的ambient、diffuse和specular光照分量有着不同的强度。环境光照通常被设置为一个比较低的强度，因为我们不希望环境光颜色太过主导。光源的漫反射分量通常被设置为我们希望光所具有的那个颜色，通常是一个比较明亮的白色。镜面光分量通常会保持为vec3(1.0)，以最大强度发光。注意我们也将光源的位置向量加入了结构体\n1 2 3 4 5 6 7 8 9 struct Light { vec3 position; vec3 ambient; vec3 diffuse; vec3 specular; }; uniform Light light; GLSL GLSL由三部分构成：vertex + fragment\n版本指定：#version 310 es\n零、简单的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** This is a VertexShader */ const char* VertexShaderSource = \u0026#34;#version 330 core\\n\u0026#34; \u0026#34;layout (location = 0) in vec3 aPos;\\n\u0026#34; \u0026#34;void main()\\n\u0026#34; \u0026#34;{\\n\u0026#34; \u0026#34; gl_Position = vec4(aPos.x,aPos.y,aPos.z,1.0);\\n\u0026#34; \u0026#34; gl_PointSize = 20.0f;\\n\u0026#34; \u0026#34;}\\0\u0026#34; ; /** This is a FragmentShader */ const char* FragmentShaderSource = \u0026#34;#version 330 core\\n\u0026#34; \u0026#34;out vec4 FragColor;\\n\u0026#34; \u0026#34;void main()\\n\u0026#34; \u0026#34;{\\n\u0026#34; \u0026#34; FragColor = vec4(1.0f,0.5f,0.2f,1.0f);\\n\u0026#34; \u0026#34;}\\0\u0026#34; ; 一、着色器关键字 关键字 说明 示例 attribute 顶点属性，只会在顶点着色器中出现，不会在片段着色器中出现\n现在已经废弃，而采用in和out attribute aVertexPosition uniform 外部变量，全局统一 uniform uModelViewMatrix varing 可透传到片段着色器的变量，由顶点着色器计算得出 varing highp vec3 vFragPos layout in 该着色器的输入 layout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aTangent; out 该着色器的输出 out type out_variable_name; 二、变量 变量类型 说明 示例 int / float / double / uint / bool 基础类型 vec 向量，默认为float，也可以选择bool、double、uint bvec3 / vec2 mat 矩阵 sampler2D 纹理贴图 gl_Position 顶点着色器中的默认变量 gl_FragColor 片段着色器中的默认变量，可以存在多个，需要用到变种。（一次pass，输出多个结果） 三、函数 函数名 说明 示例 texture2D 贴图采样器 texture2D(uSampler,vTextureCoord).rgb pow 乘方，常用：gama矫正 pow(texture2D(uSampler,vTextureCoord).rgb,vec3(2.2) max 取大值 min 取小值 mix 线性插值/混合 mix(texture(uTexture0, TexCoord.xy),texture(uTexture1, TexCoord.xy),0.8f); 四、常用函数 一、深度打包函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //Fragment vec4 pack (float depth) { // 使用rgba 4字节共32位来存储z值,1个字节精度为1/256 const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0); const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0); // gl_FragCoord:片元的坐标,fract():返回数值的小数部分 vec4 rgbaDepth = fract(depth * bitShift); //计算每个点的z值 rgbaDepth -= rgbaDepth.gbaa * bitMask; // Cut off the value which do not fit in 8 bits return rgbaDepth; } float unpack() { // TODO: 实现解包函数 } void main() { gl_FragColor = pack(gl_FragCoord.z); } HLSL Vertex + Pixel\nGLM库 GLM（OpenGL Mathematics）是一个专门为 OpenGL 设计的 C++ 数学库，它提供了与 GLSL（OpenGL Shading Language）兼容的数学类型和函数。GLM 的设计目标是让 C++ 代码能够方便地使用与着色器相同的数学运算。\n主要特性：\n提供向量（vec2, vec3, vec4）、矩阵（mat3, mat4）等数据类型 支持常见的数学运算（点积、叉积、归一化等） 提供变换函数（平移、旋转、缩放、透视投影等） 与 GLSL 语法高度兼容 STB库 STB 是一个轻量级的单文件 C/C++ 库集合，由 Sean Barrett 开发。它包含了各种常用功能的实现，如图像加载、文本解析、音频处理等。\n一、stb_image 函数 作用 示例 stbi_load() 加载图片 int width, height, nrChannels; unsigned char *data = stbi_load(\u0026ldquo;container.jpg\u0026rdquo;, \u0026amp;width, \u0026amp;height, \u0026amp;nrChannels, 0); ","date":"2026-01-05T00:00:00Z","image":"https://Liyufei1.github.io/guidao5.jpg","permalink":"https://Liyufei1.github.io/p/opengl-learning-notes/","title":"OpenGL学习随笔"},{"content":"Godot 4.4 启动参数完整指南 Godot 引擎提供了丰富的命令行启动参数，允许开发者在运行时和编辑器中精细控制引擎行为。本文基于 Godot 4.4 源码，全面梳理了所有可用的启动参数，并按功能分类进行详细介绍。\n目录 基本参数 运行时参数 编辑器参数 显示与渲染参数 音频参数 调试参数 网络与文件系统参数 平台特定参数 其他工具参数 常用组合示例 注意事项 基本参数 -h, --help, /? 显示帮助信息并退出。这是获取所有可用命令行参数的最快方法。\n1 godot --help 使用场景：\n初次使用 Godot 时了解可用参数 忘记具体参数名称时快速查阅 检查当前 Godot 版本支持的参数列表 --version 显示 Godot 版本信息并退出。\n1 godot --version 使用场景：\n确认当前使用的 Godot 版本 在 CI/CD 环境中验证引擎版本 报告问题时提供版本信息 -v, --verbose 启用详细输出模式，打印更多信息到控制台。包括引擎初始化、资源加载、错误详情等。\n1 godot --verbose 使用场景：\n调试启动问题 查看资源加载过程 分析引擎初始化流程 开发和测试环境中获取更多信息 -q, --quiet 启用安静模式，减少控制台输出。仅显示错误信息，适用于自动化脚本。\n1 godot --quiet 使用场景：\nCI/CD 环境中减少日志噪音 自动化构建脚本 批量处理任务 生产环境部署 --no-header 禁用启动时显示的 Godot 标题头信息，使输出更加简洁。\n1 godot --no-header 使用场景：\n脚本化操作时保持输出整洁 日志分析时减少无关信息 自动化测试环境 运行时参数 --path \u0026lt;path\u0026gt; 指定项目路径。这是最重要的参数之一，告诉 Godot 在哪里找到项目。\n1 godot --path /path/to/project 使用场景：\n从任意目录运行 Godot 项目 在脚本中指定项目位置 CI/CD 管道中的项目路径配置 最佳实践：\n优先使用绝对路径以确保可靠性 在自动化脚本中总是明确指定项目路径 路径应包含 project.godot 文件 -u, --upwards 向上扫描文件夹以查找 project.godot 文件。从当前目录开始递归搜索父目录。\n1 godot --upwards 使用场景：\n在项目子目录中快速运行 Godot 开发环境中的便捷操作 不需要记住完整项目路径的快速启动 最佳实践：\n适用于开发环境，生产环境建议使用 --path 确保项目目录结构清晰，避免多个 project.godot 文件 --main-pack \u0026lt;path\u0026gt; 指定主包文件路径。允许从 PCK 文件运行项目，无需源代码。\n1 godot --main-pack /path/to/main.pck 使用场景：\n运行打包后的游戏 分发游戏而不暴露源代码 模块化项目部署 最佳实践：\n确保 PCK 文件与引擎版本兼容 用于最终产品分发，不用于开发 --quit 在第一个主循环迭代后自动退出。用于快速测试和验证。\n1 godot --quit 使用场景：\n验证项目配置是否正确 快速检查脚本语法错误 CI/CD 中的快速验证步骤 最佳实践：\n结合 --verbose 使用以获取错误信息 用于自动化测试的第一步验证 --quit-after \u0026lt;n\u0026gt; 在指定数量的迭代后退出。允许运行特定帧数后自动退出。\n1 godot --quit-after 100 使用场景：\n性能测试的固定时长 自动化截图或录制 有限时长的测试场景 最佳实践：\n结合 --fixed-fps 使用以获得精确的时间控制 用于自动化测试和性能基准测试 --max-fps \u0026lt;n\u0026gt; 设置最大渲染帧率。0 表示不限制帧率。\n1 godot --max-fps 60 使用场景：\n限制 CPU/GPU 使用率 移动设备省电 保持一致的帧率 性能测试 最佳实践：\n移动平台通常设置为 30 或 60 FPS 桌面平台可以不限制或设置为显示器刷新率 用于性能优化时，逐步降低帧率测试 --fixed-fps \u0026lt;n\u0026gt; 设置固定帧率模式。禁用实时同步，强制固定时间步长。\n1 godot --fixed-fps 30 使用场景：\n物理模拟需要固定时间步长 录制游戏视频时确保一致性 网络同步游戏 调试时间相关问题 最佳实践：\n物理游戏通常使用 60 FPS 的固定帧率 录制视频时根据目标帧率设置 不适用于需要实时响应的游戏 --frame-delay \u0026lt;ms\u0026gt; 设置帧延迟（毫秒）。模拟高 CPU 负载情况。\n1 godot --frame-delay 16 使用场景：\n模拟低端设备性能 测试游戏在慢速环境下的表现 性能压力测试 最佳实践：\n不要用作 FPS 限制器，应使用 --max-fps 用于性能测试和优化验证 典型值为 16ms（60 FPS）或 33ms（30 FPS） --time-scale \u0026lt;scale\u0026gt; 设置时间缩放因子。1.0 为正常速度，更高值更快，更低值更慢。\n1 godot --time-scale 0.5 使用场景：\n慢动作效果测试 快速测试长时间运行的游戏 调试时间相关的游戏机制 性能测试中的时间加速 最佳实践：\n0.5 用于慢动作调试 2.0 或更高用于快速测试 结合 --fixed-fps 获得可重现的结果 --delta-smoothing \u0026lt;mode\u0026gt; 设置增量平滑模式（enable/disable）。控制帧时间平滑以减少抖动。\n1 godot --delta-smoothing enable 使用场景：\n提高动画和物理的平滑度 减少帧率波动的影响 调试时间相关问题 最佳实践：\n默认启用以获得更好的游戏体验 调试时可以禁用以查看原始帧时间 在固定帧率模式下通常不需要 编辑器参数 -e, --editor 启动编辑器模式。\n1 godot --editor -p, --project-manager 启动项目管理器。\n1 godot --project-manager --recovery-mode 启用恢复模式。\n1 godot --recovery-mode --single-window 强制单窗口模式。\n1 godot --single-window --build-solutions 构建脚本解决方案（如 C#）。\n1 godot --build-solutions --import 导入资源并退出。\n1 godot --import --export-release \u0026lt;preset\u0026gt; \u0026lt;path\u0026gt; 发布模式导出项目。\n1 godot --export-release \u0026#34;Windows Desktop\u0026#34; game.exe --export-debug \u0026lt;preset\u0026gt; \u0026lt;path\u0026gt; 调试模式导出项目。\n1 godot --export-debug \u0026#34;Windows Desktop\u0026#34; game_debug.exe --export-pack \u0026lt;preset\u0026gt; \u0026lt;path\u0026gt; 导出为 PCK 包。\n1 godot --export-pack \u0026#34;Windows Desktop\u0026#34; game.pck --export-patch \u0026lt;preset\u0026gt; \u0026lt;path\u0026gt; 导出为补丁包。\n1 godot --export-patch \u0026#34;Windows Desktop\u0026#34; patch.pck 显示与渲染参数 -f, --fullscreen 强制全屏模式。\n1 godot --fullscreen -m, --maximized 强制最大化窗口。\n1 godot --maximized -w, --windowed 强制窗口模式。\n1 godot --windowed --resolution \u0026lt;WxH\u0026gt; 设置窗口分辨率。\n1 godot --resolution 1920x1080 --position \u0026lt;X,Y\u0026gt; 设置窗口位置。\n1 godot --position 100,100 --screen \u0026lt;n\u0026gt; 指定显示器编号。\n1 godot --screen 1 -t, --always-on-top 强制窗口置顶。\n1 godot --always-on-top --display-driver \u0026lt;driver\u0026gt; 指定显示驱动。\n1 godot --display-driver vulkan --rendering-method \u0026lt;method\u0026gt; 指定渲染方法。\n1 godot --rendering-method forward_plus --rendering-driver \u0026lt;driver\u0026gt; 指定渲染驱动。\n1 godot --rendering-driver vulkan --gpu-index \u0026lt;n\u0026gt; 指定 GPU 索引。\n1 godot --gpu-index 0 --gpu-validation 启用 GPU 验证层。\n1 godot --gpu-validation --disable-vsync 禁用垂直同步。\n1 godot --disable-vsync --headless 启用无头模式（无音频、无渲染）。\n1 godot --headless --render-thread \u0026lt;mode\u0026gt; 设置渲染线程模式（safe/separate）。\n1 godot --render-thread safe --xr-mode \u0026lt;mode\u0026gt; 设置 XR 模式（default/off/on）。\n1 godot --xr-mode default 音频参数 --audio-driver \u0026lt;driver\u0026gt; 指定音频驱动。\n1 godot --audio-driver ALSA --audio-output-latency \u0026lt;ms\u0026gt; 设置音频输出延迟。\n1 godot --audio-output-latency 15 调试参数 -d, --debug 启用调试模式。启动本地调试服务器并允许连接调试器。\n1 godot --debug 使用场景：\n本地调试游戏逻辑 脚本调试和错误追踪 开发阶段的实时调试 最佳实践：\n开发阶段始终启用 发布版本中禁用以提高性能 结合 IDE 的调试功能使用 --debug-collisions 启用碰撞调试。在游戏中显示所有碰撞形状的可见轮廓。\n1 godot --debug-collisions 使用场景：\n调试物理碰撞问题 验证碰撞形状设置 优化碰撞检测性能 最佳实践：\n物理游戏开发中经常使用 用于调试不可见的碰撞问题 发布前确保禁用以提高性能 --debug-paths 启用路径调试。显示导航路径和寻路相关的可视化信息。\n1 godot --debug-paths 使用场景：\n调试 AI 寻路问题 验证导航网格设置 优化路径查找算法 最佳实践：\nAI 游戏开发必备工具 用于复杂的导航系统调试 帮助理解路径查找行为 --debug-navigation 启用导航调试。显示导航多边形和导航网格的可视化信息。\n1 godot --debug-navigation 使用场景：\n调试导航网格生成 验证导航区域设置 优化导航系统性能 最佳实践：\n3D 游戏导航系统开发 用于调试复杂的导航场景 帮助识别导航问题 --debug-avoidance 启用避障调试。显示避障算法的可视化信息。\n1 godot --debug-avoidance 使用场景：\n调试 AI 避障行为 验证避障算法效果 优化避障系统性能 最佳实践：\n复杂 AI 系统开发 用于调试群体行为 帮助优化避障参数 --debug-canvas-item-redraw 启用画布项目重绘调试。每次画布项目请求重绘时显示矩形。\n1 godot --debug-canvas-item-redraw 使用场景：\n调试 UI 重绘问题 优化渲染性能 排查过度重绘问题 最佳实践：\nUI 性能优化时使用 用于调试低处理器模式问题 帮助识别不必要的重绘 --debug-stringnames 启用字符串名称调试。在引擎退出时打印所有 StringName 分配信息。\n1 godot --debug-stringnames 使用场景：\n内存使用分析 字符串优化 调试字符串内存泄漏 最佳实践：\n内存优化分析时使用 用于识别字符串性能问题 发布版本中禁用 --remote-debug \u0026lt;uri\u0026gt; 设置远程调试地址。允许通过网络连接调试器。\n1 godot --remote-debug tcp://127.0.0.1:6007 使用场景：\n远程设备调试 移动设备调试 CI/CD 环境中的调试 最佳实践：\n格式：tcp://\u0026lt;host\u0026gt;:\u0026lt;port\u0026gt; 默认端口：6007 确保网络连接和防火墙设置 --profiling 启用性能分析。收集运行时性能数据用于分析。\n1 godot --profiling 使用场景：\n性能瓶颈分析 优化游戏性能 监控资源使用 最佳实践：\n性能优化阶段使用 结合 --verbose 获得详细信息 定期进行性能分析 --profile-gpu 启用 GPU 性能分析。收集 GPU 相关的性能数据。\n1 godot --profile-gpu 使用场景：\nGPU 性能优化 渲染瓶颈分析 着色器性能调试 最佳实践：\n图形密集型游戏必备 用于优化渲染性能 需要支持 GPU 分析的驱动 --print-fps 打印帧率信息到标准输出。实时显示当前帧率。\n1 godot --print-fps 使用场景：\n实时性能监控 帧率稳定性测试 性能回归测试 最佳实践：\n性能测试时使用 用于监控帧率波动 结合 --max-fps 验证限制效果 -b, --breakpoints \u0026lt;list\u0026gt; 设置断点列表。在指定位置设置调试断点。\n1 godot --breakpoints res://script.gd:42,res://other.gd:10 使用场景：\n自动化测试中的断点设置 调试特定代码路径 验证代码执行流程 最佳实践：\n格式：路径:行号，多个断点用逗号分隔 用于自动化调试流程 结合远程调试使用 --skip-breakpoints 跳过所有断点。忽略代码中设置的断点。\n1 godot --skip-breakpoints 使用场景：\n快速运行测试 忽略调试断点 生产环境运行 最佳实践：\nCI/CD 环境中使用 用于快速验证功能 避免意外暂停执行 网络与文件系统参数 --remote-fs \u0026lt;host:port\u0026gt; 设置远程文件系统地址。\n1 godot --remote-fs 192.168.1.100:6010 --remote-fs-password \u0026lt;password\u0026gt; 设置远程文件系统密码。\n1 godot --remote-fs-password mypassword --log-file \u0026lt;path\u0026gt; 指定日志文件路径。\n1 godot --log-file /path/to/godot.log 平台特定参数 --tablet-driver \u0026lt;driver\u0026gt; 指定平板驱动。\n1 godot --tablet-driver wintab --wid \u0026lt;window_id\u0026gt; 嵌入到指定窗口 ID。\n1 godot --wid 123456 --lsp-port \u0026lt;port\u0026gt; 设置 LSP 端口。\n1 godot --lsp-port 8080 --dap-port \u0026lt;port\u0026gt; 设置 DAP 端口。\n1 godot --dap-port 8081 其他工具参数 --doctool 生成文档工具。\n1 godot --doctool --gdscript-docs \u0026lt;path\u0026gt; 生成 GDScript 文档。\n1 godot --gdscript-docs /path/to/project --dump-gdextension-interface 导出 GDExtension 接口头文件。\n1 godot --dump-gdextension-interface --dump-extension-api 导出扩展 API。\n1 godot --dump-extension-api --dump-extension-api-with-docs 导出扩展 API（包含文档）。\n1 godot --dump-extension-api-with-docs --validate-extension-api \u0026lt;file\u0026gt; 验证扩展 API 文件。\n1 godot --validate-extension-api extension_api.json --test-rd-support 测试渲染设备支持。\n1 godot --test-rd-support --test-rd-creation 测试渲染设备创建。\n1 godot --test-rd-creation --write-movie \u0026lt;path\u0026gt; 录制电影到指定路径。\n1 godot --write-movie /path/to/movie.avi --benchmark 启用基准测试模式。\n1 godot --benchmark --benchmark-file \u0026lt;path\u0026gt; 指定基准测试文件路径。\n1 godot --benchmark-file /path/to/benchmark.json --disable-crash-handler 禁用崩溃处理器。\n1 godot --disable-crash-handler --single-threaded-scene 使用单线程场景处理。\n1 godot --single-threaded-scene --disable-render-loop 禁用渲染循环。\n1 godot --disable-render-loop --text-driver \u0026lt;driver\u0026gt; 指定文本驱动。\n1 godot --text-driver \u0026lt;driver_name\u0026gt; --editor-pid \u0026lt;pid\u0026gt; 指定编辑器进程 ID（内部使用）。\n1 godot --editor-pid 1234 --editor-pseudolocalization 启用编辑器伪本地化。\n1 godot --editor-pseudolocalization --generate-spirv-debug-info 生成 SPIR-V 调试信息。\n1 godot --generate-spirv-debug-info --extra-gpu-memory-tracking 启用额外的 GPU 内存跟踪。\n1 godot --extra-gpu-memory-tracking --accurate-breadcrumbs 启用准确的面包屑跟踪。\n1 godot --accurate-breadcrumbs --gpu-abort 在 GPU 错误时中止。\n1 godot --gpu-abort --debug-server \u0026lt;uri\u0026gt; 启动调试服务器。\n1 godot --debug-server tcp://127.0.0.1:6007 --patches \u0026lt;list\u0026gt; 指定补丁列表。\n1 godot --patches patch1.pck,patch2.pck --language \u0026lt;locale\u0026gt; 设置界面语言。\n1 godot --language zh_CN -- 停止解析命令行参数，后续参数将传递给项目。\n1 godot -- --custom-arg value ++ 停止解析命令行参数，后续参数将作为用户参数传递。\n1 godot ++ --user-arg value 常用组合示例 1. 开发调试 1 godot --path /path/to/project --editor --verbose 说明：启动编辑器并启用详细输出，适合日常开发工作。\n使用场景：\n日常游戏开发 新功能开发 问题调试和修复 最佳实践：\n开发阶段始终使用 --verbose 获取更多信息 确保项目路径正确 结合 IDE 的调试功能使用 2. 游戏测试 1 godot --path /path/to/project --debug --remote-debug tcp://127.0.0.1:6007 说明：以调试模式运行游戏并启用远程调试，适合功能测试。\n使用场景：\n游戏功能测试 脚本调试 逻辑验证 最佳实践：\n测试前确保调试服务器配置正确 使用 IDE 连接到调试服务器 测试完成后及时关闭调试模式 3. 性能分析 1 godot --path /path/to/project --profiling --profile-gpu --max-fps 60 说明：启用全面的性能分析，包括 CPU 和 GPU 性能数据收集。\n使用场景：\n性能瓶颈分析 优化前后的性能对比 帧率稳定性测试 最佳实践：\n在一致的环境中进行性能测试 记录测试条件以便结果对比 结合 --quit-after 进行固定时长的测试 4. 无头服务器 1 godot --path /path/to/project --headless --dedicated-server 说明：以无头模式运行专用服务器，适合部署到服务器环境。\n使用场景：\n多人游戏服务器 CI/CD 环境中的自动化测试 云服务器部署 最佳实践：\n确保项目配置支持服务器模式 使用 --log-file 记录服务器日志 配置适当的资源限制和监控 5. 自动导出 1 godot --headless --path /path/to/project --export-release \u0026#34;Windows Desktop\u0026#34; game.exe 说明：以无头模式导出发布版本，适合 CI/CD 管道中的自动构建。\n使用场景：\nCI/CD 自动化构建 批量导出多个平台 定期构建验证 最佳实践：\n始终使用 --headless 避免窗口干扰 确保导出模板已安装 验证导出预设名称的正确性 使用绝对路径避免路径问题 6. 视频录制 1 godot --path /path/to/project --write-movie demo.avi --fixed-fps 60 --quit-after 300 说明：录制游戏视频，固定帧率确保视频质量，限制录制时长。\n使用场景：\n游戏宣传视频制作 演示视频录制 Bug 复现视频 最佳实践：\n使用 --fixed-fps 确保视频帧率一致 使用 --quit-after 控制录制时长 选择适当的视频格式和压缩设置 确保有足够的磁盘空间 7. 基准测试 1 godot --path /path/to/project --benchmark --benchmark-file benchmark.json --max-fps 60 --quit-after 600 说明：进行性能基准测试，结果保存到 JSON 文件便于分析。\n使用场景：\n性能回归测试 不同版本的性能对比 硬件性能评估 最佳实践：\n在一致的测试环境中运行 使用固定帧率确保结果可比性 保存基准测试结果用于历史对比 定期运行以监控性能变化 8. CI/CD 完整构建流水线 1 2 3 4 5 6 7 8 9 10 # 步骤1：验证项目配置 godot --headless --path /path/to/project --quit --verbose # 步骤2：运行测试 godot --headless --path /path/to/project --script tests/run_tests.gd --quit # 步骤3：导出多平台版本 godot --headless --path /path/to/project --export-release \u0026#34;Windows Desktop\u0026#34; builds/game.exe godot --headless --path /path/to/project --export-release \u0026#34;Linux/X11\u0026#34; builds/game.x86_64 godot --headless --path /path/to/project --export-release \u0026#34;macOS\u0026#34; builds/game.zip 说明：完整的 CI/CD 构建流程，包括验证、测试和导出。\n使用场景：\n自动化构建和部署 多平台发布 持续集成验证 最佳实践：\n每个步骤独立验证 使用适当的错误处理 记录构建日志用于问题排查 设置构建通知和报告 注意事项 参数使用原则 参数顺序：某些参数的顺序很重要，特别是路径相关参数。\n--path 应该在其他需要项目上下文的参数之前 --headless 通常放在前面以避免不必要的初始化 场景文件路径应该在最后 平台差异：部分参数仅在特定平台上可用。\nmacOS 需要使用 .app 包内的可执行文件 Windows 和 Linux 可以直接运行二进制文件 移动平台的参数支持有限 版本兼容性：不同版本的 Godot 可能支持不同的参数。\n新版本可能添加新参数或废弃旧参数 某些参数的行为可能在不同版本间有差异 建议查看对应版本的官方文档 性能考虑 性能影响：调试和性能分析参数可能会显著影响运行性能。\n--debug 会降低运行性能，仅用于开发阶段 --profiling 和 --profile-gpu 会增加开销 --verbose 会产生大量输出，影响 I/O 性能 发布版本中禁用所有调试参数 资源管理：某些参数会影响内存和资源使用。\n--extra-gpu-memory-tracking 会增加内存使用 --write-movie 需要大量磁盘空间 --profiling 会收集大量数据 安全考虑 安全考虑：远程调试和文件系统参数在生产环境中应谨慎使用。 --remote-debug 可能暴露安全漏洞 --remote-fs 涉及网络文件系统访问 避免在生产环境启用调试功能 使用防火墙限制调试端口访问 常见问题和解决方案 路径问题：\n使用绝对路径避免相对路径问题 Windows 路径使用反斜杠，Unix 使用正斜杠 确保路径中不包含特殊字符或空格（或使用引号） 权限问题：\n确保对项目目录有读写权限 检查日志文件的写入权限 某些参数可能需要管理员权限 兼容性问题：\n检查 Godot 版本与项目兼容性 确保导出模板版本匹配 验证依赖项和插件兼容性 环境配置：\n确保系统环境变量正确设置 检查图形驱动程序兼容性 验证音频驱动可用性 最佳实践总结 开发环境：\n使用 --verbose 获取详细信息 启用适当的调试参数 使用版本控制管理项目 测试环境：\n模拟目标环境配置 使用自动化测试脚本 记录测试结果和性能数据 生产环境：\n禁用所有调试参数 使用 --quiet 减少日志输出 配置适当的日志轮转 CI/CD 环境：\n始终使用 --headless 配置适当的超时时间 使用明确的错误处理 性能优化：\n定期进行性能分析 监控资源使用情况 建立性能基准线 源码解析 以下是 Godot 4.4 源码中关键启动参数的处理逻辑精简版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 Error Main::setup(const char *execpath, int argc, char *argv[], bool p_second_phase) { // ... // 命令行参数解析循环 while (I) { List\u0026lt;String\u0026gt;::Element *N = I-\u0026gt;next(); const String \u0026amp;arg = I-\u0026gt;get(); // 1. --help 参数处理 if (arg == \u0026#34;-h\u0026#34; || arg == \u0026#34;--help\u0026#34; || arg == \u0026#34;/?\u0026#34;) { show_help = true; exit_err = ERR_HELP; // 强制早期退出，返回成功代码 goto error; } // 2. --remote-debug 参数处理 else if (arg == \u0026#34;--remote-debug\u0026#34;) { if (N) { debug_uri = N-\u0026gt;get(); if (!debug_uri.contains(\u0026#34;://\u0026#34;)) { // 验证地址格式 OS::get_singleton()-\u0026gt;print( \u0026#34;Invalid debug host address, it should be of the form \u0026lt;protocol\u0026gt;://\u0026lt;host/IP\u0026gt;:\u0026lt;port\u0026gt;.\\n\u0026#34;); goto error; } N = N-\u0026gt;next(); } else { OS::get_singleton()-\u0026gt;print(\u0026#34;Missing remote debug host address, aborting.\\n\u0026#34;); goto error; } } // 3. --max-fps 参数处理 else if (arg == \u0026#34;--max-fps\u0026#34;) { if (N) { max_fps = N-\u0026gt;get().to_int(); N = N-\u0026gt;next(); } else { OS::get_singleton()-\u0026gt;print(\u0026#34;Missing maximum FPS argument, aborting.\\n\u0026#34;); goto error; } } // 4. --time-scale 参数处理 以及实现 else if (arg == \u0026#34;--time-scale\u0026#34;) { if (N) { // 设置时间缩放 Engine::get_singleton()-\u0026gt;set_time_scale(N-\u0026gt;get().to_float()); N = N-\u0026gt;next(); } else { OS::get_singleton()-\u0026gt;print(\u0026#34;Missing time scale argument, aborting.\\n\u0026#34;); goto error; } } I = N; //1. --help 的实现 if (show_help) { print_help(execpath); } // 2. --remote-debug 的实现 EngineDebugger::initialize(debug_uri, skip_breakpoints, breakpoints, []() { if (editor_pid) { DisplayServer::get_singleton()-\u0026gt;enable_for_stealing_focus(editor_pid); } }); // 3. --max-fps 的实现 Engine::get_singleton()-\u0026gt;set_max_fps(GLOBAL_DEF(PropertyInfo(Variant::INT, \u0026#34;application/run/max_fps\u0026#34;, PROPERTY_HINT_RANGE, \u0026#34;0,1000,1\u0026#34;), 0)); if (max_fps \u0026gt;= 0) { Engine::get_singleton()-\u0026gt;set_max_fps(max_fps); } } } 总结 Godot 4.4 的启动参数提供了对引擎各个方面的精细控制，从基本的运行模式到高级的调试和性能分析功能。合理使用这些参数可以大大提高开发效率和调试能力。在实际开发中，建议根据具体需求选择合适的参数组合，并注意参数之间的相互影响。\n","date":"2025-12-20T09:18:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E4%B8%83godot%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/","title":"【godot】七、godot的启动参数"},{"content":"iFlow CLI 使用和部署完整教程 iFlow初步认识 iFlow CLI 是一款直接在终端中运行的强大 AI 助手。它能够无缝分析代码仓库、执行编程任务、理解上下文需求，通过自动化处理从简单的文件操作到复杂的工作流程，全面提升您的工作效率。\n核心特性 免费 AI 模型：通过 心流开放平台 访问强大的免费 AI 模型，包括 Kimi K2、Qwen3 Coder、DeepSeek v3 等 灵活集成：保留你喜欢的开发工具，也可集成到现有系统实现自动化 自然语言交互：告别复杂命令，用日常对话驱动 AI，从代码开发到生活助理 开放平台：从心流开放市场中可以一键安装SubAgent和MCP，快速扩展智能体，组建只属于你的AI团队 核心功能 支持4种运行模式：yolo模式（模型拥有最大权限，可执行任何操作）、接受编辑模式（模型仅拥有文件修改权限）、计划模式（先计划后执行）、默认模式（模型无权限） 升级subAgent功能：将CLI从通用助手转变为专家团队，提供更专业准确的建议。使用 /agent 查看更多预配置代理 升级task工具：有效压缩上下文长度，让CLI更彻底地完成您的任务。当上下文达到70%时自动压缩 集成心流开放市场：快速安装有用的MCP工具、Subagents和自定义指令。使用 /mcp 了解更多 免费多模态模型使用：现在您也可以在CLI中粘贴图片了（Ctrl+V粘贴图片） 支持对话历史保存和回滚（iflow \u0026ndash;resume 和 /chat 命令） 支持更多有用的终端命令（iflow -h 查看更多命令） VSCode插件支持 自动升级：iFlow CLI自动检测当前版本是否为最新版本 更多使用教程请访问：iFlow平台\nWindows平台的安装部署 系统要求 操作系统：Windows 10+（使用 WSL 1、WSL 2 或 Git for Windows） 硬件：4GB+ 内存 软件：Node.js 22+ 网络：需要互联网连接用于身份验证和 AI 处理 Shell：在 Bash、Zsh 或 Fish 中效果最佳 安装步骤 方法一：标准安装 访问 Node.js官网 下载最新的 Node.js 安装程序 运行安装程序来安装 Node.js 重启终端：CMD 或 PowerShell 运行 npm install -g @iflow-ai/iflow-cli 来安装 iFlow CLI 运行 iflow 来启动 iFlow CLI 方法二：中国大陆用户专用安装（推荐） 如果您在中国大陆，可以使用以下命令安装 iFlow CLI：\n访问 iFlow CLI nvm安装包 下载最新的 nvm 安装程序 运行安装程序来安装 nvm 重启终端：CMD 或 PowerShell 运行 nvm node_mirror https://npmmirror.com/mirrors/node/ 和 nvm npm_mirror https://npmmirror.com/mirrors/npm/ 运行 nvm install 22 来安装 Node.js 22，稍等片刻 运行 nvm use 22 来使用 Node.js 22 运行 npm install -g @iflow-ai/iflow-cli 来安装 iFlow CLI 运行 iflow 来启动 iFlow CLI 验证安装 安装完成后，可以在终端中运行以下命令验证是否安装成功：\n1 iflow --version 如果显示版本号，则表示安装成功。\n登录和使用 iFlow CLI提供两种身份验证方式：\n推荐方式：使用 iFlow 原生身份验证 备选方式：通过 OpenAI 兼容 API 连接 获取 API Key 获取 API Key的步骤：\n注册 iFlow 账户 进入个人设置页面或点击此直达链接 在弹出对话框中点击\u0026quot;重置\u0026quot;生成新的 API 密钥 生成密钥后，将其粘贴到终端提示符中即可完成设置。注意：在 Windows 的 CMD 或者 PowerShell 中，请点击右键进行粘贴。\n快速开始 要启动 iFlow CLI，请在终端中导航到您的工作空间并输入：\n1 iflow 创建新项目 对于新项目，只需描述您想要创建的内容：\n1 2 3 cd new-project/ iflow \u0026gt; 使用 HTML 创建一个基于网页的我的世界游戏 处理现有项目 对于现有代码库，建议先使用 /init 命令帮助 iFlow 理解您的项目：\n1 2 3 4 cd project1/ iflow \u0026gt; /init \u0026gt; 根据 requirement.md 文件中的 PRD 文档分析需求，输出技术文档，然后实现解决方案。 /init 命令会扫描您的代码库，学习其结构，并创建包含完整文档的 IFLOW.md 文件。\n有关斜杠命令的完整列表和使用说明，请查看iFlow命令文档。\n卸载 如果需要卸载 iFlow CLI，可以使用以下命令：\n1 npm uninstall -g @iflow-ai/iflow-cli 此命令将完全移除 iFlow CLI 及其相关文件。\n额外清理 如果需要彻底清理所有相关配置文件，可以删除以下目录：\nWindows: C:\\Users\\{用户名}\\.iflow 配置文件: ~/.iflow/settings.json iFlow中的\u0026rsquo;/\u0026lsquo;命令和使用示例 iFlow CLI 提供了丰富的斜杠命令（Slash Commands），这些命令可以帮助用户更高效地控制和使用AI助手。斜杠命令以 / 开头，可以快速执行特定功能。\n常用斜杠命令 命令 功能描述 使用示例 适用场景 /help 或 /? 显示所有可用的斜杠命令列表和帮助信息 \u0026gt; /help 需要查看所有可用命令时 /init 分析当前项目结构，扫描代码库并生成IFLOW.md文档，帮助iFlow更好地理解您的项目 \u0026gt; /init\n\u0026gt; 正在分析项目结构... 项目初始化时 /chat 管理对话历史，查看之前的对话记录或切换到不同的对话 \u0026gt; /chat list # 列出所有对话\n\u0026gt; /chat resume # 恢复之前的对话 管理对话历史时 /agent 使用预配置的专家代理（subagent）来处理特定领域的任务 \u0026gt; /agent # 查看可用的代理\n\u0026gt; /agent code # 使用代码专家代理 需要专业领域帮助时 /mcp 访问心流开放市场中的MCP（Model Context Protocol）工具，扩展iFlow的功能 \u0026gt; /mcp # 查看可用的MCP工具\n\u0026gt; /mcp install # 安装MCP工具 扩展功能时 /task 使用任务管理工具，将复杂任务分解为可管理的子任务 \u0026gt; /task create # 创建任务列表\n\u0026gt; /task list # 查看任务进度 处理复杂任务时 /plan 进入计划模式，先制定详细计划再执行任务，确保执行过程更加可控 \u0026gt; /plan # 进入计划模式 需要先制定计划再执行时 /yolo 进入YOLO（You Only Live Once）模式，赋予AI模型最大权限，可执行任何操作 \u0026gt; /yolo # 进入YOLO模式（谨慎使用） 需要AI完全自主操作时 /accept 进入接受编辑模式，AI模型仅拥有文件修改权限，更安全 \u0026gt; /accept # 进入接受编辑模式 需要更安全的操作模式时 /compact 压缩对话上下文，减少内存占用，提高响应速度 \u0026gt; /compact # 压缩对话历史 对话历史过长时 /search 执行网络搜索任务，获取实时信息 \u0026gt; /search # 执行搜索 需要获取实时信息时 实际应用场景示例 场景 命令示例 项目初始化 \u0026gt; /init\n\u0026gt; 分析项目结构后，生成文档并提供优化建议。 代码审查 \u0026gt; /agent code\n\u0026gt; 审查当前目录下的所有代码文件，找出潜在问题。 任务分解 \u0026gt; /task create\n\u0026gt; 请帮我实现用户注册功能，包含前端表单、后端接口和数据库设计 高级权限操作 \u0026gt; /yolo\n\u0026gt; 创建新项目目录，安装依赖，生成基本代码结构 这些斜杠命令极大地增强了iFlow CLI的功能性，让您可以更精确地控制AI助手的行为，提高开发效率。有关斜杠命令的完整列表和最新功能，请查看iFlow命令文档。\n结语 iFlow CLI 是一个强大的开发助手，通过本教程，您应该已经掌握了如何在 Windows 平台上安装、登录使用和卸载 iFlow CLI。更多高级功能和使用技巧，请访问官方文档：iFlow CLI GitHub仓库\n如需加入社区交流，可以扫描官方微信群二维码：iFlow微信社区\n","date":"2025-12-09T10:00:00+08:00","image":"https://Liyufei1.github.io/guidao5.jpg","permalink":"https://Liyufei1.github.io/p/iflow-cli-%E4%BD%BF%E7%94%A8%E5%92%8C%E9%83%A8%E7%BD%B2%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/","title":"iFlow CLI 使用和部署完整教程"},{"content":"概述 对于追求极客精神的小伙伴而言，对godot编辑器的改造无疑是一件非常酷的事情。它可以为godot编辑器添加一些定制化的操作，用于提升开发效率，加速工程实现。对于泛用的编辑器功能或是自定义功能类的调式补充界面，做成编辑器插件是非常不错的，比如：批量的实体放置、批量的材质复制、曲线的debug绘制等。 需要实现一个自定义的编辑器插件，会涉及到下方几个类：\nEditorNode:Godot编辑器的核心控制类,管理所有编辑器面板/场景编辑器/文件浏览器/脚本编辑器/编辑器插件等,EditorPlugin、Node3DEditor、CanvasItemEditor 和EditorDockManager都集成在它的里面. EditorPlugin：Godot内置的插件基类，提供了与编辑器进行交互的接口。 Node3DEditor：Godot内置3D场景编辑器的核心插件，它是3D场景的编辑界面的主体，包括了：3D物体的齐次线性变换、工具栏、Gizmo、网格等等。 CanvasItemEditor：Godot内置2D场景编辑器的核心插件，它是2D场景的编辑界面的主体，包括了：2D物体的变换、工具栏等等。 EditorDockManager: EditorPlugin EditorPlugin是Godot编辑器插件系统的核心类，也是我们开发插件的起点。\n👉初始化 1 2 3 4 5 6 7 //在register_editor_types.cpp中注册插件 EditorPlugins::add_by_type\u0026lt;LyfTestEditorPlugin\u0026gt;(); //在EditorData的构造阶段,实际创建并收集插件 for (int i = 0; i \u0026lt; EditorPlugins::get_plugin_count(); i++) { add_editor_plugin(EditorPlugins::create(i)); } 👉扩展 Godot 编辑器 我们可以可以添加工具面板、菜单按钮、自定义检查器、操作2D/3D编辑器(Node3DEditor/CanvasItemEditor)等。\nEditorPluginUI拓展的实现,依赖实际的工作类，比如：Node3DEditor、CanvasItemEditor、EditorDockManager。它只是对工作类的接口进行封装。\n接口 作用 add_control_to_container 添加控件到指定位置 add_control_to_bottom_panel 编辑器底部面板添加一个新的工具选项卡 add_control_to_dock 编辑器添加一个可停靠的自定义面板 add_tool_menu_item 在工具栏添加一个菜单项 add_control_to_container add_control_to_container存在多个停靠位置:\nCONTAINER_TOOLBAR : 上方工具栏, CONTAINER_SPATIAL_EDITOR_MENU : 3D视口上方菜单栏 CONTAINER_SPATIAL_EDITOR_SIDE_LEFT : 3D视口左方 CONTAINER_SPATIAL_EDITOR_SIDE_RIGHT : 3D视口右方 CONTAINER_SPATIAL_EDITOR_BOTTOM : 3D视口下方 CONTAINER_CANVAS_EDITOR_MENU : 2D视口上方菜单栏 CONTAINER_CANVAS_EDITOR_SIDE_LEFT : 2D视口左方 CONTAINER_CANVAS_EDITOR_SIDE_RIGHT : 2D视口右方 CONTAINER_CANVAS_EDITOR_BOTTOM : 2D视口下方 CONTAINER_INSPECTOR_BOTTOM : 检查器下方 CONTAINER_PROJECT_SETTING_TAB_LEFT : 项目设置左侧 CONTAINER_PROJECT_SETTING_TAB_RIGHT : 项目设置右侧 add_control_to_bottom_panel add_control_to_dock add_tool_menu_item 👉处理用户选中的对象 编辑器每次选中对象时都会调用：bool EditorPlugin::handles(Object *p_object)判断当前选中的对象是否应该被插件处理。\n当插件决定“接管某对象”时，会触发对象进入/退出编辑模式：\nvoid EditorPlugin::make_visible(bool p_visible); 进入时，p_visible为true； 退出时：p_visible为false void EditorPlugin::edit(Object *p_object) 进入时：p_object为选中的对象； 退出时：p_object为nullptr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //EditorPlugin子类的基本样式 class LyfTestEditorPlugin : public EditorPlugin { GDCLASS(LyfTestEditorPlugin, EditorPlugin); // MeshInstance3DEditor *mesh_editor = nullptr; public: virtual String get_plugin_name() const override { return \u0026#34;LyfTestEditorPlugin\u0026#34;; } bool has_main_screen() const override { return false; } virtual bool handles(Object *p_object) const override; virtual void make_visible(bool p_visible) override; virtual void edit(Object *p_object) override; LyfTestEditorPlugin(); ~LyfTestEditorPlugin(); }; 👉添加特定的编辑器插件 godot还封装了一系列具有完整功能的编辑器插件:\nEditorTranslationParserPlugin：用于解析翻译文件，比如：.pot文件。 EditorImportPlugin: 资源导入插件，比如：自定义.fbx文件导入。 EditorNode3DGizmoPlugin: 用来在3D视图里为某些Node3D类型绘制自定义gizmo（操作手柄/可视辅助） EditorInspectorPlugin: 检查器属性编辑插件 1 2 3 4 5 6 7 8 9 10 11 12 void add_translation_parser_plugin(const Ref\u0026lt;EditorTranslationParserPlugin\u0026gt; \u0026amp;p_parser); void add_import_plugin(const Ref\u0026lt;EditorImportPlugin\u0026gt; \u0026amp;p_importer, bool p_first_priority = false); void add_export_plugin(const Ref\u0026lt;EditorExportPlugin\u0026gt; \u0026amp;p_exporter); void add_export_platform(const Ref\u0026lt;EditorExportPlatform\u0026gt; \u0026amp;p_platform); void add_node_3d_gizmo_plugin(const Ref\u0026lt;EditorNode3DGizmoPlugin\u0026gt; \u0026amp;p_gizmo_plugin); void add_inspector_plugin(const Ref\u0026lt;EditorInspectorPlugin\u0026gt; \u0026amp;p_plugin); void add_scene_format_importer_plugin(const Ref\u0026lt;EditorSceneFormatImporter\u0026gt; \u0026amp;p_importer, bool p_first_priority = false); void add_scene_post_import_plugin(const Ref\u0026lt;EditorScenePostImportPlugin\u0026gt; \u0026amp;p_importer, bool p_first_priority = false); void add_autoload_singleton(const String \u0026amp;p_name, const String \u0026amp;p_path); void add_debugger_plugin(const Ref\u0026lt;EditorDebuggerPlugin\u0026gt; \u0026amp;p_plugin); void add_resource_conversion_plugin(const Ref\u0026lt;EditorResourceConversionPlugin\u0026gt; \u0026amp;p_plugin); void add_context_menu_plugin(EditorContextMenuPlugin::ContextMenuSlot p_slot, const Ref\u0026lt;EditorContextMenuPlugin\u0026gt; \u0026amp;p_plugin); Node3DEditor Node3DEditor是Godot内置3D场景编辑器的核心插件，它是3D场景的编辑界面的主体，包括了：视口、工具栏、Gizmo、网格等等。\n✔️初始化 1 2 //在EditorNode的构造阶段,创建并注册 add_editor_plugin(memnew(Node3DEditorPlugin)); ✔️UI扩展：往3D界面编辑器的上下左右添加控件 接口 作用 add_control_to_menu_panel 在上方菜单栏添加控件 add_control_to_left_panel 在视口左侧添加控件 add_control_to_right_panel 在视口右侧添加控件 get_shader_split 获取视口底部的容器盒 1 2 3 4 5 6 7 8 9 10 11 12 //使用示例 //在上方菜单栏添加控件 Node3DEditor::get_singleton()-\u0026gt;add_control_to_menu_panel(p_control); //在视口左侧添加控件 Node3DEditor::get_singleton()-\u0026gt;add_control_to_left_panel(p_control); //在视口右侧添加控件 Node3DEditor::get_singleton()-\u0026gt;add_control_to_right_panel(p_control); //在视口底部添加控件 Node3DEditor::get_singleton()-\u0026gt;get_shader_split()-\u0026gt;add_child(p_control); Gizmo扩展：添加自定义Gizmo CanvasItemEditor CanvasItemEditor是Godot内置2D编辑器的核心插件，它是2D场景的编辑界面的主体。\nUI扩展：往2D界面编辑器的上下左右添加控件 接口 作用 add_control_to_menu_panel 在上方菜单栏添加控件 add_control_to_left_panel 在视口左侧添加控件 add_control_to_right_panel 在视口右侧添加控件 get_bottom_split 获取视口底部的容器盒 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //使用示例 case CONTAINER_CANVAS_EDITOR_MENU: { //在上方菜单栏添加控件 CanvasItemEditor::get_singleton()-\u0026gt;add_control_to_menu_panel(p_control); } break; case CONTAINER_CANVAS_EDITOR_SIDE_LEFT: { //在视口左侧添加控件 CanvasItemEditor::get_singleton()-\u0026gt;add_control_to_left_panel(p_control); } break; case CONTAINER_CANVAS_EDITOR_SIDE_RIGHT: { //在视口右侧添加控件 CanvasItemEditor::get_singleton()-\u0026gt;add_control_to_right_panel(p_control); } break; case CONTAINER_CANVAS_EDITOR_BOTTOM: { //在视口底部添加控件 CanvasItemEditor::get_singleton()-\u0026gt;get_bottom_split()-\u0026gt;add_child(p_control); } break; ","date":"2025-11-20T09:18:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E5%85%ADgodot%E4%B8%AD%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%E6%8F%92%E4%BB%B6editorplugin/","title":"【godot】六、godot中的编辑器插件EditorPlugin"},{"content":"概述 在游戏开发中，动态性和灵活性是至关重要的特性。python，C#，java等编程语言，从语音层面就是支持反射或动态类型系统的，可以运行时动态地查看对象的类型、成员、方法，甚至动态调用或修改它们。而游戏引擎为了追求运行时的效率，一般会采用Cpp语言进行开发，Cpp语言本身不支持反射，所以各大游戏引擎都各显神通地添加了反射系统，以支持运行时动态类型信息。\n在虚幻引擎当中，是通过UObject类来收集元信息的。通过UPROPTERTY()等宏标记，用UHT工具，在编译前进行一次头文件的生成，从而生成UPROPERTY()所标记的属性元信息的U类。对于虚幻的反射实现感兴趣的朋友，可以参考大钊在知乎上的文章：虚幻引擎的元信息机制 在Unity中，反射系统由C#提供的。 在godot中，反射系统则是由名为ClassDB提供，它记录了所有派生自Object类的类型信息。在业务代码层，我们可以通过它提供的一系列静态方法来运行时访问类的类型信息，比如获取类的成员变量、方法、属性等信息。 ClassDB介绍 对于godot来说ClassDB是一个全局类信息库，可以对所有注册类的元数据进行访问。\nClassDB利用静态成员变量来存储类的元数据，比如类的继承关系、成员变量、方法、属性等信息。 ClassDB提供了一系列的静态成员函数给用户来进行元数据查询。 因此ClassDB并没有实例化的需求。 下方截取了4.4版本godot源码中ClassDB类的部分代码，并标注了一些重要的信息，帮助我们去整体的理解ClassDB的运行原理。为了方便理解，方法和属性的顺序，并非与源码严格一致。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class ClassDB { public: //... //读写锁，防止多线程问题 static RWLock lock; //所有注册的类信息 static HashMap\u0026lt;StringName, ClassInfo\u0026gt; classes; // static HashMap\u0026lt;StringName, StringName\u0026gt; resource_base_extensions; static HashMap\u0026lt;StringName, StringName\u0026gt; compat_classes; //... public: //... //查询所有类的名称列表 static void get_class_list(List\u0026lt;StringName\u0026gt; *p_classes); //查询所有GDExtension的类名称列表 static void get_extensions_class_list(List\u0026lt;StringName\u0026gt; *p_classes); //按照名称查询类是否存在 static bool class_exists(const StringName \u0026amp;p_class); //信号接口 static void add_signal(const StringName \u0026amp;p_class, const MethodInfo \u0026amp;p_signal); static bool has_signal(const StringName \u0026amp;p_class, const StringName \u0026amp;p_signal, bool p_no_inheritance = false); static bool get_signal(const StringName \u0026amp;p_class, const StringName \u0026amp;p_signal, MethodInfo *r_signal); static void get_signal_list(const StringName \u0026amp;p_class, List\u0026lt;MethodInfo\u0026gt; *p_signals, bool p_no_inheritance = false); }; 类的查询接口 在理解ClassDB中的静态成员变量static HashMap\u0026lt;StringName, ClassInfo\u0026gt; classes;存储了所有的类信息后，下方两个查询的接口，就非常好理解了。\n接口 作用 一般接口 get_class_list 查询所有类名称 class_exists 查询类是否存在 instantiate 调用实例化函数，并发送通知 向下查询 get_inheriters_from_class 查询所有继承类 get_direct_inheriters_from_class 查询所有继承类(不包含自身) 向上查询 get_parent_class 查询父类 get_parent_class_nocheck 查询父类名称，不做报错 get_inheritance_chain_nocheck 查询继承链 is_parent_class 查询A是否继承自B(包括同一类) 一般接口 get_class_list ：：所有类名称查询，返回一个列表，列表中的元素是所有类的名称。 1 2 3 4 5 6 7 8 9 10 11 12 void ClassDB::get_class_list(List\u0026lt;StringName\u0026gt; *p_classes) { //创建读锁，godot定义的宏，可以不关注它的实现细节 OBJTYPE_RLOCK; //遍历存放所有类信息的HashMap：classes，拿到它的键值，也就是类名，添加进输出列表 for (const KeyValue\u0026lt;StringName, ClassInfo\u0026gt; \u0026amp;E : classes) { p_classes-\u0026gt;push_back(E.key); } //对 p_classes 列表中的所有类名（StringName）按照字母顺序进行排序。 p_classes-\u0026gt;sort_custom\u0026lt;StringName::AlphCompare\u0026gt;(); } class_exists ：：查询类是否存在，返回布尔值。 1 2 3 4 5 6 bool ClassDB::class_exists(const StringName \u0026amp;p_class) { //创建读锁 OBJTYPE_RLOCK; //根据键值查询哈希表 return classes.has(p_class); } 向下查询 get_inheriters_from_class ：： 查询所有继承自指定类的类名称列表。 get_direct_inheriters_from_class ：：查询所有继承自指定类的类名称列表，过滤掉了传入的类本身 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void ClassDB::get_inheriters_from_class(const StringName \u0026amp;p_class, List\u0026lt;StringName\u0026gt; *p_classes) { //锁上读锁 OBJTYPE_RLOCK; //遍历存放所有类信息，如果E为继承自p_class的类，则添加进输出列表 for (const KeyValue\u0026lt;StringName, ClassInfo\u0026gt; \u0026amp;E : classes) { if (E.key != p_class \u0026amp;\u0026amp; _is_parent_class(E.key, p_class)) { p_classes-\u0026gt;push_back(E.key); } } } void ClassDB::get_direct_inheriters_from_class(const StringName \u0026amp;p_class, List\u0026lt;StringName\u0026gt; *p_classes) { //锁上读锁 OBJTYPE_RLOCK; //同上，但是过滤掉了自身 for (const KeyValue\u0026lt;StringName, ClassInfo\u0026gt; \u0026amp;E : classes) { if (E.key != p_class \u0026amp;\u0026amp; _get_parent_class(E.key) == p_class) { p_classes-\u0026gt;push_back(E.key); } } } 向上查询 get_parent_class ：：查询指定类的父类名称 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 StringName ClassDB::get_parent_class(const StringName \u0026amp;p_class) { //锁上读锁 OBJTYPE_RLOCK; //调用实际执行函数 return _get_parent_class(p_class); } StringName ClassDB::_get_parent_class(const StringName \u0026amp;p_class) { ClassInfo *ti = classes.getptr(p_class); //非空判断，为空时报错并返回空字符串 ERR_FAIL_NULL_V_MSG(ti, StringName(), vformat(\u0026#34;Cannot get class \u0026#39;%s\u0026#39;.\u0026#34;, String(p_class))); //返回父类名称 return ti-\u0026gt;inherits; } get_parent_class_nocheck ：：查询指定类的父类名称，不做报错 1 2 3 4 5 6 7 8 9 10 11 12 13 StringName ClassDB::get_parent_class_nocheck(const StringName \u0026amp;p_class) { //锁上读锁 OBJTYPE_RLOCK; //非空判断 ClassInfo *ti = classes.getptr(p_class); if (!ti) { return StringName(); } //返回父类名称 return ti-\u0026gt;inherits; } get_inheritance_chain_nocheck：：查询继承链 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 bool ClassDB::get_inheritance_chain_nocheck(const StringName \u0026amp;p_class, Vector\u0026lt;StringName\u0026gt; \u0026amp;r_result) { //锁上读锁 OBJTYPE_RLOCK; //非空判断 ClassInfo *start = classes.getptr(p_class); if (!start) { return false; } //向上查询，直至父类指针为空 int classes_to_add = 0; for (ClassInfo *ti = start; ti; ti = ti-\u0026gt;inherits_ptr) { classes_to_add++; } //扩容r_result列表，并将父类名列表称添加进列表 //不用push_back，因为push_back会动态扩容，性能表现更差，而resize不会 int64_t old_size = r_result.size(); r_result.resize(old_size + classes_to_add); StringName *w = r_result.ptrw() + old_size; for (ClassInfo *ti = start; ti; ti = ti-\u0026gt;inherits_ptr) { *w++ = ti-\u0026gt;name; } return true; } 信号接口 信号相关的信息，存储在ClassInfo的signal_map当中\n接口 作用 add_signal 为某个类添加一个 信号，普遍使用它的宏ADD_SIGNAL版本 has_signal 检查类是否（含父类）定义了某个信号 get_signal 返回 class 或其祖先的信号数据。 get_signal_list 获取所有信号（可包括父类） 基本使用示例： godot中的signal类似于ue中的动态多播代理。它可以将一个信号（可以带参数）发送到所有监听函数。\n信号的创建一般放在_bind_methods中 监听信号的绑定，则需要结合实际的监听者（Object*），因此不会在静态函数_bind_methods中绑定。 信号的发送，也需要结合实际的发送者。 注意，由于信号功能的实现，依赖了Object内的方法，所以相关的函数需要被注册进类型信息当中，否则Object无法通过call动态的调用绑定的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //信号创建 void MyNode::_bind_methods() { //定义信号的属性 MethodInfo mi(\u0026#34;TestSignal\u0026#34;); //信号名称为TestSignal mi._push_params(PropertyInfo(Variant::INT,\u0026#34;Arg1\u0026#34;)); //具有一个类型为int的参数Arg1 ClassDB::add_signal(\u0026#34;NsTestResource\u0026#34;, mi);\t//添加信号 //宏的实现版本 //信号名称为TestSignal，信号具有一个参数，类型为int ADD_SIGNAL(MethodInfo(\u0026#34;NsTestResource\u0026#34;, PropertyInfo(Variant::INT, \u0026#34;TestSignal\u0026#34;)));\t} //定义被调用函数 void NsTestResource::test_func_for_signal(int AAA){ print_line(\u0026#34;test_func_for_signal::\u0026#34;,AAA); } //绑定信号 void NsTestResource::test_func_for_connect(){ connect(\u0026#34;TestSignal\u0026#34;, Callable(this,\u0026#34;test_func_for_signal\u0026#34;)); } //发射信号 void NsTestResource::test_func_for_emit(int AAA){ emit_signal(\u0026#34;TestSignal\u0026#34;, 2); } add_signal 为某个类添加一个信号,MethodInfo参考链接\n方法签名\n1 2 3 4 void ClassDB::add_signal( const StringName \u0026amp;p_class, //类名 const MethodInfo \u0026amp;p_signal\t//信号信息 ); 常用的宏定义\n1 #define ADD_SIGNAL(m_signal) ::ClassDB::add_signal(get_class_static(), m_signal) 使用示例\n1 2 3 4 5 6 7 8 9 10 void MyNode::_bind_methods() { //定义信号的属性 MethodInfo mi(\u0026#34;TestSignal\u0026#34;); //信号名称为TestSignal mi._push_params(PropertyInfo(Variant::INT,\u0026#34;Arg1\u0026#34;)); //具有一个类型为int的参数Arg1 ClassDB::add_signal(\u0026#34;NsTestResource\u0026#34;, mi);\t//添加信号 //宏的实现版本 //信号名称为TestSignal，信号具有一个参数，类型为int ADD_SIGNAL(MethodInfo(\u0026#34;NsTestResource\u0026#34;, PropertyInfo(Variant::INT, \u0026#34;TestSignal\u0026#34;)));\t} 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void ClassDB::add_signal(const StringName \u0026amp;p_class, const MethodInfo \u0026amp;p_signal) { //锁上写锁 OBJTYPE_WLOCK; //类信息非空判断 ClassInfo *type = classes.getptr(p_class); ERR_FAIL_NULL(type); //获取信号名称 StringName sname = p_signal.name; //同名信号报错 #ifdef DEBUG_METHODS_ENABLED ClassInfo *check = type; while (check) { ERR_FAIL_COND_MSG(check-\u0026gt;signal_map.has(sname), vformat(\u0026#34;Class \u0026#39;%s\u0026#39; already has signal \u0026#39;%s\u0026#39;.\u0026#34;, String(p_class), String(sname))); check = check-\u0026gt;inherits_ptr; } #endif //signal_map中添加信号 type-\u0026gt;signal_map[sname] = p_signal; } has_signal 检查某个类是否定义过某个信号\n方法签名\n1 2 3 4 5 bool ClassDB::has_signal( const StringName \u0026amp;p_class, //类名 const StringName \u0026amp;p_signal, //信号名 bool p_no_inheritance //是否忽略继承关系 ); 使用示例\n1 2 3 4 void testfun(){ bool exists = ClassDB::has_signal(\u0026#34;Node\u0026#34;, \u0026#34;tree_entered\u0026#34;); print_line(vformat(\u0026#34;Has signal? %s\u0026#34;, exists)); } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool ClassDB::has_signal(const StringName \u0026amp;p_class, const StringName \u0026amp;p_signal, bool p_no_inheritance) { //锁上读锁 OBJTYPE_RLOCK; //类信息非空判断 ClassInfo *type = classes.getptr(p_class); ClassInfo *check = type; //向上逐级查询classinfo，直到object类， while (check) { if (check-\u0026gt;signal_map.has(p_signal)) { return true; } //无需向上查询，则返回false if (p_no_inheritance) { return false; } check = check-\u0026gt;inherits_ptr; } return false; } get_signal 获取信号的完整信息存入MethodInfo，如果信号存在返回true 并填充p_signal\nMethodInfo链接\n方法签名\n1 2 3 4 5 bool ClassDB::get_signal( const StringName \u0026amp;p_class, // 类名 const StringName \u0026amp;p_signal, // 信号名 MethodInfo *r_signal // 存储信号的MethodInfo )； 使用示例\n1 2 3 4 5 6 7 8 9 10 void testfun(){ MethodInfo info; if (ClassDB::get_signal(\u0026#34;MyNode\u0026#34;, \u0026#34;hit\u0026#34;, \u0026amp;info)) { print_line(\u0026#34;Signal name: \u0026#34; + info.name); for (auto arg : info.arguments) { print_line(\u0026#34;Arg: \u0026#34; + arg.name); } } } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool ClassDB::get_signal(const StringName \u0026amp;p_class, const StringName \u0026amp;p_signal, MethodInfo *r_signal) { //锁上读锁 OBJTYPE_RLOCK; ClassInfo *type = classes.getptr(p_class); ClassInfo *check = type; //向上逐级查询classinfo，直到object类 while (check) { //获取信号信息 if (check-\u0026gt;signal_map.has(p_signal)) { if (r_signal) { //进行值拷贝 *r_signal = check-\u0026gt;signal_map[p_signal]; } return true; } //父类ClassInfo指针 check = check-\u0026gt;inherits_ptr; } return false; } get_signal_list 获取某个类所有信号,包括父类信号\n方法签名\n1 2 3 4 5 void ClassDB::get_signal_list( const StringName \u0026amp;p_class, //类名 List\u0026lt;MethodInfo\u0026gt; *p_signals, //信号列表引用，用于返回查询结果 bool p_no_inheritance //是否查询父类信号 ); 使用示例\n1 2 3 4 5 6 7 8 void testfun(){ List\u0026lt;MethodInfo\u0026gt; signals; ClassDB::get_signal_list(\u0026#34;Node2D\u0026#34;, \u0026amp;signals); for (List\u0026lt;MethodInfo\u0026gt;::Element *E = signals.front(); E; E = E-\u0026gt;next()) { print_line(\u0026#34;Signal: \u0026#34; + E-\u0026gt;get().name); } } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void ClassDB::get_signal_list(const StringName \u0026amp;p_class, List\u0026lt;MethodInfo\u0026gt; *p_signals, bool p_no_inheritance) { //锁上读锁 非空判断 OBJTYPE_RLOCK; ClassInfo *type = classes.getptr(p_class); ERR_FAIL_NULL(type); //向上逐级查询classinfo，直到object类 ClassInfo *check = type; while (check) { //遍历所有信号，并推入数组 for (KeyValue\u0026lt;StringName, MethodInfo\u0026gt; \u0026amp;E : check-\u0026gt;signal_map) { p_signals-\u0026gt;push_back(E.value); } if (p_no_inheritance) { return; } check = check-\u0026gt;inherits_ptr; } } 属性接口 属性相关的信息，存储在ClassInfo的property_list、property_map和property_setget当中\n接口 作用 add_property 给某个类注册一个“属性”，并把这个属性和对应的 setter/getter 方法绑定起来 add_property_array 为 Inspector 生成“数组式属性组”的辅助函数，本身不创建实际的属性 add_property_array_count 给一个类注册数组属性 add_property_group 为 Inspector中显示的属性分组 add_property_subgroup 创建 缩进更深一级的子分组 add_linked_property 链接属性，将子属下关联到父属性 get_property_list 获取某个类的所有属性列表 get_property_info 获取某个类的某个属性，注意由于是通过ClassInfo：：property_map来进行查询的，因此占位的属性信息会返回false get_property 获取某个实例的属性值，信息存放在ClassInfo::PropertySetGet中 set_property 设置某个实例的属性值，信息存放在ClassInfo::PropertySetGet中 has_property 查询某个类是否定义过某个属性，信息存放在ClassInfo::PropertySetGet中 get_property_index 查询属性索引，信息存放在ClassInfo::PropertySetGet中 get_property_type 获取属性类型，信息存放在ClassInfo::PropertySetGet中 get_property_setter 获取属性setter方法名，信息存放在ClassInfo::PropertySetGet中 get_property_getter 获取属性getter方法名，信息存放在ClassInfo::PropertySetGet中 add_property add_property给某个类注册一个“属性”，并把这个属性和对应的 setter/getter 方法绑定起来。\n一般结合get_class_static()使用，在_bind_methods 中调用，注册本类的属性。\n方法签名\n1 2 3 4 5 6 7 static void add_property( const StringName \u0026amp;p_class,// 类名，使用封装的ADD_PROPERTY宏时，该类名会被自动填入 const PropertyInfo \u0026amp;p_pinfo,// 属性信息 const StringName \u0026amp;p_setter,// setter 方法名 const StringName \u0026amp;p_getter,// getter 方法名 int p_index = -1 // 属性索引，默认使用-1，ADD_PROPERTYI中可以添加索引。配合add_property_array使用 ); 常用的宏定义\n1 2 #define ADD_PROPERTY(m_property, m_setter, m_getter) ::ClassDB::add_property(get_class_static(), m_property, _scs_create(m_setter), _scs_create(m_getter)) #define ADD_PROPERTYI(m_property, m_setter, m_getter, m_index) ::ClassDB::add_property(get_class_static(), m_property, _scs_create(m_setter), _scs_create(m_getter), m_index) 使用示例\n1 2 3 4 5 6 7 8 9 void MyNode::_bind_methods() { ClassDB::bind_method(D_METHOD(\u0026#34;set_value\u0026#34;, \u0026#34;index\u0026#34;, \u0026#34;value\u0026#34;), \u0026amp;MyData::set_value); ClassDB::bind_method(D_METHOD(\u0026#34;get_value\u0026#34;, \u0026#34;index\u0026#34;), \u0026amp;MyData::get_value); // 这里 p_index 分别写 0/1/2 ClassDB::add_property(\u0026#34;MyData\u0026#34;,PropertyInfo(Variant::FLOAT, \u0026#34;value_0\u0026#34;),\u0026#34;set_value\u0026#34;, \u0026#34;get_value\u0026#34;,0); //或者用宏 ADD_PROPERTY(PropertyInfo(Variant::FLOAT, \u0026#34;value_0\u0026#34;),\u0026#34;set_value\u0026#34;, \u0026#34;get_value\u0026#34;); } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 void ClassDB::add_property(const StringName \u0026amp;p_class, const PropertyInfo \u0026amp;p_pinfo, const StringName \u0026amp;p_setter, const StringName \u0026amp;p_getter, int p_index) { //锁上读锁，获取类信息 lock.read_lock(); ClassInfo *type = classes.getptr(p_class); lock.read_unlock(); //类信息非空判断 ERR_FAIL_NULL(type); //获取setter方法 MethodBind *mb_set = nullptr; if (p_setter) { mb_set = get_method(p_class, p_setter); #ifdef DEBUG_METHODS_ENABLED ERR_FAIL_NULL_MSG(mb_set, vformat(\u0026#34;Invalid setter \u0026#39;%s::%s\u0026#39; for property \u0026#39;%s\u0026#39;.\u0026#34;, p_class, p_setter, p_pinfo.name)); int exp_args = 1 + (p_index \u0026gt;= 0 ? 1 : 0); ERR_FAIL_COND_MSG(mb_set-\u0026gt;get_argument_count() != exp_args, vformat(\u0026#34;Invalid function for setter \u0026#39;%s::%s\u0026#39; for property \u0026#39;%s\u0026#39;.\u0026#34;, p_class, p_setter, p_pinfo.name)); #endif } //获取getter方法 MethodBind *mb_get = nullptr; if (p_getter) { mb_get = get_method(p_class, p_getter); #ifdef DEBUG_METHODS_ENABLED ERR_FAIL_NULL_MSG(mb_get, vformat(\u0026#34;Invalid getter \u0026#39;%s::%s\u0026#39; for property \u0026#39;%s\u0026#39;.\u0026#34;, p_class, p_getter, p_pinfo.name)); int exp_args = 0 + (p_index \u0026gt;= 0 ? 1 : 0); ERR_FAIL_COND_MSG(mb_get-\u0026gt;get_argument_count() != exp_args, vformat(\u0026#34;Invalid function for getter \u0026#39;%s::%s\u0026#39; for property \u0026#39;%s\u0026#39;.\u0026#34;, p_class, p_getter, p_pinfo.name)); #endif } //属性名称重复报错 #ifdef DEBUG_METHODS_ENABLED ERR_FAIL_COND_MSG(type-\u0026gt;property_setget.has(p_pinfo.name), vformat(\u0026#34;Object \u0026#39;%s\u0026#39; already has property \u0026#39;%s\u0026#39;.\u0026#34;, p_class, p_pinfo.name)); #endif //锁上写锁，直到函数结束 OBJTYPE_WLOCK //在classinfo中添加属性信息 type-\u0026gt;property_list.push_back(p_pinfo); type-\u0026gt;property_map[p_pinfo.name] = p_pinfo; #ifdef DEBUG_METHODS_ENABLED if (mb_get) { type-\u0026gt;methods_in_properties.insert(p_getter); } if (mb_set) { type-\u0026gt;methods_in_properties.insert(p_setter); } #endif //添加属性的set和get方法，键是属性名称 PropertySetGet psg; psg.setter = p_setter; psg.getter = p_getter; psg._setptr = mb_set; psg._getptr = mb_get; psg.index = p_index; psg.type = p_pinfo.type; type-\u0026gt;property_setget[p_pinfo.name] = psg; } add_property_array 在 Inspector 中创建一个“数组属性组”（array property group），用于显示一组以类似命名规则的属性。\n它不直接存 getter/setter，也不关联实际属性。 它是一个 虚拟属性（Variant::NIL） ，仅用于 UI 分组。 它配合add_property/ADD_PROPERTYI使用，可以创建一个定长数组属性。 它配合_set()/_get()/_get_property_list()使用，可以创建一个动态数组属性。 注意：它的使用非常复杂,需要结合Object的宏get_property_list使用。后续会有专门的章节讲解。此处仅给出一个简短的示例\n方法签名\n1 2 3 4 5 void ClassDB::add_property_array( const StringName \u0026amp;p_class, // 类名 const StringName \u0026amp;p_path, // 属性路径 const String \u0026amp;p_array_element_prefix // 数组元素前缀 ); 常用的宏定义\n1 #define ADD_ARRAY(m_array_path, m_prefix) ClassDB::add_property_array(get_class_static(), m_array_path, m_prefix) 使用示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void MyNode::_bind_methods() { ClassDB::bind_method(D_METHOD(\u0026#34;set_position\u0026#34;, \u0026#34;index\u0026#34;, \u0026#34;value\u0026#34;), \u0026amp;MyNode::set_position); ClassDB::bind_method(D_METHOD(\u0026#34;get_position\u0026#34;, \u0026#34;index\u0026#34;), \u0026amp;MyNode::get_position); // 添加数组属性组（虚拟属性），定长数组 // 添加每个实际属性，简易版本 // 对于变长数组，需要重载函数get_property_list中定义该属性数组的行为 ClassDB::add_property_array(\u0026#34;MyNode\u0026#34;, \u0026#34;positions\u0026#34;, \u0026#34;positions/\u0026#34;); for (int i = 0; i \u0026lt; 3; i++) { String name = \u0026#34;positions/\u0026#34; + itos(i); ClassDB::add_property(\u0026#34;MyNode\u0026#34;, PropertyInfo(Variant::VECTOR3, name), \u0026#34;set_position\u0026#34;, \u0026#34;get_position\u0026#34;, i); } //使用宏的版本实现 ADD_ARRAY(\u0026#34;TestProperty\u0026#34;, \u0026#34;TestProperty/\u0026#34;); ADD_PROPERTYI(PropertyInfo(Variant::COLOR,\u0026#34;TestProperty/0\u0026#34;), \u0026#34;set_TP_color\u0026#34;, \u0026#34;get_TP_color\u0026#34;,1); ADD_PROPERTYI(PropertyInfo(Variant::COLOR,\u0026#34;TestProperty/1\u0026#34;), \u0026#34;set_TP_color\u0026#34;, \u0026#34;get_TP_color\u0026#34;,2); ClassDB::add_property(\u0026#34;NsTestResource\u0026#34;, PropertyInfo(Variant::VECTOR3,\u0026#34;TestProperty/2\u0026#34;), \u0026#34;set_TP_vector3\u0026#34;, \u0026#34;get_TP_vector3\u0026#34;, 0 ); } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 //此处就非常简单，仅做了占位的属性添加 void ClassDB::add_property_array(const StringName \u0026amp;p_class, const StringName \u0026amp;p_path, const String \u0026amp;p_array_element_prefix) { //锁上写锁，直到函数结束，空值判断 OBJTYPE_WLOCK; ClassInfo *type = classes.getptr(p_class); ERR_FAIL_NULL(type); // 添加到属性组，类型为空NIL，用于占位 //注意，此处的usage属性为 PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_ARRAY ，也就是声明为了数组，以及编辑器可见 type-\u0026gt;property_list.push_back(PropertyInfo(Variant::NIL, p_path, PROPERTY_HINT_NONE, \u0026#34;\u0026#34;, PROPERTY_USAGE_EDITOR | PROPERTY_USAGE_ARRAY, p_array_element_prefix)); } add_property_array_count 给一个类注册数组属性（Array Property）;\n通常结合自定义的_setter_ 和 _getter_以及_get_property_list_使用 可以实现自定义的变长数组 它只注册长度属性本身 方法签名\n1 2 3 4 5 6 7 8 9 static void add_property_array_count( const StringName \u0026amp;p_class, //被绑定类的类名 const String \u0026amp;p_label, //Inspector 上显示的 标签（用户可见）。 const StringName \u0026amp;p_count_property, //数组长度属性的 内部属性名。 const StringName \u0026amp;p_count_setter, //对应 setter 函数名 const StringName \u0026amp;p_count_getter, //对应 getter 函数名 const String \u0026amp;p_array_element_prefix, //数组元素的前缀 uint32_t p_count_usage = PROPERTY_USAGE_DEFAULT //属性的PropertyUsage类型 ); 常用的宏定义\n1 2 #define ADD_ARRAY_COUNT(m_label, m_count_property, m_count_property_setter, m_count_property_getter, m_prefix) ClassDB::add_property_array_count(get_class_static(), m_label, m_count_property, _scs_create(m_count_property_setter), _scs_create(m_count_property_getter), m_prefix) #define ADD_ARRAY_COUNT_WITH_USAGE_FLAGS(m_label, m_count_property, m_count_property_setter, m_count_property_getter, m_prefix, m_property_usage_flags) ClassDB::add_property_array_count(get_class_static(), m_label, m_count_property, _scs_create(m_count_property_setter), _scs_create(m_count_property_getter), m_prefix, m_property_usage_flags) 使用示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 注册数组组：名字“Colors”，长度属性名“color_count”，元素前缀“color_” //此处仅对数组长度进行注册，其他属性不注册 // _bind_methods()中 ADD_ARRAY_COUNT(\u0026#34;Colors\u0026#34;, \u0026#34;color_count\u0026#34;, \u0026#34;set_color_count\u0026#34;, \u0026#34;get_color_count\u0026#34;, \u0026#34;color_\u0026#34;); // 下方是三个配套函数：_set()、_get()、_get_property_list() // 此处真正定义的数组中属性的行为 bool NsTestResource::_set(const StringName \u0026amp;p_name, const Variant \u0026amp;p_value){ Vector\u0026lt;String\u0026gt; components = String(p_name).split(\u0026#34;/\u0026#34;, true, 2); if (components.size() \u0026gt;= 2 \u0026amp;\u0026amp; components[0].begins_with(\u0026#34;color_\u0026#34;) \u0026amp;\u0026amp; components[0].trim_prefix(\u0026#34;color_\u0026#34;).is_valid_int()) { int index = components[0].trim_prefix(\u0026#34;color_\u0026#34;).to_int(); const String \u0026amp;property = components[1]; if (property == \u0026#34;color\u0026#34;) { // set_point_position(point_index, p_value); set_color(index, p_value); return true; } if (property == \u0026#34;shader\u0026#34;) { set_shader(index,p_value); return true; } } return false; } bool NsTestResource::_get(const StringName \u0026amp;p_name, Variant \u0026amp;r_ret)const { Vector\u0026lt;String\u0026gt; components = String(p_name).split(\u0026#34;/\u0026#34;, true, 2); if (components.size() \u0026gt;= 2 \u0026amp;\u0026amp; components[0].begins_with(\u0026#34;color_\u0026#34;) \u0026amp;\u0026amp; components[0].trim_prefix(\u0026#34;color_\u0026#34;).is_valid_int()) { int index = components[0].trim_prefix(\u0026#34;color_\u0026#34;).to_int(); const String \u0026amp;property = components[1]; if (property == \u0026#34;color\u0026#34;) { r_ret = get_color(index); return true; } if (property == \u0026#34;shader\u0026#34;) { r_ret = get_shader(index); return true; } } return false; } void NsTestResource::_get_property_list(List\u0026lt;PropertyInfo\u0026gt; *p_list)const { print_line(\u0026#34;NsTestResource::_get_property_list\u0026#34;); for (int i = 0; i \u0026lt; colors.size();i++) { PropertyInfo pi = PropertyInfo(Variant::COLOR, vformat(\u0026#34;color_%d/color\u0026#34;,i)); p_list-\u0026gt;push_back(pi); pi = PropertyInfo(Variant::OBJECT, vformat(\u0026#34;color_%d/shader\u0026#34;,i),PROPERTY_HINT_RESOURCE_TYPE, \u0026#34;Shader\u0026#34;); p_list-\u0026gt;push_back(pi); } } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 void ClassDB::add_property_array_count(const StringName \u0026amp;p_class, const String \u0026amp;p_label, const StringName \u0026amp;p_count_property, const StringName \u0026amp;p_count_setter, const StringName \u0026amp;p_count_getter, const String \u0026amp;p_array_element_prefix, uint32_t p_count_usage) { add_property(p_class, PropertyInfo(Variant::INT, //属性类型为INT p_count_property, //属性名 PROPERTY_HINT_NONE, //提示为无提示 \u0026#34;\u0026#34;, //提示信息为空 p_count_usage | PROPERTY_USAGE_ARRAY, //数组属性 vformat(\u0026#34;%s,%s\u0026#34;, p_label, p_array_element_prefix) //类名为标签和前缀的组装 ), p_count_setter, //属性设置函数 p_count_getter //属性获取函数 ); } add_property_group ClassDB::add_property_group()用于在 Godot Inspector（属性面板）中创建一条分组标题，让多个属性显示在同一个折叠组下，从而让 Inspector 清晰整洁。 方法签名\n1 2 3 4 5 6 void ClassDB::add_property_group( const StringName \u0026amp;p_class, //自身类名 const String \u0026amp;p_name, const //分组标题 String \u0026amp;p_prefix, //分组前缀，其他具有该前缀的属性将显示在本分组下 int p_indent_depth = 0 //分组缩进深度 ); 常用的宏定义\n1 2 3 4 //使用默认缩进 0 #define ADD_GROUP(m_name, m_prefix) ::ClassDB::add_property_group(get_class_static(), m_name, m_prefix) //使用自定义缩进 #define ADD_GROUP_INDENT(m_name, m_prefix, m_depth) ::ClassDB::add_property_group(get_class_static(), m_name, m_prefix, m_depth) 使用示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void Resource::_bind_methods() { ADD_GROUP(\u0026#34;AddGroup1\u0026#34;, \u0026#34;addGroup1_\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup1_Color0\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup1_Color1\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_GROUP_INDENT(\u0026#34;AddGroup2\u0026#34;, \u0026#34;AddGroup2_\u0026#34;,1); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;AddGroup2_Color2\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;AddGroup2_Color3\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_SUBGROUP(\u0026#34;AddGroup3\u0026#34;, \u0026#34;addGroup3_\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup3_Color4\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup3_Color5\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_SUBGROUP_INDENT(\u0026#34;AddGroup4\u0026#34;, \u0026#34;addGroup4_\u0026#34;,2); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup4_Color6\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); ADD_PROPERTY(PropertyInfo(Variant::COLOR,\u0026#34;addGroup4_Color7\u0026#34;), \u0026#34;set_color_Group\u0026#34;, \u0026#34;get_color_Group\u0026#34;); } 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void ClassDB::add_property_group(const StringName \u0026amp;p_class, const String \u0026amp;p_name, const String \u0026amp;p_prefix, int p_indent_depth) { // 锁上读锁，获取类型信息指针，非空检测 OBJTYPE_WLOCK; ClassInfo *type = classes.getptr(p_class); ERR_FAIL_NULL(type); //根据缩进，进行前缀拼接 String prefix = p_prefix; if (p_indent_depth \u0026gt; 0) { prefix = vformat(\u0026#34;%s,%d\u0026#34;, p_prefix, p_indent_depth); } //在类型信息的property_list中，填入分组的属性 type-\u0026gt;property_list.push_back( PropertyInfo(Variant::NIL, //占位 p_name, //分组名 PROPERTY_HINT_NONE, //无提示 prefix, //前缀 PROPERTY_USAGE_GROUP//使用类型为 分组 ) ); } get_property_list 本质还是对ClassInfo中的property_list的遍历读.\n注意，此处的ClassDB::get_property_list仅有查询的功能，并不会触发我们自己重写的_get_property_list()函数。\n如果需要走自定义的_get_property_list()函数，请使用YourObject.get_property_list()的方式来查询。\nobject中的GDCLASS(m_class, m_inherits)宏中包装了_get_property_listv方法，用于获取属性列表时调用自定义的_get_property_list()函数。\n方法签名\n1 2 3 4 5 6 static void get_property_list( const StringName \u0026amp;p_class, //需要查询类的名称 List\u0026lt;PropertyInfo\u0026gt; *p_list, //返回的属性列表 bool p_no_inheritance = false,//是否向上查询父类,默认查询 const Object *p_validator = nullptr)//关联的实际类，可以不关联 ; 使用示例\n1 2 List\u0026lt;PropertyInfo\u0026gt; list; ClassDB::get_property_list(\u0026#34;YourObject\u0026#34;, \u0026amp;list,true); 源码解读（带注释）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void ClassDB::get_property_list(const StringName \u0026amp;p_class, List\u0026lt;PropertyInfo\u0026gt; *p_list, bool p_no_inheritance, const Object *p_validator) { //锁上读锁,直到出作用域 OBJTYPE_RLOCK; //逐级向父类查询类型信息 ClassInfo *type = classes.getptr(p_class); ClassInfo *check = type; while (check) { //遍历属性列表信息 for (const PropertyInfo \u0026amp;pi : check-\u0026gt;property_list) { //是否关联实例 if (p_validator) { // Making a copy as we may modify it. PropertyInfo pi_mut = pi; p_validator-\u0026gt;validate_property(pi_mut); p_list-\u0026gt;push_back(pi_mut); } else { //不关联就将property_list直接推入列表p_list p_list-\u0026gt;push_back(pi); } } //是否查询父类，如果不查询，直接返回 if (p_no_inheritance) { return; } //变更为父类类型信息指针 check = check-\u0026gt;inherits_ptr; } } get_property 方法签名\n1 2 3 4 5 bool ClassDB::get_property( Object *p_object, //被查询的实例 const StringName \u0026amp;p_property, //属性名 Variant \u0026amp;r_value//属性值 ); 使用示例\n1 bool ret = ClassDB::get_property(\u0026#34;MyObject\u0026#34;, \u0026#34;property_name\u0026#34;, value); 源码解读（带注释）\n注：PropertySetGet定义详见此处\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 bool ClassDB::get_property(Object *p_object, const StringName \u0026amp;p_property, Variant \u0026amp;r_value) { //空指针检测 ERR_FAIL_NULL_V(p_object, false); //向上逐级查询类型信息 ClassInfo *type = classes.getptr(p_object-\u0026gt;get_class_name()); ClassInfo *check = type; while (check) { //查询类型信息中的property_setget const PropertySetGet *psg = check-\u0026gt;property_setget.getptr(p_property); if (psg) { //存在PropertySetGet，但是没有getter方法 if (!psg-\u0026gt;getter) { return true; //return true but do nothing } if (psg-\u0026gt;index \u0026gt;= 0) { Variant index = psg-\u0026gt;index; const Variant *arg[1] = { \u0026amp;index }; Callable::CallError ce; //利用对象实例的callp方法，动态调用该属性的getter方法 //对于索引不为-1（数组）的属性值，需要传入索引参数 const Variant value = p_object-\u0026gt;callp(psg-\u0026gt;getter, arg, 1, ce); r_value = (ce.error == Callable::CallError::CALL_OK) ? value : Variant(); } else { Callable::CallError ce; if (psg-\u0026gt;_getptr) { //通过MethodBind指针_getptr调用getter方法 r_value = psg-\u0026gt;_getptr-\u0026gt;call(p_object, nullptr, 0, ce); } else { const Variant value = p_object-\u0026gt;callp(psg-\u0026gt;getter, nullptr, 0, ce); r_value = (ce.error == Callable::CallError::CALL_OK) ? value : Variant(); } } return true; } const int64_t *c = check-\u0026gt;constant_map.getptr(p_property); //constants count if (c) { r_value = *c; return true; } if (check-\u0026gt;method_map.has(p_property)) { //methods count r_value = Callable(p_object, p_property); return true; } if (check-\u0026gt;signal_map.has(p_property)) { //signals count r_value = Signal(p_object, p_property); return true; } check = check-\u0026gt;inherits_ptr; } // The \u0026#34;free()\u0026#34; method is special, so we assume it exists and return a Callable. if (p_property == CoreStringName(free_)) { r_value = Callable(p_object, p_property); return true; } return false; } 函数接口 函数相关的接口，是ClassDB中最复杂的一组，涉及到函数的绑定，所以godot用了非常多的模板来实现。 它的信息存储在ClassInfo的下面两个成员变量中：\nHashMap\u0026lt;StringName, MethodBind *\u0026gt; method_map; HashMap\u0026lt;StringName, LocalVector\u0026lt;MethodBind *\u0026gt;\u0026gt; method_map_compatibility; 接口 作用 bind_method 类型注册时的函数绑定方法，用的非常广泛 has_method 查询是类否包含某个函数，通过classinfo的method_map来查询 get_method_list 查询某个类的所有函数信息MethodInfo,通过classinfo的method_map来查询 bind_method bind_method的主要作用是把一个C++成员函数，封装成一个MethodBind，然后再注册进ClassDB的类型信息中，路径为：classdb::classes-\u0026gt;ClassInfo::method_map\n该方法使用非常简单，但是内部实现极其复杂，笔者代码能力有限，仅能做部分代码的解读。因此该函数的介绍，会更偏向使用。\nMethodDefinition 在下方有详细描述，它仅是字符串的描述 方法签名\n1 2 3 4 5 6 template \u0026lt;typename N, typename M, typename... VarArgs\u0026gt; static MethodBind *bind_method( N p_method_name, //函数名、参数列表的描述，MethodDefinition类型，利用D_METHOD()生成 M p_method, //成员函数指针，例如 \u0026amp;Input::warp_mouse VarArgs... p_args //函数默认值参数包 ); 使用示例\nDEFVAL用于函数默认值参数的包装，它的排序对应函数签名的后N位。\n以下方testfunc的函数绑定为例：\narg4 = 0.0f arg5 = -1.0f 1 2 3 4 void Input::_bind_methods() { ClassDB::bind_method(D_METHOD(\u0026#34;is_anything_pressed\u0026#34;), \u0026amp;Input::is_anything_pressed); ClassDB::bind_method(D_METHOD(\u0026#34;testfunc\u0026#34;, \u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;, \u0026#34;arg3\u0026#34;, \u0026#34;arg4\u0026#34;, \u0026#34;arg5\u0026#34;), \u0026amp;Input::testfunc, DEFVAL(0.0f),DEFVAL(-1.0f)); } 源码解读（带注释）\n通过上面的示例代码，可以看到要正确绑定一个函数，需要使用两个函数\nD_METHOD 创建MethodDefinition，用于描述函数的参数列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template \u0026lt;typename... VarArgs\u0026gt; MethodDefinition D_METHOD(const char *p_name, const VarArgs... p_args) { //创建参数列表args,利用列表初始化展开参数包p_args //收集所有参数名称 const char *args[sizeof...(p_args) + 1] = { p_args..., nullptr }; // +1 makes sure zero sized arrays are also supported. const char *const *argptrs[sizeof...(p_args) + 1]; for (uint32_t i = 0; i \u0026lt; sizeof...(p_args); i++) { argptrs[i] = \u0026amp;args[i]; } //将收集的参数列表，传入D_METHODP()进行MD的创建 return D_METHODP(p_name, sizeof...(p_args) == 0 ? nullptr : (const char *const **)argptrs, sizeof...(p_args)); } MethodDefinition D_METHODP(const char *p_name, const char *const **p_args, uint32_t p_argcount) { //实际创建MethodDefinition，填入函数名称和参数名称列表 MethodDefinition md; md.name = StaticCString::create(p_name); md.args.resize(p_argcount); for (uint32_t i = 0; i \u0026lt; p_argcount; i++) { md.args.write[i] = StaticCString::create(*p_args[i]); } return md; } ClassDB::bind_method 执行函数绑定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;typename N, typename M, typename... VarArgs\u0026gt; static MethodBind *bind_method(N p_method_name, M p_method, VarArgs... p_args) { //创建参数列表args,利用列表初始化展开参数包p_args Variant args[sizeof...(p_args) + 1] = { p_args..., Variant() }; // +1 makes sure zero sized arrays are also supported. //创建参数指针列表argptrs const Variant *argptrs[sizeof...(p_args) + 1]; //遍历参数列表args，并将参数指针保存到argptrs中 for (uint32_t i = 0; i \u0026lt; sizeof...(p_args); i++) { argptrs[i] = \u0026amp;args[i]; } //创建函数绑定MethodBind //此处比较复杂，暂时不展开 MethodBind *bind = create_method_bind(p_method); if constexpr (std::is_same_v\u0026lt;typename member_function_traits\u0026lt;M\u0026gt;::return_type, Object *\u0026gt;) { bind-\u0026gt;set_return_type_is_raw_object_ptr(true); } //将函数绑定信息的注册到ClassDB中 return bind_methodfi(METHOD_FLAGS_DEFAULT, bind, false, p_method_name, sizeof...(p_args) == 0 ? nullptr : (const Variant **)argptrs, sizeof...(p_args)); } get_method_list 信息类 ClassInfo ClassInfo是ClassDB中定义的类信息结构体，它保存了类的元数据，比如类的名称、继承关系、成员变量、方法、属性等信息。下方截取了4.4版本godot源码中ClassInfo类的部分代码，并标注了一些重要的信息，帮助我们去整体的理解ClassInfo的运行原理。为了方便理解，方法和属性的顺序，并非与源码严格一致。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct ClassInfo { // 根据注册的时机和接口不同，API类型有以下5种： // API_CORE、 // API_EDITOR、 // API_EXTENSION、 // API_EDITOR_EXTENSION、 // API_NONE APIType api = API_NONE; //父类的类信息指针 ClassInfo *inherits_ptr = nullptr; void *class_ptr = nullptr; //gdextension指针 ObjectGDExtension *gdextension = nullptr; //类的方法信息，键是方法名，值是方法绑定 HashMap\u0026lt;StringName, MethodBind *\u0026gt; method_map; HashMap\u0026lt;StringName, LocalVector\u0026lt;MethodBind *\u0026gt;\u0026gt; method_map_compatibility; HashMap\u0026lt;StringName, int64_t\u0026gt; constant_map; struct EnumInfo { List\u0026lt;StringName\u0026gt; constants; bool is_bitfield = false; }; HashMap\u0026lt;StringName, EnumInfo\u0026gt; enum_map; //类信号信息，键是信号名 HashMap\u0026lt;StringName, MethodInfo\u0026gt; signal_map; //类属性信息列表 List\u0026lt;PropertyInfo\u0026gt; property_list; //类属性信息，键是属性名称，值是属性信息 HashMap\u0026lt;StringName, PropertyInfo\u0026gt; property_map; //类属性set/get信息，键是属性名称，值是属性设置和获取方法信息 HashMap\u0026lt;StringName, PropertySetGet\u0026gt; property_setget; HashMap\u0026lt;StringName, Vector\u0026lt;uint32_t\u0026gt;\u0026gt; virtual_methods_compat; //父类名称 StringName inherits; //自身类名 StringName name; bool disabled = false; bool exposed = false; bool reloadable = false; bool is_virtual = false; bool is_runtime = false; // The bool argument indicates the need to postinitialize. Object *(*creation_func)(bool) = nullptr; ClassInfo() {} ~ClassInfo() {} }; MethodDefinition 1 2 3 4 5 6 7 8 9 struct MethodDefinition { StringName name;//方法名称 Vector\u0026lt;StringName\u0026gt; args;//方法参数名称列表 MethodDefinition() {} MethodDefinition(const char *p_name) : name(p_name) {} MethodDefinition(const StringName \u0026amp;p_name) : name(p_name) {} }; MethodInfo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 struct MethodInfo { String name; PropertyInfo return_val; uint32_t flags = METHOD_FLAGS_DEFAULT; int id = 0; List\u0026lt;PropertyInfo\u0026gt; arguments; Vector\u0026lt;Variant\u0026gt; default_arguments; int return_val_metadata = 0; Vector\u0026lt;int\u0026gt; arguments_metadata; int get_argument_meta(int p_arg) const { ERR_FAIL_COND_V(p_arg \u0026lt; -1 || p_arg \u0026gt; arguments.size(), 0); if (p_arg == -1) { return return_val_metadata; } return arguments_metadata.size() \u0026gt; p_arg ? arguments_metadata[p_arg] : 0; } inline bool operator==(const MethodInfo \u0026amp;p_method) const { return id == p_method.id \u0026amp;\u0026amp; name == p_method.name; } inline bool operator\u0026lt;(const MethodInfo \u0026amp;p_method) const { return id == p_method.id ? (name \u0026lt; p_method.name) : (id \u0026lt; p_method.id); } operator Dictionary() const; static MethodInfo from_dict(const Dictionary \u0026amp;p_dict); uint32_t get_compatibility_hash() const; MethodInfo() {} explicit MethodInfo(const GDExtensionMethodInfo \u0026amp;pinfo) : name(*reinterpret_cast\u0026lt;StringName *\u0026gt;(pinfo.name)), return_val(PropertyInfo(pinfo.return_value)), flags(pinfo.flags), id(pinfo.id) { for (uint32_t j = 0; j \u0026lt; pinfo.argument_count; j++) { arguments.push_back(PropertyInfo(pinfo.arguments[j])); } const Variant *def_values = (const Variant *)pinfo.default_arguments; for (uint32_t j = 0; j \u0026lt; pinfo.default_argument_count; j++) { default_arguments.push_back(def_values[j]); } } void _push_params(const PropertyInfo \u0026amp;p_param) { arguments.push_back(p_param); } template \u0026lt;typename... VarArgs\u0026gt; void _push_params(const PropertyInfo \u0026amp;p_param, VarArgs... p_params) { arguments.push_back(p_param); _push_params(p_params...); } MethodInfo(const String \u0026amp;p_name) { name = p_name; } template \u0026lt;typename... VarArgs\u0026gt; MethodInfo(const String \u0026amp;p_name, VarArgs... p_params) { name = p_name; _push_params(p_params...); } MethodInfo(Variant::Type ret) { return_val.type = ret; } MethodInfo(Variant::Type ret, const String \u0026amp;p_name) { return_val.type = ret; name = p_name; } template \u0026lt;typename... VarArgs\u0026gt; MethodInfo(Variant::Type ret, const String \u0026amp;p_name, VarArgs... p_params) { name = p_name; return_val.type = ret; _push_params(p_params...); } MethodInfo(const PropertyInfo \u0026amp;p_ret, const String \u0026amp;p_name) { return_val = p_ret; name = p_name; } template \u0026lt;typename... VarArgs\u0026gt; MethodInfo(const PropertyInfo \u0026amp;p_ret, const String \u0026amp;p_name, VarArgs... p_params) { return_val = p_ret; name = p_name; _push_params(p_params...); } }; MethodBind MethodBind实现比较复杂，此处仅列出部分成员函数和成员变量，用于理解它的作用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MethodBind { int method_id; uint32_t hint_flags = METHOD_FLAGS_DEFAULT; StringName name; StringName instance_class; Vector\u0026lt;Variant\u0026gt; default_arguments; int default_argument_count = 0; int argument_count = 0; bool _static = false; bool _const = false; bool _returns = false; bool _returns_raw_obj_ptr = false; // ... } PropertyInfo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 struct PropertyInfo { Variant::Type type = Variant::NIL; String name; StringName class_name; // For classes PropertyHint hint = PROPERTY_HINT_NONE; String hint_string; uint32_t usage = PROPERTY_USAGE_DEFAULT; // If you are thinking about adding another member to this class, ask the maintainer (Juan) first. _FORCE_INLINE_ PropertyInfo added_usage(uint32_t p_fl) const { PropertyInfo pi = *this; pi.usage |= p_fl; return pi; } operator Dictionary() const; static PropertyInfo from_dict(const Dictionary \u0026amp;p_dict); PropertyInfo() {} PropertyInfo(const Variant::Type p_type, const String \u0026amp;p_name, const PropertyHint p_hint = PROPERTY_HINT_NONE, const String \u0026amp;p_hint_string = \u0026#34;\u0026#34;, const uint32_t p_usage = PROPERTY_USAGE_DEFAULT, const StringName \u0026amp;p_class_name = StringName()) : type(p_type), name(p_name), hint(p_hint), hint_string(p_hint_string), usage(p_usage) { if (hint == PROPERTY_HINT_RESOURCE_TYPE) { class_name = hint_string; } else { class_name = p_class_name; } } PropertyInfo(const StringName \u0026amp;p_class_name) : type(Variant::OBJECT), class_name(p_class_name) {} explicit PropertyInfo(const GDExtensionPropertyInfo \u0026amp;pinfo) : type((Variant::Type)pinfo.type), name(*reinterpret_cast\u0026lt;StringName *\u0026gt;(pinfo.name)), class_name(*reinterpret_cast\u0026lt;StringName *\u0026gt;(pinfo.class_name)), hint((PropertyHint)pinfo.hint), hint_string(*reinterpret_cast\u0026lt;String *\u0026gt;(pinfo.hint_string)), usage(pinfo.usage) {} bool operator==(const PropertyInfo \u0026amp;p_info) const { return ((type == p_info.type) \u0026amp;\u0026amp; (name == p_info.name) \u0026amp;\u0026amp; (class_name == p_info.class_name) \u0026amp;\u0026amp; (hint == p_info.hint) \u0026amp;\u0026amp; (hint_string == p_info.hint_string) \u0026amp;\u0026amp; (usage == p_info.usage)); } bool operator\u0026lt;(const PropertyInfo \u0026amp;p_info) const { return name \u0026lt; p_info.name; } }; PropertySetGet 1 2 3 4 5 6 7 8 struct PropertySetGet { int index;\t//属性索引，默认为-1，数组索引从0开始 StringName setter;\t//setter函数名 StringName getter;\t//getter函数名 MethodBind *_setptr = nullptr; //setter函数包指针 MethodBind *_getptr = nullptr; //getter函数包指针 Variant::Type type;\t//属性类型 }; ","date":"2025-11-07T09:18:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E4%BA%94godot%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9Frtti/","title":"【godot】五、godot中的动态类型信息系统RTTI"},{"content":"性能分析相关 godot作为相对成熟的游戏引擎，其本身就提供了相对完善的运行时性能监测工具。本文将对常用的运行时性能参数的获取和使用进行一个简易的说明，旨在帮助大家了解获取及理解这些参数。\nPerformance Performance是godot内置的性能数据存储器，它提供对许多与性能相关的不同监视器的访问，例如贴图内存使用情况 :RENDER_BUFFER_MEM_USED（在glbufferData的时候，会对申请的size进行累加）、绘制调用:RENDER_TOTAL_DRAW_CALLS_IN_FRAME （gldraw的时候加一）FPS。\n这些值与编辑器的调试器面板中的监视选项卡中显示的值相同。通过使用该类的 get_monitor() 方法，你可以从代码中访问该数据。\n注意：某些内置监视器仅在调试模式下可用，并且在以发布模式导出的项目中使用时，将始终返回 0。\n注意：出于性能原因，某些内置监视器不会实时更新，所以在更改之间可能会有长达 1 秒的延迟。\n注意：自定义监视器不支持负值。负值被钳制为 0\n1 2 //Performance::TIME_FPS是提前内置的Monitor Performance::get_singleton()-\u0026gt;get_monitor(Performance::TIME_FPS); 名称 作用 TIME_FPS 帧率（每秒帧数） TIME_PROCESS 每帧的处理时间（不包括物理和导航过程），c++/Gdscript TIME_PHYSICS_PROCESS 物理处理的时间 MEMORY_STATIC 静态内存使用量（不包括动态内存） MEMORY_STATIC_MAX 静态内存的最大使用量 MEMORY_MESSAGE_BUFFER_MAX 消息缓冲区的最大内存使用量 OBJECT_COUNT 当前场景中的总对象数 OBJECT_RESOURCE_COUNT 当前场景中资源的数量 OBJECT_NODE_COUNT 当前场景中节点的数量 OBJECT_ORPHAN_NODE_COUNT 孤立节点的数量（没有父节点的节点） RENDER_TOTAL_OBJECTS_IN_FRAME 每帧渲染的总对象数量 RENDER_TOTAL_PRIMITIVES_IN_FRAME 每帧渲染的总图形原语数量（如三角形、线条） RENDER_TOTAL_DRAW_CALLS_IN_FRAME 每帧渲染的总绘制调用次数 RENDER_TEXTURE_MEM_USED 渲染使用的纹理内存量 RENDER_BUFFER_MEM_USED 渲染使用的缓冲区内存量 MEMORY_STATIC Performance中的静态内存数据，包含了godot体系下的所有用户申请的内存，也即Variant中被标注的变量。\n**注意：**cpp原生类型申请的内存空间并不会被统计进去。\n该数据被实际存储在Memary类中，出于线程安全考虑，它被包装在一个原子类型中：\nRENDER_TEXTURE_MEM_USED 在gl渲染模式下，由于并没有RenderDevice层，都是直接使用的gl接口，因此数据的记录相对更加直接。\nperformancce中访问的RENDER_TEXTURE_MEM_USED是通过**RenderingServer提供的get_rendering_info**接口来获取的。\n在往下走就是RGS::RendererUtilities提供的**get_rendering_info**接口，在Utilities中，管理着gl申请出来的所有内存。\n在每一次申请和删除渲染gl内存时，Utilities都会对内存大小的统计数字做出相应的增减。\n我们在日常开发中遇到的资源泄露报错，就来自于Utilities的析构函数。\n当Utilities发生析构时，如果gl申请的内存未被完全释放，就会打印该条报错日志。（常由于孤立节点未被正确释放导致）\nRENDER_TOTAL_DRAW_CALLS_IN_FRAME performancce中访问的RENDER_TOTAL_DRAW_CALLS_IN_FRAME也是通过**RenderingServer提供的get_rendering_info接口来获取的。而RenderingServer查询的数据，则来自RendererViewport**的total_draw_calls_used。\nRendererViewport中这组数据，则是在绘制阶段draw_viewports()时，收集累加激活状态的Viewport中的render_info中的数据。\n对于每个激活的Viewport中的drawcall，会在gl光栅化的阶段，也就是实际调用gl绘制函数的时候，进行一次增加。\n**注意：**基于这一点，手动调用的绘制操作glDrawElements等，不会被统计进godot的Drawcall中。因此应尽量避免gl相关函数的直接调用。而应该通过godot的封装层RenderingServer来调用。\nRenderingServer Godot当中的RenderingServer相当于Unreal中的RHI，它是底层的渲染抽象层，负责与图形 API（如 OpenGL、Vulkan、DirectX、Metal 等）交互。\n同时它也存储了渲染相关的数据，并且提供了对应的获取接口。\nget_rendering_info get_rendering_info可以查询渲染绘制相关的信息，有以下几种：\n名称 说明 RENDERING_INFO_TOTAL_OBJECTS_IN_FRAME 绘制对象数量 RENDERING_INFO_TOTAL_PRIMITIVES_IN_FRAME 绘制图元数量 RENDERING_INFO_TOTAL_DRAW_CALLS_IN_FRAME DrawCall RENDERING_INFO_TEXTURE_MEM_USED 贴图内存 RENDERING_INFO_BUFFER_MEM_USED glbuffer RENDERING_INFO_VIDEO_MEM_USED RENDERING_INFO_PIPELINE_COMPILATIONS_CANVAS 渲染管线（Pipeline）编译的次数 RENDERING_INFO_PIPELINE_COMPILATIONS_MESH RENDERING_INFO_PIPELINE_COMPILATIONS_SURFACE RENDERING_INFO_PIPELINE_COMPILATIONS_DRAW RENDERING_INFO_PIPELINE_COMPILATIONS_SPECIALIZATION viewport_get_render_info 与上方接口差不多，但是针对某个视口，而非所有。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enum ViewportRenderInfo { VIEWPORT_RENDER_INFO_OBJECTS_IN_FRAME, VIEWPORT_RENDER_INFO_PRIMITIVES_IN_FRAME, VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME, VIEWPORT_RENDER_INFO_MAX, }; enum ViewportRenderInfoType { VIEWPORT_RENDER_INFO_TYPE_VISIBLE, VIEWPORT_RENDER_INFO_TYPE_SHADOW, VIEWPORT_RENDER_INFO_TYPE_CANVAS, VIEWPORT_RENDER_INFO_TYPE_MAX }; virtual int viewport_get_render_info(RID p_viewport, ViewportRenderInfoType p_type, ViewportRenderInfo p_info) = 0; Rander GPU and CPU Time 注意，需要利用下面两个接口时，需要利用viewport_set_measure_render_time()接口提前开启时间统计，否则始终返回0.\nviewport_get_measured_render_time_cpu，CPU 在指定 Viewport 上执行渲染的耗时 viewport_get_measured_render_time_gpu，GPU 在指定 Viewport 上执行渲染的耗时 get_frame_setup_time_cpu 准备渲染命令 阶段所消耗的时间 场景剔除（Culling） 渲染对象排序 光源与阴影的分配 材质/渲染状态设置 将渲染数据写入命令缓冲（command buffer） time .get_ticks_usec()获取godot主线程时间\nRenderingDevice(gl不支持) RENDER_TIMESTAMP 其实是引擎渲染管线里的一类 GPU 时间戳 (Timestamp) 标记。\n通过**RenderingDevice**可以获取某个阶段的时间戳。具体方法如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;godot_cpp/classes/rendering_server.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/rendering_device.hpp\u0026gt; using namespace godot; void dump_gpu_pass_times_ms() { Ref\u0026lt;RenderingDevice\u0026gt; rd = RenderingServer::get_singleton()-\u0026gt;get_rendering_device(); if (rd.is_null()) return; const uint32_t count = rd-\u0026gt;get_captured_timestamps_count(); // 采集到的标签数 const uint64_t frame = rd-\u0026gt;get_captured_timestamps_frame(); // 对应的帧号（可选） for (uint32_t i = 0; i \u0026lt; count; i++) { String name = rd-\u0026gt;get_captured_timestamp_name(i); // 例如 \u0026#34;Depth Prepass\u0026#34; double gpu_ms = rd-\u0026gt;get_captured_timestamp_gpu_time(i) / 1e6; // 纳秒→毫秒 double cpu_ms = rd-\u0026gt;get_captured_timestamp_cpu_time(i) / 1e6; // 你可以筛选/重命名/累加到自己的统计里 UtilityFunctions::print(vformat(\u0026#34;[%s] GPU %.3f ms, CPU %.3f ms (frame %d)\u0026#34;, name, gpu_ms, cpu_ms, (int)frame)); } } godott-benchmark godott-benchmark是godot官方提供的测试工程，它可以针对不同芯片，测试当前godot版本的各项功能耗时。\n可以利用它作为性能基准。\n渲染CPU：渲染每帧所花费的平均CPU时间（例如设置绘制调用）。这个度量不考虑过程/物理过程功能。 渲染GPU：每帧平均花费的GPU时间。 空闲：c++和GDScript进程函数每秒所花费的平均CPU时间。 物理：每秒在c++和GDScript物理处理函数中花费的平均CPU时间。 主线程时间：在主线程上设置场景所花费的时间。对于渲染基准测试，它作为加载时间度量。 ","date":"2025-11-05T09:18:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E5%9B%9B%E6%80%A7%E8%83%BD%E7%BB%9F%E8%AE%A1/","title":"【godot】四、性能统计"},{"content":"一、SRC编写 Godot中不推荐使用#pragma once，而是推荐使用**#ifndef**的方式，来保证头文件的单次引用，参考下方行1。 类内第一行，必须打上Godot的对应宏GDCLASS(SelfClass,BaseClass)，参考下方行12。 对于需要暴露到脚本的函数，需要在**_bind_methods**中用 ClassDB::bind_method进行绑定，参考行178、179 对于需要暴露到脚本的属性，需要在**_bind_methods中用ADD_PROPERTY**进行绑定，参考行181、182、183 对于需要暴露到脚本的枚举，需要用VARIANT_ENUM_CAST以及在**_bind_methods中用BIND_ENUM_CONSTANT**进行注册，参考行：63、166、199 对于需要暴露到脚本的位域，需要用VARIANT_BITFIELD_CAST以及在**_bind_methods中用BIND_BITFIELD_FLAG**进行注册，参考行：64、171、203 对于需要信号（回调），需要用ADD_SIGNAL注册并用emit_signal发送，以及可以用connect绑定，参考行：78、100、176 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/texture2d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: enum ETest{ None, Enum1, Enum2, Num }; enum EFlag{ FlagNone = 0, Flag1 = 1 \u0026lt;\u0026lt; 0, Flag2 = 1 \u0026lt;\u0026lt; 1, Flag3 = 1 \u0026lt;\u0026lt; 2, }; public: Test(); ~Test(); void StartTest(); void StartTest2(); int GetIValue(); void SetIValue(int input); float GetFValue(); void SetFValue(float input); String GetSValue(); void SetSValue(String input); Ref\u0026lt;Texture2D\u0026gt; GetTValue(); void SetTValue(Ref\u0026lt;Texture2D\u0026gt; input); ETest GetEValue(); void SetEValue(ETest input); BitField\u0026lt;EFlag\u0026gt; GetFlagValue(); void SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input); protected: static void _bind_methods(); private: int IValue = 0; float FValue = 0.0f; String SValue = \u0026#34;Hello\u0026#34;; Ref\u0026lt;Texture2D\u0026gt; TValue; ETest EValue = ETest::None; BitField\u0026lt;EFlag\u0026gt; flag = EFlag::FlagNone; }; VARIANT_ENUM_CAST(Test::ETest); VARIANT_BITFIELD_CAST(Test::EFlag); #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/image_texture.hpp\u0026gt; Test::Test() { connect(\u0026#34;ready\u0026#34;,Callable(this,\u0026#34;StartTest2\u0026#34;)); } Test::~Test() { } void Test::StartTest() { UtilityFunctions::print(\u0026#34;AAAAAAAAAAAAAAAA\u0026#34;); Ref\u0026lt;ImageTexture\u0026gt; AA(memnew(ImageTexture)); UtilityFunctions::print(\u0026#34;AAAAAAAAAAAAAAAA:\u0026#34;,AA-\u0026gt;get_reference_count()); auto format = AA-\u0026gt;get_format(); Ref\u0026lt;ImageTexture\u0026gt; BB = AA; UtilityFunctions::print(\u0026#34;AAAAAAAAAAAAAAAA:\u0026#34;,AA-\u0026gt;get_reference_count()); } void Test::StartTest2() { UtilityFunctions::print(\u0026#34;BBBBBBBBBBBBBBB:\u0026#34;,IValue); emit_signal(\u0026#34;HelloSignal\u0026#34;,\u0026#34;CCCCCCCCCCCCCCCCCCC\u0026#34;); // UtilityFunctions::print(\u0026#34;BBBBBBBBBBBBBBB:\u0026#34;,IValue,\u0026#34;---\u0026#34;,FValue,\u0026#34;---\u0026#34;,SValue,\u0026#34;---\u0026#34;,TValue-\u0026gt;get_name()); } int Test::GetIValue() { return IValue; } void Test::SetIValue(int input) { IValue = input; } float Test::GetFValue() { return FValue; } void Test::SetFValue(float input) { FValue = input; } String Test::GetSValue() { return SValue; } void Test::SetSValue(String input) { SValue = input; } Ref\u0026lt;Texture2D\u0026gt; Test::GetTValue() { return TValue; } void Test::SetTValue(Ref\u0026lt;Texture2D\u0026gt; input) { TValue = input; } Test::ETest Test::GetEValue() { return EValue; } void Test::SetEValue(ETest input) { EValue = input; } BitField\u0026lt;Test::EFlag\u0026gt; Test::GetFlagValue() { return flag; } void Test::SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input) { flag = input; } void Test::_bind_methods() { BIND_ENUM_CONSTANT(None); BIND_ENUM_CONSTANT(Enum1); BIND_ENUM_CONSTANT(Enum2); BIND_ENUM_CONSTANT(Num); BIND_BITFIELD_FLAG(FlagNone); BIND_BITFIELD_FLAG(Flag1); BIND_BITFIELD_FLAG(Flag2); BIND_BITFIELD_FLAG(Flag3); ADD_SIGNAL(MethodInfo(\u0026#34;HelloSignal\u0026#34;,PropertyInfo(Variant::STRING,\u0026#34;message\u0026#34;))); ClassDB::bind_method(D_METHOD(\u0026#34;StartTest\u0026#34;),\u0026amp;Test::StartTest); ClassDB::bind_method(D_METHOD(\u0026#34;StartTest2\u0026#34;),\u0026amp;Test::StartTest2); ClassDB::bind_method(D_METHOD(\u0026#34;GetIValue\u0026#34;),\u0026amp;Test::GetIValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetIValue\u0026#34;,\u0026#34;IValue\u0026#34;),\u0026amp;Test::SetIValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;IValue\u0026#34;),\u0026#34;SetIValue\u0026#34;,\u0026#34;GetIValue\u0026#34;); ClassDB::bind_method(D_METHOD(\u0026#34;GetFValue\u0026#34;),\u0026amp;Test::GetFValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetFValue\u0026#34;,\u0026#34;FValue\u0026#34;),\u0026amp;Test::SetFValue); ADD_PROPERTY(PropertyInfo(Variant::FLOAT,\u0026#34;FValue\u0026#34;),\u0026#34;SetFValue\u0026#34;,\u0026#34;GetFValue\u0026#34;); ClassDB::bind_method(D_METHOD(\u0026#34;GetSValue\u0026#34;),\u0026amp;Test::GetSValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetSValue\u0026#34;,\u0026#34;SValue\u0026#34;),\u0026amp;Test::SetSValue); ADD_PROPERTY(PropertyInfo(Variant::STRING,\u0026#34;SValue\u0026#34;),\u0026#34;SetSValue\u0026#34;,\u0026#34;GetSValue\u0026#34;); ClassDB::bind_method(D_METHOD(\u0026#34;GetTValue\u0026#34;),\u0026amp;Test::GetTValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetTValue\u0026#34;,\u0026#34;TValue\u0026#34;),\u0026amp;Test::SetTValue); ADD_PROPERTY(PropertyInfo(Variant::OBJECT,\u0026#34;TValue\u0026#34;,PROPERTY_HINT_RESOURCE_TYPE,\u0026#34;Texture2D\u0026#34;),\u0026#34;SetIValue\u0026#34;,\u0026#34;GetIValue\u0026#34;); ClassDB::bind_method(D_METHOD(\u0026#34;GetEValue\u0026#34;),\u0026amp;Test::GetEValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetEValue\u0026#34;,\u0026#34;EValue\u0026#34;),\u0026amp;Test::SetEValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;EValue\u0026#34;,PROPERTY_HINT_ENUM,\u0026#34;None , Enum1 , Enum2\u0026#34;),\u0026#34;SetEValue\u0026#34;,\u0026#34;GetEValue\u0026#34;); ClassDB::bind_method(D_METHOD(\u0026#34;GetFlagValue\u0026#34;),\u0026amp;Test::GetFlagValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetFlagValue\u0026#34;,\u0026#34;flag\u0026#34;),\u0026amp;Test::SetFlagValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;flag\u0026#34;,PROPERTY_HINT_FLAGS,\u0026#34;FlagNone , Flag1 , Flag2 , Flag3\u0026#34;),\u0026#34;SetFlagValue\u0026#34;,\u0026#34;GetFlagValue\u0026#34;); } （一）函数暴露 ​\t对于需要暴露到脚本的函数，需要在**_bind_methods**中用 ClassDB::bind_method进行绑定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: void StartTest(); protected: static void _bind_methods(); }; #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; void Test::StartTest() { UtilityFunctions::print(\u0026#34;StartTest:1111); } void Test::_bind_methods() { ClassDB::bind_method(D_METHOD(\u0026#34;StartTest\u0026#34;),\u0026amp;Test::StartTest); } （二）属性暴露 对于需要暴露到脚本的属性，需要在**_bind_methods中用ADD_PROPERTY进行绑定，同时需要暴露它对应的Get和Set**方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/texture2d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: enum ETest{ None, Enum1, Enum2, Num }; enum EFlag{ FlagNone = 0, Flag1 = 1 \u0026lt;\u0026lt; 0, Flag2 = 1 \u0026lt;\u0026lt; 1, Flag3 = 1 \u0026lt;\u0026lt; 2, }; public: int GetIValue(); void SetIValue(int input); Ref\u0026lt;Texture2D\u0026gt; GetTValue(); void SetTValue(Ref\u0026lt;Texture2D\u0026gt; input); ETest GetEValue(); void SetEValue(ETest input); BitField\u0026lt;EFlag\u0026gt; GetFlagValue(); void SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input); protected: static void _bind_methods(); private: int IValue = 0; Ref\u0026lt;Texture2D\u0026gt; TValue; ETest EValue = ETest::None; BitField\u0026lt;EFlag\u0026gt; flag = EFlag::FlagNone; }; VARIANT_ENUM_CAST(Test::ETest); VARIANT_BITFIELD_CAST(Test::EFlag); #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/image_texture.hpp\u0026gt; int Test::GetIValue() { return IValue; } void Test::SetIValue(int input) { IValue = input; } Ref\u0026lt;Texture2D\u0026gt; Test::GetTValue() { return TValue; } void Test::SetTValue(Ref\u0026lt;Texture2D\u0026gt; input) { TValue = input; } Test::ETest Test::GetEValue() { return EValue; } void Test::SetEValue(ETest input) { EValue = input; } BitField\u0026lt;Test::EFlag\u0026gt; Test::GetFlagValue() { return flag; } void Test::SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input) { flag = input; } void Test::_bind_methods() { //int变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetIValue\u0026#34;),\u0026amp;Test::GetIValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetIValue\u0026#34;,\u0026#34;IValue\u0026#34;),\u0026amp;Test::SetIValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;IValue\u0026#34;),\u0026#34;SetIValue\u0026#34;,\u0026#34;GetIValue\u0026#34;); //资源变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetTValue\u0026#34;),\u0026amp;Test::GetTValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetTValue\u0026#34;,\u0026#34;TValue\u0026#34;),\u0026amp;Test::SetTValue); ADD_PROPERTY(PropertyInfo(Variant::OBJECT,\u0026#34;TValue\u0026#34;,PROPERTY_HINT_RESOURCE_TYPE,\u0026#34;Texture2D\u0026#34;),\u0026#34;SetIValue\u0026#34;,\u0026#34;GetIValue\u0026#34;); //枚举变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetEValue\u0026#34;),\u0026amp;Test::GetEValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetEValue\u0026#34;,\u0026#34;EValue\u0026#34;),\u0026amp;Test::SetEValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;EValue\u0026#34;,PROPERTY_HINT_ENUM,\u0026#34;None , Enum1 , Enum2\u0026#34;),\u0026#34;SetEValue\u0026#34;,\u0026#34;GetEValue\u0026#34;); //位域变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetFlagValue\u0026#34;),\u0026amp;Test::GetFlagValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetFlagValue\u0026#34;,\u0026#34;flag\u0026#34;),\u0026amp;Test::SetFlagValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;flag\u0026#34;,PROPERTY_HINT_FLAGS,\u0026#34;FlagNone , Flag1 , Flag2 , Flag3\u0026#34;),\u0026#34;SetFlagValue\u0026#34;,\u0026#34;GetFlagValue\u0026#34;); } （三）枚举 对于需要暴露到脚本的枚举，需要用VARIANT_ENUM_CAST以及在**_bind_methods中用BIND_ENUM_CONSTANT**进行注册\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/texture2d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: enum ETest{ None, Enum1, Enum2, Num }; public: ETest GetEValue(); void SetEValue(ETest input); protected: static void _bind_methods(); private: ETest EValue = ETest::None; }; VARIANT_ENUM_CAST(Test::ETest); #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/image_texture.hpp\u0026gt; Test::ETest Test::GetEValue() { return EValue; } void Test::SetEValue(ETest input) { EValue = input; } void Test::_bind_methods() { BIND_ENUM_CONSTANT(None); BIND_ENUM_CONSTANT(Enum1); BIND_ENUM_CONSTANT(Enum2); BIND_ENUM_CONSTANT(Num); //枚举变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetEValue\u0026#34;),\u0026amp;Test::GetEValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetEValue\u0026#34;,\u0026#34;EValue\u0026#34;),\u0026amp;Test::SetEValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;EValue\u0026#34;,PROPERTY_HINT_ENUM,\u0026#34;None , Enum1 , Enum2\u0026#34;),\u0026#34;SetEValue\u0026#34;,\u0026#34;GetEValue\u0026#34;); } （四）位域 对于需要暴露到脚本的位域，需要用VARIANT_BITFIELD_CAST以及在**_bind_methods中用BIND_BITFIELD_FLAG**进行注册\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/texture2d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: enum EFlag{ FlagNone = 0, Flag1 = 1 \u0026lt;\u0026lt; 0, Flag2 = 1 \u0026lt;\u0026lt; 1, Flag3 = 1 \u0026lt;\u0026lt; 2, }; public: BitField\u0026lt;EFlag\u0026gt; GetFlagValue(); void SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input); protected: static void _bind_methods(); private: BitField\u0026lt;EFlag\u0026gt; flag = EFlag::FlagNone; }; VARIANT_BITFIELD_CAST(Test::EFlag); #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/image_texture.hpp\u0026gt; BitField\u0026lt;Test::EFlag\u0026gt; Test::GetFlagValue() { return flag; } void Test::SetFlagValue(BitField\u0026lt;EFlag\u0026gt; input) { flag = input; } void Test::_bind_methods() { BIND_BITFIELD_FLAG(FlagNone); BIND_BITFIELD_FLAG(Flag1); BIND_BITFIELD_FLAG(Flag2); BIND_BITFIELD_FLAG(Flag3); //位域变量 ClassDB::bind_method(D_METHOD(\u0026#34;GetFlagValue\u0026#34;),\u0026amp;Test::GetFlagValue); ClassDB::bind_method(D_METHOD(\u0026#34;SetFlagValue\u0026#34;,\u0026#34;flag\u0026#34;),\u0026amp;Test::SetFlagValue); ADD_PROPERTY(PropertyInfo(Variant::INT,\u0026#34;flag\u0026#34;,PROPERTY_HINT_FLAGS,\u0026#34;FlagNone , Flag1 , Flag2 , Flag3\u0026#34;),\u0026#34;SetFlagValue\u0026#34;,\u0026#34;GetFlagValue\u0026#34;); } （五）信号/回调 1、ADD_SIGNAL 对于需要信号（回调），需要用ADD_SIGNAL注册并用emit_signal发送，以及可以用connect绑定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //----------------头文件---------------- #ifndef TEST_H #define TEST_H #include \u0026lt;godot_cpp/classes/node3d.hpp\u0026gt; #include \u0026lt;godot_cpp/classes/texture2d.hpp\u0026gt; using namespace godot; class Test : public Node3D { GDCLASS(Test,Node3D) public: void StartTest2(); protected: static void _bind_methods(); }; #endif //----------------源文件---------------- #include \u0026#34;Test.h\u0026#34; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/variant/utility_functions.hpp\u0026gt; Test::Test() { connect(\u0026#34;ready\u0026#34;,Callable(this,\u0026#34;StartTest2\u0026#34;)); } void Test::StartTest2() { UtilityFunctions::print(\u0026#34;BBBBBBBBBBBBBBB:\u0026#34;,IValue); emit_signal(\u0026#34;HelloSignal\u0026#34;,\u0026#34;CCCCCCCCCCCCCCCCCCC\u0026#34;); } void Test::_bind_methods() { ADD_SIGNAL(MethodInfo(\u0026#34;HelloSignal\u0026#34;,PropertyInfo(Variant::STRING,\u0026#34;message\u0026#34;))); } 2、call_deferred 1 2 this-\u0026gt;call_deferred(\u0026#34;method_name\u0026#34;, arg1, arg2); //注意method_name方法需要被注册过才能正确调用 二、常用函数 （一）引用计数、memnew、memdelete 1 2 3 4 5 6 7 //godot对于内存管理有自己的封装，所以对于非原生类，需要用它定义的创建/删除方法。 memnew(ImageTexture); memdelete(); //一般使用引用计数来控制资源生命周期，而非手动管理 Ref\u0026lt;ImageTexture\u0026gt; AA(memnew(ImageTexture)); UtilityFunctions::print(\u0026#34;reference count:\u0026#34;,AA-\u0026gt;get_reference_count()); （二）计时器 1、Timer\n2、Tween\n轻量化的计时器，godot会自动回收。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 备注：没有内存泄漏风险。Ref自动管理了内存 Ref\u0026lt;Tween\u0026gt; tween = create_tween(); double Index = Duration / (2.0f * Times); // Times是闪烁次数也是循环次数，Index是闪烁间隔 for (int i = 0; i \u0026lt; Times; i++) { tween-\u0026gt;tween_property(this, \u0026#34;modulate:a\u0026#34;, 0.0f, Index); tween-\u0026gt;tween_property(this, \u0026#34;modulate:a\u0026#34;, 1.0f, Index); } if (true) { tween-\u0026gt;tween_property(this, \u0026#34;modulate:a\u0026#34;, 0.0f, Index); } tween-\u0026gt;set_trans(Tween::TRANS_LINEAR); 三、编辑器3D小工具插件Gizmo Gizmo是godot自带的编辑器界面的3D小工具。\n它是附加式的，即不会影响原节点，同时也不会被原节点所感知 支持点、线、网格的绘制 支持点击和拖拽事件 该功能主要由：控制器EditorNode3DGizmoPlugin，组件EditorNode3DGizmo。两大部分组成。但需要使用的话，就需要在统一的插件管理器中，进行注册和初始化。\n（一）、EditorNode3DGizmoPlugin EditorNode3DGizmoPlugin 是 Godot 编辑器中的一个 插件基类，用于扩展和注册自定义的 3D Gizmo 工具。它允许开发者在 3D 视口中为特定类型的节点绘制自定义辅助图形、控制柄、交互部件。\n注册 Gizmo 类型：关联到某个节点类（如 Camera3D、Light3D、自定义节点等） 生成 Gizmo 实例：通过 create_gizmo() 创建对应的 EditorNode3DGizmo 对象 定义外观与行为：create_handle_material（）、create_material（）等 注意事项： 当_has_gizmo被重载时，会根据返回的bool值，创建默认的EditorNode3DGizmo。 当__create_gizmo被重载时，创建自定义的EditorNode3DGizmo。 当他们同时被重载时，仅会生效__create_gizmo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 //======================头文件======================== #pragma once #ifndef SPLINE_GIZMO_PLUGIN_H #define SPLINE_GIZMO_PLUGIN_H #include \u0026#34;godot_cpp/classes/editor_node3d_gizmo_plugin.hpp\u0026#34; using namespace godot; class SplineGizmoPlugin : public EditorNode3DGizmoPlugin { GDCLASS(SplineGizmoPlugin, EditorNode3DGizmoPlugin); protected: static void _bind_methods(){} public: // virtual bool _has_gizmo(Node3D *p_for_node_3d) const override; virtual Ref\u0026lt;EditorNode3DGizmo\u0026gt; _create_gizmo(Node3D *p_for_node_3d) const override; virtual void _redraw(const Ref\u0026lt;EditorNode3DGizmo\u0026gt; \u0026amp;p_gizmo) override; virtual String _get_gizmo_name() const override{ return \u0026#34;SplineGizmo\u0026#34;; } // virtual int32_t _get_priority() const override{ // return -1; // } }; #endif //======================源文件======================== #include \u0026#34;SplineGizmoPlugin.h\u0026#34; #include \u0026#34;Spline.h\u0026#34; #include \u0026#34;SplineGizmo.h\u0026#34; #include \u0026#34;godot_cpp/classes/object.hpp\u0026#34; #include \u0026#34;godot_cpp/core/memory.hpp\u0026#34; #include \u0026#34;godot_cpp/variant/utility_functions.hpp\u0026#34; // bool SplineGizmoPlugin::_has_gizmo(Node3D *p_for_node_3d) const { // UtilityFunctions::print(\u0026#34;SplineGizmoPlugin::_has_gizmo :: AAAAAAAAAAAA\u0026#34;); // UtilityFunctions::print(__FUNCTION__,p_for_node_3d-\u0026gt;get_name()); // return Object::cast_to\u0026lt;Spline\u0026gt;(p_for_node_3d) != nullptr; // } Ref\u0026lt;EditorNode3DGizmo\u0026gt; SplineGizmoPlugin::_create_gizmo(Node3D *p_for_node_3d) const{ UtilityFunctions::print(\u0026#34;SplineGizmoPlugin::_create_gizmo :: Try to create gizmo for :: \u0026#34;,p_for_node_3d-\u0026gt;get_name()); bool bIsSpline = Object::cast_to\u0026lt;Spline\u0026gt;(p_for_node_3d) != nullptr; if (bIsSpline) { UtilityFunctions::print(\u0026#34;SplineGizmoPlugin::_create_gizmo :: \u0026#34;,p_for_node_3d-\u0026gt;get_name()); Ref\u0026lt;EditorNode3DGizmo\u0026gt; Gizmo = memnew(SplineGizmo(p_for_node_3d)); return Gizmo; } return nullptr; } void SplineGizmoPlugin::_redraw(const Ref\u0026lt;EditorNode3DGizmo\u0026gt; \u0026amp;p_gizmo){ UtilityFunctions::print(\u0026#34;SplineGizmoPlugin::_redraw :: \u0026#34; , p_gizmo-\u0026gt;get_node_3d()-\u0026gt;get_name()); p_gizmo-\u0026gt;_redraw(); } （二）、EditorNode3DGizmo EditorNode3DGizmo 是实际在 3D 视口中绘制和交互的对象。由 EditorNode3DGizmoPlugin 创建，它负责管理绘制内容和交互点。\n添加可见元素：通过 add_mesh()、add_lines()、add_unscaled_billboard() 等方法绘制不同类型的辅助几何\n添加交互句柄（Handles）：\nadd_handles() 用于添加可拖拽的控制点 在编辑器中用户可以直接用鼠标操作这些点 交互与更新\n在插件中重写 redraw(gizmo)，可根据节点属性变化实时刷新 使用 set_handle() 与 commit_handle() 响应用户操作，将变动写回节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 //======================头文件======================== #pragma once #ifndef SPLINE_GIZMO_H #define SPLINE_GIZMO_H #include \u0026#34;Spline.h\u0026#34; #include \u0026#34;godot_cpp/classes/node3d.hpp\u0026#34; // #include \u0026#34;godot_cpp/classes/editor_node3d_gizmo_plugin.hpp\u0026#34; #include \u0026#34;godot_cpp/classes/editor_node3d_gizmo.hpp\u0026#34; // #include \u0026#34;godot_cpp/classes/node3d_gizmo.hpp\u0026#34; #include \u0026#34;godot_cpp/classes/camera3d.hpp\u0026#34; using namespace godot; class SplineGizmo : public EditorNode3DGizmo { GDCLASS(SplineGizmo, EditorNode3DGizmo); protected: static void _bind_methods(){} public: SplineGizmo(){} SplineGizmo(Node3D *p_node); ~SplineGizmo(); virtual void _redraw() override; virtual void _commit_handle(int32_t p_id, bool p_secondary, const Variant \u0026amp;p_restore, bool p_cancel) override; virtual void _set_handle(int32_t p_id, bool p_secondary, Camera3D *p_camera, const Vector2 \u0026amp;p_point) override; private: Spline * SplineInstance; Ref\u0026lt;Material\u0026gt; RedMaterial; Ref\u0026lt;Material\u0026gt; GreenMaterial; Ref\u0026lt;Material\u0026gt; BlueMaterial; }; #endif //======================源文件======================== #include \u0026#34;SplineGizmo.h\u0026#34; #include \u0026#34;Spline.h\u0026#34; #include \u0026#34;godot_cpp/classes/object.hpp\u0026#34; #include \u0026#34;godot_cpp/classes/editor_node3d_gizmo_plugin.hpp\u0026#34; #include \u0026#34;godot_cpp/classes/standard_material3d.hpp\u0026#34; #include \u0026#34;godot_cpp/core/error_macros.hpp\u0026#34; #include \u0026#34;godot_cpp/core/memory.hpp\u0026#34; #include \u0026#34;godot_cpp/variant/array.hpp\u0026#34; #include \u0026#34;godot_cpp/variant/utility_functions.hpp\u0026#34; #include \u0026#34;godot_cpp/variant/vector3.hpp\u0026#34; SplineGizmo::SplineGizmo(Node3D *p_node){ set_node_3d(p_node); SplineInstance = Object::cast_to\u0026lt;Spline\u0026gt;(p_node); } SplineGizmo::~SplineGizmo(){ } void SplineGizmo::_redraw(){ UtilityFunctions::print(__FUNCTION__,\u0026#34;redraw::CCCCCCC :: \u0026#34;,get_node_3d()-\u0026gt;get_name()); clear(); PackedVector3Array points; PackedInt32Array ids; PackedVector3Array lines; ERR_FAIL_COND(!SplineInstance); int numPoints = SplineInstance-\u0026gt;GetControlPoints().size(); ERR_FAIL_COND(numPoints == 0); for (int i = 0; i \u0026lt; numPoints; i++) { Vector3 CurPoint = SplineInstance-\u0026gt;GetControlPoints()[i]; points.append(CurPoint); ids.append(i); } int segNum = 100; Array TempP = SplineInstance-\u0026gt;GetBezierCurve(segNum); for (int i = 0; i \u0026lt; segNum - 1; i++) { Vector3 CurPoint0 = TempP[i]; Vector3 CurPoint1 = TempP[i + 1]; lines.append(CurPoint0); lines.append(CurPoint1); } add_handles(points, get_plugin()-\u0026gt;get_material(\u0026#34;HandleMat\u0026#34;,this),ids); add_lines(lines, get_plugin()-\u0026gt;get_material(\u0026#34;RedMat\u0026#34;,this)); } void SplineGizmo::_commit_handle(int32_t p_id, bool p_secondary, const Variant \u0026amp;p_restore, bool p_cancel){ UtilityFunctions::print(\u0026#34;SplineGizmo::_commit_handle :: id :: \u0026#34;, p_id , \u0026#34; , Restore :: \u0026#34;, p_restore ,\u0026#34;NewPosition :: \u0026#34;); } void SplineGizmo::_set_handle(int32_t p_id, bool p_secondary, Camera3D *p_camera, const Vector2 \u0026amp;p_point){ // UtilityFunctions::print(\u0026#34;SplineGizmo::_set_handle :: id :: \u0026#34;, p_id , \u0026#34; , Screen Point :: \u0026#34;, p_point ); if (!SplineInstance || !p_camera ) { return; } Array points = SplineInstance-\u0026gt;GetControlPoints(); Vector3 LocalLocation = points[p_id]; Vector3 WorldLocation = SplineInstance-\u0026gt;get_transform().xform(LocalLocation); UtilityFunctions::print(\u0026#34;LocalLocation :: \u0026#34;, LocalLocation , \u0026#34; , WorldLocation :: \u0026#34;, WorldLocation ); const Vector3 ray_o = p_camera-\u0026gt;project_ray_origin(p_point); const Vector3 ray_d = p_camera-\u0026gt;project_ray_normal(p_point); // UtilityFunctions::print(\u0026#34;SplineGizmo::_set_handle :: id :: \u0026#34;, p_id , \u0026#34; , ray_o :: \u0026#34;,ray_o,\u0026#34; , ray_d :: \u0026#34;,ray_d); // 构造“屏幕平面”：过当前把手点，法线 = 相机前向（-Z 列） const Vector3 cam_fwd = -p_camera-\u0026gt;get_global_transform().basis.get_column(2).normalized(); Plane view_plane(cam_fwd, WorldLocation); // UtilityFunctions::print(\u0026#34;cam_fwd :: \u0026#34;, cam_fwd ); Vector3 hit; if (!view_plane.intersects_ray(ray_o, ray_d, \u0026amp;hit)) { // 射线与平面近平行，忽略这帧 return; } UtilityFunctions::print(\u0026#34;Hit :: \u0026#34;,hit); points[p_id] = SplineInstance-\u0026gt;get_transform().xform_inv(hit); SplineInstance-\u0026gt;SetControlPoints(points); _redraw(); } （三）、EditorPlugin EditorPlugin 是 Godot 中所有编辑器插件的基类，负责：\n注册和卸载 EditorNode3DGizmoPlugin 处理插件的生命周期 与编辑器 UI、场景树、Inspector 等交互 接口 作用 说明 add_node_3d_gizmo_plugin 把自定义 Gizmo 插件注册到编辑器 remove_node_3d_gizmo_plugin 把自定义 Gizmo 插件移除 enable_plugin 开启插件 disable_plugin 关闭插件 handles 判断是否接管某类型节点的编辑逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 //=================类的定义======================= class MyEditorPlugin : public EditorPlugin { GDCLASS(MyEditorPlugin, EditorPlugin); Ref\u0026lt;SplineGizmoPlugin\u0026gt; gizmo_plugin; protected: static void _bind_methods() { } public: virtual void _enter_tree() override { UtilityFunctions::print(\u0026#34;Init :: MyEditorPlugin :: _enter_tree\u0026#34;); gizmo_plugin.instantiate(); gizmo_plugin-\u0026gt;create_handle_material(\u0026#34;HandleMat\u0026#34;); gizmo_plugin-\u0026gt;create_material(\u0026#34;RedMat\u0026#34;, Color(1.0f, 0.0f, 0.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;GreenMat\u0026#34;, Color(0.0f, 1.0f, 0.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;BlueMat\u0026#34;, Color(0.0f, 0.0f, 1.0f)); add_node_3d_gizmo_plugin(gizmo_plugin); } virtual void _exit_tree() override { UtilityFunctions::print(\u0026#34;UnInit :: MyEditorPlugin :: _exit_tree\u0026#34;); remove_node_3d_gizmo_plugin(gizmo_plugin); } }; //==================使用示例======================= //==================register_types.cpp======================= void initialize_GodotTest_module(ModuleInitializationLevel p_level) { if (p_level == MODULE_INITIALIZATION_LEVEL_SCENE) { UtilityFunctions::print(\u0026#34;Init :: Scene\u0026#34;); GDREGISTER_CLASS(FowTexture); GDREGISTER_CLASS(Spline); } if (p_level == MODULE_INITIALIZATION_LEVEL_EDITOR) { UtilityFunctions::print(\u0026#34;Init :: Editor\u0026#34;); GDREGISTER_CLASS(SplineGizmo); GDREGISTER_CLASS(SplineGizmoPlugin); GDREGISTER_CLASS(MyEditorPlugin); EditorPlugins::add_by_type\u0026lt;MyEditorPlugin\u0026gt;(); } UtilityFunctions::print(\u0026#34;Init :: None :: \u0026#34;, p_level); } ","date":"2025-11-04T16:38:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E4%B8%89gdextension%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","title":"【godot】三、GDExtension开发指南"},{"content":"Modules开发指南 本文档是针对Godot 4.4引擎的 Modules开发指南，为需要进行底层开发的开发者提供实用的参考。Godot Modules开发允许我们直接在引擎源码层面扩展功能，相比GDExtension具有更强大的能力和更深度的集成。本文涵盖了日志打印、容器类型、GUI组件、线程管理、配置系统等核心模块的常用头文件和最小使用示例，帮助你快速上手 Godot 引擎的 C++ 开发。\n常用功能 编译期宏开关 名称 作用 TOOLS_ENABLED 只在编辑器/工具链里需要的代码 WINDOWS_ENABLED Windows 平台 ANDROID_ENABLED Android 平台 GLES3_ENABLED GLES3 渲染后端 VULKAN_ENABLED Vulkan 渲染后端 日志打印 头文件：#include \u0026ldquo;core/string/print_string.h\u0026rdquo;\n用于标准日志的输出。在做引擎开发时使用。\n在做GDExtension开发时，使用Utility_function头文件，进行日志打印。\n接口 作用 示例 void print_line(const Variant \u0026amp;v） 打印日志 __print_line(\u0026ldquo;AAA\u0026rdquo;,10.0); void print_error(const String \u0026amp;p_string) 打印错误 print_error(\u0026ldquo;BBBB\u0026rdquo;) 计时器 1 2 3 4 5 6 7 8 9 //1.通过场景树（mainloop）设置简单的时间回调函数 // timer to show text for 3 seconds auto timer = get_scene_tree()-\u0026gt;create_timer(time); timer-\u0026gt;connect(\u0026#34;timeout\u0026#34;, callable_mp(this,\u0026amp;CommandTool::reduce_screen_output_buffer)); //2.c++原生的线程调用也可以实现，但是需要call_deferred来回到主线程 //3.tween，更加复杂，但是可以链式调用，以及设置缓动 自定义项目配置 头文件：#include \u0026ldquo;core/config/project_settings.h\u0026rdquo;\nProjectSettings是 Godot引擎的核心单例类，负责管理项目的配置和设置。它继承自Object，使用 GDCLASS 宏注册到 Godot 的类型系统中\n核心职责：\n加载和保存项目配置文件（project.godot） 定义全局设置（带默认值）:GLOBAL_DEF 定义为基础设置（在编辑器中高亮）:GLOBAL_DEF_BASIC 定义全局设置（修改后需要重启）:GLOBAL_DEF_RST 定义为内部设置（不在编辑器显示）:GLOBAL_DEF_INTERNAL 获取配置值: get_setting 设置配置值: set_setting 检查配置值是否存在: has_setting 路径转换（res://、user:// 等路径本地化） 将绝对路径转换为 res:// 路径: localize_path 将 res:// 路径转换为绝对路径: globalize_path 获取项目资源路径（res:// 的实际位置）: get_resource_path 获取项目数据目录路径（res://.godot): get_project_data_path 获取导入文件路径（res://.godot/imported）: get_imported_files_path Autoload 单例管理 添加自动加载项:add_autoload 移除自动加载项:remove_autoload 检查是否存在:has_autoload 获取自动加载列表:get_autoload_list 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 void initialize_command_tool_module(ModuleInitializationLevel p_level) { if (p_level == MODULE_INITIALIZATION_LEVEL_SCENE) { GLOBAL_DEF(\u0026#34;MySelfConfig/test111/testBool1\u0026#34;, false); GLOBAL_DEF(\u0026#34;MySelfConfig/test111/testBool2\u0026#34;, true); GLOBAL_DEF(\u0026#34;MySelfConfig/test111/testfloat\u0026#34;, 3.0); GLOBAL_DEF(\u0026#34;MySelfConfig/test111/testString\u0026#34;, \u0026#34;this is a string\u0026#34;); GLOBAL_DEF(\u0026#34;MySelfConfig/test111/test_VECTOR2\u0026#34;, Vector2()); //COLOR GLOBAL_DEF(\u0026#34;MySelfConfig/test111/test_Color\u0026#34;, Color()); GLOBAL_DEF(\u0026#34;MySelfConfig/test111/test_Array\u0026#34;, Array()); GLOBAL_DEF(\u0026#34;MySelfConfig/test111/test_Dictionary\u0026#34;, Dictionary()); } } 容器 Godot脚本容器 Array ✨头文件:#include \u0026quot;core/variant/array.h\u0026quot;\n✨作用:Array是脚本GDScript中Array类型的C++实现。具有以下特点:\n通用性：它是一个存储Variant的容器，这意味着同一个数组里可以混合存放整数、字符串、对象引用等。 类型化数组（Typed Array）： Godot 4.0 引入了类型化数组的概念，C++ 端可以通过 set_typed 等方法限制数组只能存储特定类型。 ✨使用示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026#34;core/variant/array.h\u0026#34; #include \u0026#34;core/variant/variant.h\u0026#34; void demo_array() { // --- 创建 (Create) --- Array arr; // 也可以创建并指定为特定类型的数组（例如只存 int） // Array typed_arr; // typed_arr.set_typed(Variant::INT, StringName(), Variant()); // --- 增 (Add) --- arr.push_back(10); // 自动封装为 Variant(10) arr.append(\u0026#34;Hello\u0026#34;); // 自动封装为 Variant(\u0026#34;Hello\u0026#34;) arr.push_front(3.14); // 插入到头部 // 此时数组内容可能为: [3.14, 10, \u0026#34;Hello\u0026#34;] // --- 查 (Read) --- if (!arr.is_empty()) { // operator[] 返回的是 Variant \u0026amp; Variant v = arr[0]; // 需要根据类型转换 if (v.get_type() == Variant::FLOAT) { double d = v; // 自动转型操作符 print_line(rtos(d)); } } // 遍历 for (int i = 0; i \u0026lt; arr.size(); i++) { Variant item = arr[i]; // print_line(item); // Variant 重载了 String 转换 } // --- 改 (Update) --- arr[1] = \u0026#34;New Value\u0026#34;; // 将索引 1 的 10 改为字符串 // --- 删 (Delete) --- arr.remove_at(0); // 移除第一个元素 arr.erase(\u0026#34;New Value\u0026#34;); // 移除匹配值的元素（线性查找） arr.clear(); } Dictionary ✨头文件:#include \u0026quot;core/variant/dictionary.h\u0026quot;\n✨作用:键值对均为Variant的字典,具有以下特点:\n基于哈希表 插入顺序保留 ✨使用示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026#34;core/variant/dictionary.h\u0026#34; #include \u0026#34;core/variant/variant.h\u0026#34; void demo_dictionary() { // --- 创建 (Create) --- Dictionary dict; // --- 增 (Add) / 改 (Update) --- dict[\u0026#34;name\u0026#34;] = \u0026#34;Godot\u0026#34;; // 键是 String, 值是 String dict[100] = \u0026#34;One Hundred\u0026#34;; // 键是 int, 值是 String // 也可以作为左值修改 dict[\u0026#34;name\u0026#34;] = \u0026#34;Godot Engine\u0026#34;; // --- 查 (Read) --- // 检查键是否存在 if (dict.has(\u0026#34;name\u0026#34;)) { Variant v = dict[\u0026#34;name\u0026#34;]; String s = v; print_line(s); } // 安全获取（带默认值） // 如果 \u0026#34;score\u0026#34; 不存在，返回 0 int score = dict.get(\u0026#34;score\u0026#34;, 0); // 遍历 // 注意：遍历字典通常遍历的是 Key List\u0026lt;Variant\u0026gt; keys; dict.get_key_list(\u0026amp;keys); // 获取所有 key 到一个 List 中 for (const Variant \u0026amp;key : keys) { Variant value = dict[key]; print_line(String(key) + \u0026#34; : \u0026#34; + String(value)); } // --- 删 (Delete) --- dict.erase(100); // 删除键为 100 的条目 bool removed = dict.erase(\u0026#34;name\u0026#34;); // 返回是否删除成功 } Godot底层容器 Vector\u0026lt;T\u0026gt; ✨头文件:#include \u0026quot;core/templates/vector.h\u0026quot;\n✨作用:数组容器,具有以下特点:\n连续内存，类似 std::vector 频繁随机访问、遍历时性能好 ✨使用示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Vector\u0026lt;int\u0026gt; v; // 增：尾部插入 v.push_back(10); v.push_back(20); v.push_back(30); // 查：按下标访问 int x = v[1]; // 20 int size = v.size(); // 3 // 改：修改某个元素 v.write[1] = 200; // Godot 4 的 Vector 用 write[] // 有些版本是 `v.set(1, 200);` // 或 `v[1] = 200`（取决于绑定） // 查：遍历 for (int i = 0; i \u0026lt; v.size(); i++) { print_line(v[i]); } // 删：按下标删除 v.remove_at(0); // 删除第 0 个元素，现在内容 [200, 30] // 查：是否包含某值（简单类型可以这样） int idx = v.find(30); // 找到则返回 index，否则 -1 if (idx != -1) { print_line(\u0026#34;found 30 at \u0026#34;, idx); } VMap\u0026lt;K,V\u0026gt; ✨头文件:#include \u0026quot;core/templates/vector.h\u0026quot;\n✨作用:基于Vector实现的关联容器（Map）它内部维护一个按照Key排序的Vector.具有以下特点\n内存连续，缓存友好（Cache Friendly）。 查找使用二分查找，时间复杂度为𝑂(log𝑁) 插入和删除需要移动元素，时间复杂度为O(N)。 ✨使用示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026#34;core/templates/vmap.h\u0026#34; void demo_vmap() { VMap\u0026lt;int, String\u0026gt; player_names; // --- 增 (Add) --- // 注意：insert 会检查键是否存在，存在则覆盖，不存在则保持排序插入 player_names.insert(1, \u0026#34;Alice\u0026#34;); player_names.insert(2, \u0026#34;Bob\u0026#34;); player_names.insert(10, \u0026#34;Boss\u0026#34;); // --- 查 (Read) --- // 检查是否存在 if (player_names.has(2)) { // 获取值，如果 key 不存在会 crash，所以最好先检查 has String name = player_names.get(2); // 或者使用 getptr，如果不存在返回 nullptr const String *name_ptr = player_names.getptr(2); } // 查找索引（用于遍历内部 vector） int idx = player_names.find(10); // 返回内部 vector 的 index if (idx != -1) { // 通过 vector 索引访问 String val = player_names.get_value_at_index(idx); } // --- 改 (Update) --- player_names.insert(1, \u0026#34;AliceUpdated\u0026#34;); // insert 兼具更新功能 // 如果你有索引，也可以通过索引改 // player_names.get_value_at_index(0) = \u0026#34;NewName\u0026#34;; // --- 删 (Delete) --- player_names.erase(10); // 移除 key 为 10 的元素 } List\u0026lt;T\u0026gt; ✨头文件:``\n✨作用:\n非连续内存： 节点散落在内存中，通过指针连接。 插入/删除快： 在头部、尾部或任意已知节点处插入/删除元素是 $O(1)$ 操作。 随机访问慢： 想要访问第 N 个元素（list[N]），必须从头遍历，是 $O(N)$ 操作。这是它和 Vector 最大的区别。 迭代器： 使用 List::Element * 指针作为迭代器 ✨使用示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026#34;core/templates/list.h\u0026#34; #include \u0026#34;core/string/ustring.h\u0026#34; void demo_list() { // --- 1. 创建 (Create) --- List\u0026lt;String\u0026gt; chat_log; // --- 2. 增 (Add) --- // 尾部添加 O(1) chat_log.push_back(\u0026#34;Player joined\u0026#34;); chat_log.push_back(\u0026#34;Player said: Hello\u0026#34;); // 头部添加 O(1) - 适合做队列 chat_log.push_front(\u0026#34;System: Welcome\u0026#34;); // 在特定位置插入 // List 的插入通常依赖于 Element 指针 List\u0026lt;String\u0026gt;::Element *E = chat_log.front(); // 获取第一个节点 (\u0026#34;System: Welcome\u0026#34;) if (E) { // 在第一个节点后面插入 chat_log.insert_after(E, \u0026#34;System: Message of the day\u0026#34;); } // 此时顺序: // [0] System: Welcome // [1] System: Message of the day // [2] Player joined // [3] Player said: Hello // --- 3. 查 (Read) --- // A. 访问头尾 O(1) if (!chat_log.is_empty()) { String first = chat_log.front()-\u0026gt;get(); String last = chat_log.back()-\u0026gt;get(); } // B. 遍历 (推荐方式 1: 范围 for 循环 - Godot 4.x) for (const String \u0026amp;msg : chat_log) { print_line(\u0026#34;Log: \u0026#34; + msg); } // C. 遍历 (传统方式/手动方式: 使用 Element 指针) // 这种方式在你需要操作节点(如删除当前节点)时很有用 for (List\u0026lt;String\u0026gt;::Element *E = chat_log.front(); E; E = E-\u0026gt;next()) { // E 是节点指针，E-\u0026gt;get() 获取值 if (E-\u0026gt;get() == \u0026#34;Player joined\u0026#34;) { print_line(\u0026#34;Found join event!\u0026#34;); } } // D. 随机访问 (警告：极慢！) // List 重载了 []，但它是 O(N) 的，不建议在循环中使用 // String val = chat_log[2]; // 性能差，慎用 // --- 4. 改 (Update) --- // 通过节点指针直接修改 List\u0026lt;String\u0026gt;::Element *msg_node = chat_log.back(); if (msg_node) { msg_node-\u0026gt;get() = \u0026#34;Player said: Bye\u0026#34;; // 修改值 } // --- 5. 删 (Delete) --- // A. 移除头尾 O(1) chat_log.pop_front(); // 移除第一个 chat_log.pop_back(); // 移除最后一个 // B. 移除特定值 O(N) - 需要查找 chat_log.erase(\u0026#34;Player joined\u0026#34;); // C. 通过迭代器移除 O(1) - 最高效的中间删除方式 List\u0026lt;String\u0026gt;::Element *node_to_delete = chat_log.front(); // 假设我们找到了要删的节点指针 if (node_to_delete) { chat_log.erase(node_to_delete); // 直接把这个节点摘除 } // 清空 chat_log.clear(); } VSet\u0026lt;T\u0026gt; ✨头文件:#include \u0026quot;core/templates/vset.h\u0026quot;\n✨作用:类似std::set, 内存紧凑，二分查找，不支持重复元素。 ✨使用示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026#34;core/templates/vset.h\u0026#34; void demo_vset() { VSet\u0026lt;int\u0026gt; unique_ids; // --- 增 (Add) --- unique_ids.insert(50); unique_ids.insert(10); unique_ids.insert(50); // 重复插入无效，集合中只有一个 50 // 此时内部状态为有序：[10, 50] // --- 查 (Read) --- if (unique_ids.has(10)) { print_line(\u0026#34;ID 10 exists\u0026#34;); } // 查找索引 int idx = unique_ids.find(50); // 返回 1 // 遍历 for (int i = 0; i \u0026lt; unique_ids.size(); i++) { int val = unique_ids[i]; // 像数组一样访问 } // --- 改 (Update) --- // Set 通常不直接修改元素值（因为这会破坏排序）， // 而是先 erase 旧值，再 insert 新值。 // --- 删 (Delete) --- unique_ids.erase(10); } HashMap\u0026lt;K,V\u0026gt; ✨头文件:#include \u0026quot;core/templates/hash_map.h\u0026quot;\n✨作用:基于哈希表实现,具有以下特点:\n平均查找、插入、删除时间复杂度为O(1)。 无序（遍历顺序不确定）。 适用场景： 需要快速查找大量数据，且不关心遍历顺序 ✨使用示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026#34;core/templates/hash_map.h\u0026#34; void demo_hashmap() { HashMap\u0026lt;String, int\u0026gt; inventory; // --- 增 (Add) / 改 (Update) --- inventory.insert(\u0026#34;Apple\u0026#34;, 5); inventory[\u0026#34;Banana\u0026#34;] = 10; // 类似 std::map，如果不存在则创建，存在则更新 inventory.insert(\u0026#34;Apple\u0026#34;, 8); // 更新 Apple 的值为 8 // --- 查 (Read) --- if (inventory.has(\u0026#34;Banana\u0026#34;)) { int count = inventory[\u0026#34;Banana\u0026#34;]; // 获取值 } // 使用 find 获取迭代器/指针，避免两次哈希计算 HashMap\u0026lt;String, int\u0026gt;::Iterator E = inventory.find(\u0026#34;Apple\u0026#34;); if (E) { int val = E-\u0026gt;value; // E-\u0026gt;key 获取键 } // 遍历 for (const KeyValue\u0026lt;String, int\u0026gt; \u0026amp;E : inventory) { print_line(E.key + \u0026#34;: \u0026#34; + itos(E.value)); } // --- 删 (Delete) --- inventory.erase(\u0026#34;Banana\u0026#34;); // 如果存在则删除 bool removed = inventory.remove(\u0026#34;Apple\u0026#34;); // remove 也是删除 } RBMap 红黑树,有序遍历性能好\nRBSet class_db 路径：#include \u0026ldquo;core/object/class_db.h\u0026rdquo;\n在_bind_methods中进行类型和函数注册的时候，使用到的类型注册函数就来自该头文件\n接口 作用 示例 ClassDB::bind_method 注册函数到脚本 ClassDB::bind_method(D_METHOD(\u0026ldquo;test_print\u0026rdquo;), \u0026amp;CommandTool::test_print); OS 路径：#include \u0026ldquo;sence/gui/xxx.h\u0026rdquo;\n提供了一系列操作系统层级的API，比如打印日、获取引擎运行时长等。\n接口 作用 示例 get_ticks_usec 获取引擎运行时长，单位为微秒 get_ticks_msec 获取引擎运行时长，单位为毫秒 callable 路径：#include \u0026ldquo;core/variant/callable.h\u0026rdquo;\ngodot自身提供了一套用于安全、类型检查的函数回调机制，也就是Callable，在进行信号连接时，我们就需要使用到它。\n类似 C++ 的 std::function\u0026lt;void()\u0026gt;，但它能在 Godot 对象系统中序列化、连接信号、跨语言调用。\n1 2 3 4 5 //基础构造函数，注意此处的method需要在_bind_method中被注册才能够通过字符串访问。 Callable c = Callable(this, \u0026#34;_on_something\u0026#34;); //更安全高效的绑定 Callable c = callable_mp(this, \u0026amp;MyClass::_on_timeout); gui 基础路径：#include \u0026ldquo;sence/gui/xxx.h\u0026rdquo;\nGUI基础类 Control 接口 作用 右对齐 set_mouse_filter 设置鼠标/点击行为 STOP PASS IGNORE err_dialog_control-\u0026gt;set_custom_minimum_size(Size2(600, 600) * EDSCALE);\nerr_dialog_control-\u0026gt;connect(SceneStringName(draw), callable_mp(this, \u0026amp;LyfTestEditor::test_draw));\nerr_dialog_control-\u0026gt;draw_line(Point2(0,0), Point2(100,100),Color(1,0,0));\nCanvasItem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void draw_dashed_line(const Point2 \u0026amp;p_from, const Point2 \u0026amp;p_to, const Color \u0026amp;p_color, real_t p_width = -1.0, real_t p_dash = 2.0, bool p_aligned = true, bool p_antialiased = false); void draw_line(const Point2 \u0026amp;p_from, const Point2 \u0026amp;p_to, const Color \u0026amp;p_color, real_t p_width = -1.0, bool p_antialiased = false); void draw_polyline(const Vector\u0026lt;Point2\u0026gt; \u0026amp;p_points, const Color \u0026amp;p_color, real_t p_width = -1.0, bool p_antialiased = false); void draw_polyline_colors(const Vector\u0026lt;Point2\u0026gt; \u0026amp;p_points, const Vector\u0026lt;Color\u0026gt; \u0026amp;p_colors, real_t p_width = -1.0, bool p_antialiased = false); void draw_arc(const Vector2 \u0026amp;p_center, real_t p_radius, real_t p_start_angle, real_t p_end_angle, int p_point_count, const Color \u0026amp;p_color, real_t p_width = -1.0, bool p_antialiased = false); void draw_multiline(const Vector\u0026lt;Point2\u0026gt; \u0026amp;p_points, const Color \u0026amp;p_color, real_t p_width = -1.0, bool p_antialiased = false); void draw_multiline_colors(const Vector\u0026lt;Point2\u0026gt; \u0026amp;p_points, const Vector\u0026lt;Color\u0026gt; \u0026amp;p_colors, real_t p_width = -1.0, bool p_antialiased = false); void draw_rect(const Rect2 \u0026amp;p_rect, const Color \u0026amp;p_color, bool p_filled = true, real_t p_width = -1.0, bool p_antialiased = false); void draw_circle(const Point2 \u0026amp;p_pos, real_t p_radius, const Color \u0026amp;p_color, bool p_filled = true, real_t p_width = -1.0, bool p_antialiased = false); void draw_texture(const Ref\u0026lt;Texture2D\u0026gt; \u0026amp;p_texture, const Point2 \u0026amp;p_pos, const Color \u0026amp;p_modulate = Color(1, 1, 1, 1)); void draw_texture_rect(const Ref\u0026lt;Texture2D\u0026gt; \u0026amp;p_texture, const Rect2 \u0026amp;p_rect, bool p_tile = false, const Color \u0026amp;p_modulate = Color(1, 1, 1), bool p_transpose = false); void draw_texture_rect_region(const Ref\u0026lt;Texture2D\u0026gt; \u0026amp;p_texture, const Rect2 \u0026amp;p_rect, const Rect2 \u0026amp;p_src_rect, const Color \u0026amp;p_modulate = Color(1, 1, 1), bool p_transpose = false, bool p_clip_uv = false); void draw_msdf_texture_rect_region(const Ref\u0026lt;Texture2D\u0026gt; \u0026amp;p_texture, const Rect2 \u0026amp;p_rect, const Rect2 \u0026amp;p_src_rect, const Color \u0026amp;p_modulate = Color(1, 1, 1), double p_outline = 0.0, double p_pixel_range = 4.0, double p_scale = 1.0); void draw_lcd_texture_rect_region(const Ref\u0026lt;Texture2D\u0026gt; \u0026amp;p_texture, const Rect2 \u0026amp;p_rect, const Rect2 \u0026amp;p_src_rect, const Color \u0026amp;p_modulate = Color(1, 1, 1)); void draw_style_box(const Ref\u0026lt;StyleBox\u0026gt; \u0026amp;p_style_box, const Rect2 \u0026amp;p_rect); void draw_primitive(const Vector\u0026lt;Point2\u0026gt; \u0026amp;p_points, const Vector\u0026lt;Color\u0026gt; \u0026amp;p_colors, const Vector\u0026lt;Point2\u0026gt; \u0026amp;p_uvs, Ref\u0026lt;Texture2D\u0026gt; p_texture = Ref\u0026lt;Texture2D\u0026gt;()); void draw_polygon(const Vector\u0026lt;Point2\u0026gt; \u0026amp;p_points, const Vector\u0026lt;Color\u0026gt; \u0026amp;p_colors, const Vector\u0026lt;Point2\u0026gt; \u0026amp;p_uvs = Vector\u0026lt;Point2\u0026gt;(), Ref\u0026lt;Texture2D\u0026gt; p_texture = Ref\u0026lt;Texture2D\u0026gt;()); void draw_colored_polygon(const Vector\u0026lt;Point2\u0026gt; \u0026amp;p_points, const Color \u0026amp;p_color, const Vector\u0026lt;Point2\u0026gt; \u0026amp;p_uvs = Vector\u0026lt;Point2\u0026gt;(), Ref\u0026lt;Texture2D\u0026gt; p_texture = Ref\u0026lt;Texture2D\u0026gt;()); void draw_mesh(const Ref\u0026lt;Mesh\u0026gt; \u0026amp;p_mesh, const Ref\u0026lt;Texture2D\u0026gt; \u0026amp;p_texture, const Transform2D \u0026amp;p_transform = Transform2D(), const Color \u0026amp;p_modulate = Color(1, 1, 1)); void draw_multimesh(const Ref\u0026lt;MultiMesh\u0026gt; \u0026amp;p_multimesh, const Ref\u0026lt;Texture2D\u0026gt; \u0026amp;p_texture); void draw_string(const Ref\u0026lt;Font\u0026gt; \u0026amp;p_font, const Point2 \u0026amp;p_pos, const String \u0026amp;p_text, HorizontalAlignment p_alignment = HORIZONTAL_ALIGNMENT_LEFT, float p_width = -1, int p_font_size = Font::DEFAULT_FONT_SIZE, const Color \u0026amp;p_modulate = Color(1.0, 1.0, 1.0), BitField\u0026lt;TextServer::JustificationFlag\u0026gt; p_jst_flags = TextServer::JUSTIFICATION_KASHIDA | TextServer::JUSTIFICATION_WORD_BOUND, TextServer::Direction p_direction = TextServer::DIRECTION_AUTO, TextServer::Orientation p_orientation = TextServer::ORIENTATION_HORIZONTAL) const; void draw_multiline_string(const Ref\u0026lt;Font\u0026gt; \u0026amp;p_font, const Point2 \u0026amp;p_pos, const String \u0026amp;p_text, HorizontalAlignment p_alignment = HORIZONTAL_ALIGNMENT_LEFT, float p_width = -1, int p_font_size = Font::DEFAULT_FONT_SIZE, int p_max_lines = -1, const Color \u0026amp;p_modulate = Color(1.0, 1.0, 1.0), BitField\u0026lt;TextServer::LineBreakFlag\u0026gt; p_brk_flags = TextServer::BREAK_MANDATORY | TextServer::BREAK_WORD_BOUND, BitField\u0026lt;TextServer::JustificationFlag\u0026gt; p_jst_flags = TextServer::JUSTIFICATION_KASHIDA | TextServer::JUSTIFICATION_WORD_BOUND, TextServer::Direction p_direction = TextServer::DIRECTION_AUTO, TextServer::Orientation p_orientation = TextServer::ORIENTATION_HORIZONTAL) const; void draw_string_outline(const Ref\u0026lt;Font\u0026gt; \u0026amp;p_font, const Point2 \u0026amp;p_pos, const String \u0026amp;p_text, HorizontalAlignment p_alignment = HORIZONTAL_ALIGNMENT_LEFT, float p_width = -1, int p_font_size = Font::DEFAULT_FONT_SIZE, int p_size = 1, const Color \u0026amp;p_modulate = Color(1.0, 1.0, 1.0), BitField\u0026lt;TextServer::JustificationFlag\u0026gt; p_jst_flags = TextServer::JUSTIFICATION_KASHIDA | TextServer::JUSTIFICATION_WORD_BOUND, TextServer::Direction p_direction = TextServer::DIRECTION_AUTO, TextServer::Orientation p_orientation = TextServer::ORIENTATION_HORIZONTAL) const; void draw_multiline_string_outline(const Ref\u0026lt;Font\u0026gt; \u0026amp;p_font, const Point2 \u0026amp;p_pos, const String \u0026amp;p_text, HorizontalAlignment p_alignment = HORIZONTAL_ALIGNMENT_LEFT, float p_width = -1, int p_font_size = Font::DEFAULT_FONT_SIZE, int p_max_lines = -1, int p_size = 1, const Color \u0026amp;p_modulate = Color(1.0, 1.0, 1.0), BitField\u0026lt;TextServer::LineBreakFlag\u0026gt; p_brk_flags = TextServer::BREAK_MANDATORY | TextServer::BREAK_WORD_BOUND, BitField\u0026lt;TextServer::JustificationFlag\u0026gt; p_jst_flags = TextServer::JUSTIFICATION_KASHIDA | TextServer::JUSTIFICATION_WORD_BOUND, TextServer::Direction p_direction = TextServer::DIRECTION_AUTO, TextServer::Orientation p_orientation = TextServer::ORIENTATION_HORIZONTAL) const; void draw_char(const Ref\u0026lt;Font\u0026gt; \u0026amp;p_font, const Point2 \u0026amp;p_pos, const String \u0026amp;p_char, int p_font_size = Font::DEFAULT_FONT_SIZE, const Color \u0026amp;p_modulate = Color(1.0, 1.0, 1.0)) const; void draw_char_outline(const Ref\u0026lt;Font\u0026gt; \u0026amp;p_font, const Point2 \u0026amp;p_pos, const String \u0026amp;p_char, int p_font_size = Font::DEFAULT_FONT_SIZE, int p_size = 1, const Color \u0026amp;p_modulate = Color(1.0, 1.0, 1.0)) const; void draw_set_transform(const Point2 \u0026amp;p_offset, real_t p_rot = 0.0, const Size2 \u0026amp;p_scale = Size2(1.0, 1.0)); void draw_set_transform_matrix(const Transform2D \u0026amp;p_matrix); void draw_animation_slice(double p_animation_length, double p_slice_begin, double p_slice_end, double p_offset = 0); void draw_end_animation(); 文本类 Label ✨头文件:#include \u0026quot;scene/gui/label.h\u0026quot; ✨作用:Label是godot提供的UI控件，可以自适应内容的大小\nRichTextLabel ✨头文件:#include \u0026quot;scene/gui/rich_text_label.h\u0026quot;\n✨作用:RichTextLabel是godot提供的UI控件，可以使用BBcode来控制显示的内容，比如设置当行文本颜色等\n✨使用示例:\n1 2 3 screen_output_label-\u0026gt;set_use_bbcode(true);\t//使用bbcode，开启才能正确显示[color=red]XXXX[\\color]的bbcode格式文本 screen_output_label-\u0026gt;set_fit_content(true);\t//自适应文本高度 screen_output_label-\u0026gt;set_autowrap_mode(TextServer::AutowrapMode::AUTOWRAP_OFF);//关闭宽度调整，与上方设置相结合，可以自适应宽高。 按钮类 OptionButton ✨头文件:#include \u0026quot;scene/gui/option_button.h\u0026quot;\n✨作用:OptionButton是Godot中提供的一个GUI控件.其本质是一个Button的派生控件，通过内部包含一个PopupMenu实现下拉功能。有以下作用：\n显示一个下拉菜单。 包含多个可选项（Items），每个 Item 有 文本、图标、ID、可用性。 用户点击后，弹出PopupMenu供选择。 支持回调 \u0026amp; 信号（如 item_selected(int index)）。 ✨使用示例: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 创建 OptionButton option_button = memnew(OptionButton); add_child(option_button); // 添加选项 option_button-\u0026gt;add_item(\u0026#34;Easy\u0026#34;, 1); option_button-\u0026gt;add_item(\u0026#34;Normal\u0026#34;, 2); option_button-\u0026gt;add_icon_item(p_icon,\u0026#34;Hard\u0026#34;, 3); // 选择默认项 option_button-\u0026gt;select(1); // Normal // 绑定信号 option_button-\u0026gt;connect(\u0026#34;item_selected\u0026#34;, Callable(this, \u0026#34;_on_item_selected\u0026#34;)); // 加一个 Label 显示信息 info_label = memnew(Label); info_label-\u0026gt;set_position(Vector2(0, 40)); add_child(info_label); info_label-\u0026gt;set_text(\u0026#34;Selected: Normal\u0026#34;); } // 信号回调 void _on_item_selected(int index) { int id = option_button-\u0026gt;get_item_id(index); String name = option_button-\u0026gt;get_item_text(index); info_label-\u0026gt;set_text(\u0026#34;Selected: \u0026#34; + name + \u0026#34; (ID = \u0026#34; + String::num_int64(id) + \u0026#34;)\u0026#34;); } MenuButton ✨头文件:#include \u0026quot;scene/gui/menu_button.h\u0026quot;\n✨作用:\n✨使用示例:\n弹窗类 AcceptDialog ✨头文件:#include \u0026quot;scene/gui/dialogs.h\n✨作用:AcceptDialog是Godot中最常用的弹出式对话框（Popup）之一，用来向用户显示信息，并提供一个“确认/接受”按钮。\n✔️自带“确认”按钮，用户点击后会发送confirmed信号。 ✔️自带canceled信号。 ✔️可以显示简单的信息，用于提醒用户。 ✨使用示例:\n1 2 3 4 5 6 7 8 9 //初始化 err_dialog = memnew(AcceptDialog); add_child(err_dialog); err_dialog-\u0026gt;get_ok_button()-\u0026gt;set_text(\u0026#34;不ok\u0026#34;); err_dialog-\u0026gt;get_ok_button()-\u0026gt;connect(\u0026#34;pressed\u0026#34;,callable_mp(this, \u0026amp;LyfTestEditor::test_func)); //设置文本，并唤起弹窗 err_dialog-\u0026gt;set_text(\u0026#34;LyfTestEditorPlugin::MENU_OPTION_CREATE_111\u0026#34;); err_dialog-\u0026gt;popup_centered(); ConfirmationDialog 头文件路径：#include \u0026quot;scene/gui/dialogs.h\u0026quot;\nConfirmationDialog是Godot中用于确认/取消操作的标准弹窗（Popup），继承自 AcceptDialog。\n相较于AcceptDialog多了一个cancel按钮，用户点击后会发送canceled信号。\nThread ✨头文件:#include \u0026quot;core/os/thread.h\u0026quot;\n✨作用:Godot 提供的线程类，用于创建和管理线程。具有以下特点:\n跨平台支持：在 Windows、Linux、macOS 等平台上统一接口 轻量级：适合后台任务、数据处理等场景 线程安全：需要配合 Mutex、Semaphore 等同步机制使用 ⚠️ 重要注意事项:\n不要在子线程中直接操作场景树：所有 GUI 操作必须在主线程进行 使用 call_deferred：如果需要在主线程执行代码，使用 call_deferred 或信号机制 避免阻塞主线程：耗时任务放在子线程中执行 ✨使用示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include \u0026#34;core/os/thread.h\u0026#34; #include \u0026#34;core/os/mutex.h\u0026#34; #include \u0026#34;core/os/semaphore.h\u0026#34; class ThreadExample : public Node { GDCLASS(ThreadExample, Node); private: Thread *worker_thread; Mutex *mutex; Semaphore *semaphore; bool thread_active; Vector\u0026lt;int\u0026gt; shared_data; public: ThreadExample() { worker_thread = memnew(Thread); mutex = memnew(Mutex); semaphore = memnew(Semaphore); thread_active = true; } ~ThreadExample() { thread_active = false; semaphore-\u0026gt;post(); // 唤醒线程使其退出 if (worker_thread-\u0026gt;is_started()) { worker_thread-\u0026gt;wait_to_finish(); } memdelete(worker_thread); memdelete(mutex); memdelete(semaphore); } // 线程工作函数 static void _thread_function(void *p_userdata) { ThreadExample *instance = static_cast\u0026lt;ThreadExample *\u0026gt;(p_userdata); while (instance-\u0026gt;thread_active) { // 等待信号（等待任务） instance-\u0026gt;semaphore-\u0026gt;wait(); if (!instance-\u0026gt;thread_active) { break; } // 执行耗时任务（例如数据处理） Vector\u0026lt;int\u0026gt; local_data; { // 加锁访问共享数据 MutexLock lock(instance-\u0026gt;mutex); local_data = instance-\u0026gt;shared_data; } // 处理数据（不涉及 GUI 操作） for (int i = 0; i \u0026lt; local_data.size(); i++) { local_data[i] *= 2; // 示例：数据翻倍 OS::get_singleton()-\u0026gt;delay_usec(1000); // 模拟耗时操作 } // 处理完成后，通知主线程更新 instance-\u0026gt;call_deferred(\u0026#34;_on_thread_complete\u0026#34;, local_data); } } // 启动线程 void start_thread() { ERR_FAIL_COND(worker_thread-\u0026gt;is_started()); worker_thread-\u0026gt;start(_thread_function, this); } // 添加任务（从主线程调用） void add_task(const Vector\u0026lt;int\u0026gt; \u0026amp;data) { MutexLock lock(mutex); shared_data = data; semaphore-\u0026gt;post(); // 唤醒工作线程 } // 线程完成回调（在主线程执行） void _on_thread_complete(const Vector\u0026lt;int\u0026gt; \u0026amp;result) { // 可以安全地操作 GUI print_line(\u0026#34;Thread completed with \u0026#34; + itos(result.size()) + \u0026#34; items\u0026#34;); // 更新 UI 等 for (int i = 0; i \u0026lt; result.size(); i++) { print_line(\u0026#34;Result[\u0026#34; + itos(i) + \u0026#34;] = \u0026#34; + itos(result[i])); } } protected: static void _bind_methods() { ClassDB::bind_method(D_METHOD(\u0026#34;start_thread\u0026#34;), \u0026amp;ThreadExample::start_thread); ClassDB::bind_method(D_METHOD(\u0026#34;add_task\u0026#34;, \u0026#34;data\u0026#34;), \u0026amp;ThreadExample::add_task); ClassDB::bind_method(D_METHOD(\u0026#34;_on_thread_complete\u0026#34;, \u0026#34;result\u0026#34;), \u0026amp;ThreadExample::_on_thread_complete); } }; 线程同步工具 Mutex（互斥锁） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026#34;core/os/mutex.h\u0026#34; Mutex *mutex = memnew(Mutex); // 加锁 mutex-\u0026gt;lock(); // 访问共享资源 critical_section(); // 解锁 mutex-\u0026gt;unlock(); // 使用 RAII 自动管理锁（推荐） { MutexLock lock(mutex); // 构造时自动加锁 critical_section(); } // 析构时自动解锁 Semaphore（信号量） 1 2 3 4 5 6 7 8 9 #include \u0026#34;core/os/semaphore.h\u0026#34; Semaphore *semaphore = memnew(Semaphore); // 等待（阻塞直到有信号） semaphore-\u0026gt;wait(); // 发送信号 semaphore-\u0026gt;post(); 常见使用场景 异步资源加载 1 2 3 4 5 6 7 8 9 10 void load_resources_async() { worker_thread-\u0026gt;start([](void *p_userdata) { // 在子线程中加载资源 Ref\u0026lt;Texture2D\u0026gt; texture = ResourceLoader::load(\u0026#34;res://texture.png\u0026#34;); // 通过信号通知主线程 Node *node = static_cast\u0026lt;Node *\u0026gt;(p_userdata); node-\u0026gt;call_deferred(\u0026#34;_on_resource_loaded\u0026#34;, texture); }, this); } 后台数据处理 1 2 3 4 5 void process_background_task(const Vector\u0026lt;float\u0026gt; \u0026amp;data) { MutexLock lock(mutex); task_queue.push_back(data); semaphore-\u0026gt;post(); // 唤醒工作线程 } 网络请求 1 2 3 4 5 6 7 8 9 10 void fetch_data_async(const String \u0026amp;url) { worker_thread-\u0026gt;start([url](void *p_userdata) { // 执行网络请求 String result = http_request(url); // 返回结果到主线程 Node *node = static_cast\u0026lt;Node *\u0026gt;(p_userdata); node-\u0026gt;call_deferred(\u0026#34;_on_data_received\u0026#34;, result); }, this); } Config GLOBAL_DEF(\u0026ldquo;aaa/ccc/bbb111\u0026rdquo;, false);\n","date":"2025-11-04T16:18:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E4%BA%8Cmodules%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","title":"【godot】二、Modules开发指南"},{"content":"引擎编译 官方源码仓库：godot\n官方godot-cpp仓库：godot-cpp\n编译指令 在Godot_Engine根目录下，执行下方编译指令scons,有以下可选参数\n指定目标平台 ：：platform=windows/android/macos 是否带符号表 ：：debug_symbols=yes/no 构建目标类型 ：：target=editor/template_debug/template_release 是否输出编译指令：：verbose=yes 目标平台芯片架构：：arch=x86_64/arm64v8 是否生成编译json：：compiledb=true 指定编译线程数量：：-j8/-j16 使用 LLVM/Clang 编译器而非 GCC ：：use_llvm=yes/no 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 1.windows平台编译 生成路径：E:\\Godot\\Godot_Engine\\bin 编译路径：E:\\Godot\\Godot_Engine 编译指令：scons compiledb=true debug_symbols=yes verbose=yes -j16 2.android的libgodot_android.so编译 生成路径：E:\\Godot\\Godot_Engine\\platform\\android\\java\\lib\\libs\\debug\\arm64-v8a 编译路径：E:\\Godot\\Godot_Engine 编译指令：scons platform=android target=template_debug debug_symbols=yes compiledb=true 或scons platform=android store_release=true production=true dev_mode=false dev_build=false debug_symbols=true tests=false target=template_release arch=arm64 compiledb=true 3.生成Android导出模板 前置生成： 生成debug的so：scons platform=android target=template_debug arch=arm64 dev_build=yes generate_android_binaries=yes 生成release的so：scons platform=android target=template_release arch=arm64 dev_build=yes generate_android_binaries=yes 生成路径：E:\\Godot\\Godot_Engine\\bin\\android_release.apk 编译路径：E:\\Godot\\Godot_Engine\\platform\\android\\java 编译指令：./gradlew.bat generateGodotTemplates 4.android的aar的编译，godot-lib.template_debug.aar 生成路径：E:\\Godot\\Godot_Engine\\platform\\android\\java\\lib\\build\\outputs\\aar 编译路径：E:\\Godot\\Godot_Engine\\platform\\android\\java 编译指令：gradlew.bat :lib:bundleTemplateDebugAar 5.生成sln文件 scons vsproj=yes 6.生成GDExtension的胶水代码 1. 编译extension_api.json文件： bin\\godot.windows.editor.x86_64.exe --dump-extension-api 2. 在godot-cpp中执行代码生成： scons debug_symbols=yes verbose=yes generate_bindings=yes custom_api_file=E:\\Godot\\godot-cpp\\gdextension\\extension_api.json 7.导出资源包zip/pck 生成路径：${YourProjectPath} 编译路径：${YourProjectPath} 1. E:\\Godot\\Godot_Engine\\bin\\godot.windows.editor.x86_64.exe --headless --export-pack \u0026#34;Android\u0026#34; game.zip 2. E:\\Godot\\Godot_Engine\\bin\\godot.windows.editor.x86_64.exe --headless --export-pack \u0026#34;Android\u0026#34; game.pck 运行指令 1 2 3 4 5 //运行编辑器 \u0026#34;godot.exe --path ${PgmPath} -v -e\u0026#34; //直接运行runtime \u0026#34;godot.exe --path ${PgmPath} -v\u0026#34; JNI路径 文件路径：E:\\Godot\\Godot_Engine\\platform\\android\\java_godot_lib_jni.h\n模块(Module)开发 参考文档：自定义 C++ 模块 — Godot Engine (4.x) 简体中文文档\n文件及结构 新建一个模块需要以下文件及结构，存放在E:\\Godot\\Godot_Engine\\modules目录底下 。\n在E:\\Godot\\Godot_Engine\\modules\\register_module_types.gen.cpp文件中，会根据我们模块中的SCsub文件，自动生成实际的模块注册代码，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //register_module_types.gen.cpp 中自动生成的代码，用于模块的实际注册。 #include \u0026#34;modules/ns_test_module/register_types.h\u0026#34; //... #ifdef MODULE_NS_TEST_MODULE_ENABLED initialize_ns_test_module_module(p_level); #endif //... #ifdef MODULE_NS_TEST_MODULE_ENABLED uninitialize_ns_test_module_module(p_level); #endif SCsub和config.py SCsub是这个模块的编译指令，包括源码的收集、头文件路径添加、静态库的链接等。\n与config.py结合使用，可以动态的管理该模块的编译选项，以及将该模块自动的生成到E:\\Godot\\Godot_Engine\\modules\\register_module_types.gen.cpp进行模块的注册。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #====SCsub====== from misc.utility.scons_hints import * Import(\u0026#34;env\u0026#34;) Import(\u0026#34;env_modules\u0026#34;) env_nstest = env_modules.Clone() # 添加第三方库的头文件路径 env.Append(CPPPATH=[\u0026#34;#modules/matrix_data_pipeline/include\u0026#34;]) env.Append(CPPPATH=[\u0026#34;#modules/matrix_data_pipeline/include/NSCppData\u0026#34;]) env.Append(CPPPATH=[\u0026#34;#modules/matrix_data_pipeline/include/NSCppData/ProtoGen\u0026#34;]) # 添加库文件路径 if env[\u0026#34;platform\u0026#34;] == \u0026#34;windows\u0026#34;: env.Append(LIBPATH=[\u0026#34;#modules/matrix_data_pipeline/lib/windows\u0026#34;]) env.Append(LIBS=[\u0026#34;NSCppData\u0026#34;,\u0026#34;libprotobuf\u0026#34;]) elif env[\u0026#34;platform\u0026#34;] == \u0026#34;android\u0026#34;: env.Append(LIBPATH=[\u0026#34;#modules/matrix_data_pipeline/lib/android\u0026#34;]) env.Append(LIBS=[\u0026#34;mylib\u0026#34;]) # Godot source files module_obj = [] env_nstest.add_source_files(module_obj, \u0026#34;*.cpp\u0026#34;) # env_nstest.add_source_files(module_obj, \u0026#34;editor/*.cpp\u0026#34;) env.modules_sources += module_obj 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #====config.py====== def can_build(env, platform): return True def configure(env): pass # def get_doc_classes(): # return [ # \u0026#34;OggPacketSequence\u0026#34;, # \u0026#34;OggPacketSequencePlayback\u0026#34;, # ] # def get_doc_path(): # return \u0026#34;doc_classes\u0026#34; register_types 该文件负责对自身模块中声明的godot类型进行类型注册，同时也可以在相对较早的阶段（main函数的setup阶段）进行一些单例类的实例化。 如果在进行编辑器工具类的开发，则工具类的实例化和注册，也是在该阶段进行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //==============register_types.h============ #ifndef NSTEST_REGISTER_TYPES_H #define NSTEST_REGISTER_TYPES_H #include \u0026#34;modules/register_module_types.h\u0026#34; void initialize_ns_test_module_module(ModuleInitializationLevel p_level); void uninitialize_ns_test_module_module(ModuleInitializationLevel p_level); #endif //==============register_types.cpp============ #include \u0026#34;register_types.h\u0026#34; #include \u0026#34;core/object/object.h\u0026#34; #include \u0026#34;ns_test_module.h\u0026#34; void initialize_ns_test_module_module(ModuleInitializationLevel p_level) { if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) { return; } GDREGISTER_CLASS(NsTestModule) //注册类型 GDREGISTER_CLASS(NsTestResource) } void uninitialize_ns_test_module_module(ModuleInitializationLevel p_level) { if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) { return; } } GDExtension开发 参考文档：入门 — Godot Engine (4.x) 简体中文文档\n对于GDExtension中编写的c++代码，需要进行特定的注册和编译流程，才能形成给godot用的动态链接库\n项目组织结构 对于带GDExtension的godot项目，它具有以下的基本结构\nexample.gdextension 1 2 3 4 5 6 7 8 9 10 11 12 [configuration] //注意此处的entry_symbol名，应该与regisiter_types中的入口函数名保持一致 entry_symbol = \u0026#34;GodotTest_library_init\u0026#34; compatibility_minimum = \u0026#34;4.1\u0026#34; reloadable = true [libraries] windows.debug.x86_64 = \u0026#34;res://bin/GodotTest.windows.template_debug.x86_64.dll\u0026#34; android.debug.arm64 = \u0026#34;res://bin/GodotTest.android.template_release.arm64.so\u0026#34; android.arm64 = \u0026#34;res://bin/GodotTest.android.template_release.arm64.so\u0026#34; register_types 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 /* godot-cpp integration testing project. * * This is free and unencumbered software released into the public domain. */ #include \u0026#34;register_types.h\u0026#34; #include \u0026lt;gdextension_interface.h\u0026gt; #include \u0026lt;godot_cpp/core/class_db.hpp\u0026gt; #include \u0026lt;godot_cpp/core/defs.hpp\u0026gt; #include \u0026lt;godot_cpp/godot.hpp\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026#34;godot_cpp/classes/editor_interface.hpp\u0026#34; #include \u0026#34;godot_cpp/classes/editor_plugin.hpp\u0026#34; #include \u0026#34;godot_cpp/variant/utility_functions.hpp\u0026#34; #include \u0026#34;Test/Fow.h\u0026#34; // Spline #include \u0026#34;Spline/Spline.h\u0026#34; #include \u0026#34;Spline/SplineGizmo.h\u0026#34; #include \u0026#34;Spline/SplineGizmoPlugin.h\u0026#34; //Profiler #include \u0026#34;ProfilerLib/ProfilerUI.h\u0026#34; #include \u0026#34;ProfilerLib/ProfilerTest.h\u0026#34; using namespace godot; class MyEditorPlugin : public EditorPlugin { GDCLASS(MyEditorPlugin, EditorPlugin); Ref\u0026lt;SplineGizmoPlugin\u0026gt; gizmo_plugin; protected: static void _bind_methods() { } public: virtual void _enter_tree() override { UtilityFunctions::print(\u0026#34;Init :: MyEditorPlugin :: _enter_tree\u0026#34;); gizmo_plugin.instantiate(); gizmo_plugin-\u0026gt;create_handle_material(\u0026#34;HandleMat\u0026#34;); gizmo_plugin-\u0026gt;create_material(\u0026#34;RedMat\u0026#34;, Color(1.0f, 0.0f, 0.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;GreenMat\u0026#34;, Color(0.0f, 1.0f, 0.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;BlueMat\u0026#34;, Color(0.0f, 0.0f, 1.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;Color1\u0026#34;, Color(0.0f, 1.0f, 1.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;Color2\u0026#34;, Color(1.0f, 0.0f, 1.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;Color3\u0026#34;, Color(1.0f, 1.0f, 0.0f)); gizmo_plugin-\u0026gt;create_material(\u0026#34;Color4\u0026#34;, Color(1.0f, 1.0f, 1.0f)); add_node_3d_gizmo_plugin(gizmo_plugin); } virtual void _exit_tree() override { UtilityFunctions::print(\u0026#34;UnInit :: MyEditorPlugin :: _exit_tree\u0026#34;); remove_node_3d_gizmo_plugin(gizmo_plugin); } }; void initialize_GodotTest_module(ModuleInitializationLevel p_level) { if (p_level == MODULE_INITIALIZATION_LEVEL_SCENE) { UtilityFunctions::print(\u0026#34;Init :: Scene\u0026#34;); GDREGISTER_CLASS(FowTexture); GDREGISTER_CLASS(Spline); GDREGISTER_CLASS(ProfilerContext); GDREGISTER_CLASS(ProfilerUI); GDREGISTER_CLASS(ProfilerTest); } if (p_level == MODULE_INITIALIZATION_LEVEL_EDITOR) { UtilityFunctions::print(\u0026#34;Init :: Editor\u0026#34;); GDREGISTER_CLASS(SplineGizmo); GDREGISTER_CLASS(SplineGizmoPlugin); GDREGISTER_CLASS(MyEditorPlugin); EditorPlugins::add_by_type\u0026lt;MyEditorPlugin\u0026gt;(); } UtilityFunctions::print(\u0026#34;Init :: None :: \u0026#34;, p_level); } void uninitialize_GodotTest_module(ModuleInitializationLevel p_level) { if (p_level == MODULE_INITIALIZATION_LEVEL_SCENE) { UtilityFunctions::print(\u0026#34;UnInit :: Scene\u0026#34;); // return; } if (p_level == MODULE_INITIALIZATION_LEVEL_EDITOR) { UtilityFunctions::print(\u0026#34;UnInit :: Editor\u0026#34;); EditorPlugins::remove_by_type\u0026lt;MyEditorPlugin\u0026gt;(); // return; } } extern \u0026#34;C\u0026#34; { // Initialization. GDExtensionBool GDE_EXPORT GodotTest_library_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization) { godot::GDExtensionBinding::InitObject init_obj(p_get_proc_address, p_library, r_initialization); init_obj.register_initializer(initialize_GodotTest_module); init_obj.register_terminator(uninitialize_GodotTest_module); init_obj.set_minimum_library_initialization_level( MODULE_INITIALIZATION_LEVEL_SCENE); return init_obj.init(); } } SConstruct SConstruct用于配置GDExtension的编译环境，\n可以指定编译的中间文件的放置路径， 以及最终输出的链接库的名称和位置 还有引入的三方库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python import os import sys def log_env(env,key): print(f\u0026#34;{key}:{env[key]}\u0026#34;) env = SConscript(\u0026#34;godot-cpp/SConstruct\u0026#34;) project_name = \u0026#34;Godot_DemoSR\u0026#34; # For reference: # - CCFLAGS are compilation flags shared between C and C++ # - CFLAGS are for C-specific compilation flags # - CXXFLAGS are for C++-specific compilation flags # - CPPFLAGS are for pre-processor flags # - CPPDEFINES are for pre-processor defines # - LINKFLAGS are for linking flags # tweak this if you want to use different folders, or more folders, to store your source code in. env.VariantDir(\u0026#39;build\u0026#39;, \u0026#39;src\u0026#39;, duplicate=0) env.Append(CPPPATH=[\u0026#34;build/\u0026#34;]) sources = Glob(\u0026#34;build/*.cpp\u0026#34;) + Glob(\u0026#34;build/**/*.cpp\u0026#34;) + Glob(\u0026#34;build/**/**/*.cpp\u0026#34;) if env[\u0026#34;platform\u0026#34;] == \u0026#34;macos\u0026#34;: library = env.SharedLibrary( \u0026#34;{}/bin/libgdDemoSR.{}.{}.framework/libgdDemoSR.{}.{}\u0026#34;.format( project_name, env[\u0026#34;platform\u0026#34;], env[\u0026#34;target\u0026#34;], env[\u0026#34;platform\u0026#34;], env[\u0026#34;target\u0026#34;] ), source=sources, ) elif env[\u0026#34;platform\u0026#34;] == \u0026#34;windows\u0026#34;: env[\u0026#34;CXXFLAGS\u0026#34;].remove(\u0026#34;/std:c++17\u0026#34;) env.Append(CXXFLAGS = [\u0026#34;/std:c++20\u0026#34;,\u0026#34;/W4\u0026#34;, \u0026#34;/WX\u0026#34;, \u0026#34;/wd4100\u0026#34;,\u0026#34;/wd4244\u0026#34;,\u0026#34;/wd4305\u0026#34;,\u0026#34;/wd4201\u0026#34;,\u0026#34;/wd4127\u0026#34;,\u0026#34;/wd4267\u0026#34;,\u0026#34;/wd5054\u0026#34;,\u0026#34;/wd4996\u0026#34;,\u0026#34;/Zi\u0026#34;,\u0026#34;/FS\u0026#34;]) env.Append(LIBS = [\u0026#34;libzmq\u0026#34;]) env.Append(CPPDEFINES=[\u0026#34;ZMQ_STATIC\u0026#34;]) env.Append(LIBPATH = [\u0026#34;./lib/windows\u0026#34;]) library = env.SharedLibrary( \u0026#34;{}/bin/libgdDemoSR{}{}\u0026#34;.format(project_name, env[\u0026#34;suffix\u0026#34;], env[\u0026#34;SHLIBSUFFIX\u0026#34;]), source=sources, ) elif env[\u0026#34;platform\u0026#34;] == \u0026#34;android\u0026#34;: env[\u0026#34;CXXFLAGS\u0026#34;].remove(\u0026#34;-std=c++17\u0026#34;) env[\u0026#34;CXXFLAGS\u0026#34;].remove(\u0026#34;-fno-exceptions\u0026#34;) # env[\u0026#34;CXX\u0026#34;] = env[\u0026#34;CXX\u0026#34;].replace(\u0026#34;23.2.8568313\u0026#34;,\u0026#34;27.0.12077973\u0026#34;) env.Append(CXXFLAGS = [\u0026#34;-std=c++20\u0026#34;,\u0026#34;-fexceptions\u0026#34;,\u0026#39;-Wall\u0026#39;, \u0026#39;-Wextra\u0026#39;, \u0026#39;-Werror\u0026#39;,\u0026#34;-Wno-unused-parameter\u0026#34;]) env.Append(LIBS = [\u0026#34;libzmq\u0026#34;,\u0026#34;GLESv3\u0026#34;]) env.Append(CPPDEFINES=[\u0026#34;ZMQ_STATIC\u0026#34;,\u0026#34;NS_ANDROID\u0026#34;]) env.Append(LIBPATH = [\u0026#34;./lib/android\u0026#34;]) library = env.SharedLibrary( \u0026#34;{}/bin/libgdDemoSR{}{}\u0026#34;.format(project_name, env[\u0026#34;suffix\u0026#34;], env[\u0026#34;SHLIBSUFFIX\u0026#34;]), source=sources, ) else: env[\u0026#34;CXXFLAGS\u0026#34;].remove(\u0026#34;-std=c++17\u0026#34;) env[\u0026#34;CXXFLAGS\u0026#34;].remove(\u0026#34;-fno-exceptions\u0026#34;) env.Append(CXXFLAGS = [\u0026#34;-std=c++20\u0026#34;,\u0026#34;-fexceptions\u0026#34;,\u0026#39;-Wall\u0026#39;, \u0026#39;-Wextra\u0026#39;, \u0026#34;-Wno-unused-parameter\u0026#34;,\u0026#34;-Wno-changes-meaning\u0026#34;]) env.Append(LIBS = [\u0026#34;libzmq\u0026#34;,\u0026#34;GLESv3\u0026#34;]) env.Append(CPPDEFINES=[\u0026#34;ZMQ_STATIC\u0026#34;]) env.Append(LIBPATH = [\u0026#34;./lib\u0026#34;]) library = env.SharedLibrary( \u0026#34;{}/bin/libgdDemoSR{}{}\u0026#34;.format(project_name, env[\u0026#34;suffix\u0026#34;], env[\u0026#34;SHLIBSUFFIX\u0026#34;]), source=sources, ) Default(library) ","date":"2025-11-04T16:08:31+08:00","image":"https://Liyufei1.github.io/guidao4.jpg","permalink":"https://Liyufei1.github.io/p/godot%E4%B8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%8F%8A%E7%A4%BA%E4%BE%8B/","title":"【godot】一、开发环境部署及示例"},{"content":"前置工具 网站前端工具-hugo软件 ：hugo hugo主题下载线仓库：hugo-theme 参考教程：教程 hugo hugo指令 下方列举了hugo常用指令\n1 2 3 4 5 6 7 8 9 // 创建新站点 hugo new site myblog // 启动服务 hugo server -D hugo server --buildDrafts // 生成新的页面 hugo new Content \u0026#34;posts/new-post.md\u0026#34; hugo.yaml hugo.yaml是hugo网站的配置文件，在其中我们可以配置网站的标题、描述、作者、主题等等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //配置每页文章数量 pagination: pagerSize: 3 //配置链接 baseurl: https://example.com/ //页面标签的小图标设置 favicon: /favicon.png article: math: true //数学公式 toc: true //目录 readingTime: true //阅读时间 license: enabled: true //许可说明 default: Licensed under [Liyufei1](https://github.com/Liyufei1) markdown语法 官方文档链接： markdown语法\n下方为常用的语法，可以快速生成\n常用 名称 语法 示例 加粗 \u0026quot; **加粗** \u0026quot; 加粗 倾斜 \u0026quot; *倾斜* \u0026quot; 倾斜 删除线 \u0026quot; ~~删除线~~ \u0026quot; 删除线 代码块 \u0026quot; ```shell 代码块\n``` \u0026quot; shell 代码块 代码行 \u0026quot; `代码行` \u0026quot; 代码行 标题 \u0026quot; # 标题 \u0026quot; # 标题 序列 \u0026quot; 1. 序列 \u0026quot; 1. 序列 无序序列 \u0026quot; - 无序序列 \u0026quot; - 无序序列 引用 \u0026quot; \u0026gt; 引用 \u0026quot; \u0026gt; 引用 链接 \u0026quot; [链接](https://www.baidu.com) \u0026quot; 链接 列表 效果如下：\n左对齐 居中 右对齐 a b c 1 2 3 代码如下：\n1 2 3 4 | 左对齐 | 居中 | 右对齐 | |:-------|:----:|-------:| | a | b | c | | 1 | 2 | 3 | 图片 ![图片说明](guidao2.jpg)\n步骤 创建本地新站点 运行命令hugo new site dev，利用hugo创建本地新站点。创建完成后，可以运行命令hugo server -D来运行新建的站点，在浏览器中可以验证是否创建成功。 到上hugo-theme下载中意的主题（本博客采用stack），将下载的主题复制到新站点的themes文件夹下。 此时执行命令hugo server -D启动服务，在浏览器中访问本地地址，可以看到新建的模板网页 部署到github 运行指令hugo -D利用hugo构建静态网页，此时在我们的本地网站文件夹下方，可以看到生成了一个名为public的文件夹，里面存放了静态网页。 创建github仓库，需要注意仓库命名为：\u0026lt;github用户名\u0026gt;.github.io，只有按照这个规范命名，github才会将静态网页部署到githubPages中。 将public文件夹下的所有文件上传到步骤2中创建的github仓库中。然后在仓库中运行Pages配置，等待一段时间，即可看到静态网页。 githug的自动构建 创建github仓库，此仓库建议为私有仓库，用于保存本地的hugo网站，即真正的博客仓库（上方发布的仅为静态网页仓库）。 创建.github/workflows/hugo.yml文件，并添加以下内容：\n需要注意的是TOKEN为github的token，需要在github的setting中创建。同时注意同步的分支。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 name: deploy on: push: branches: - master jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.TOKEN }} EXTERNAL_REPOSITORY: Liyufei1/Liyufei1.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: auto deploy 在github中创建TOKEN，并添加到blog仓库中。创建token时需要勾选repo权限以及workflow权限。创建完毕后，在blog仓库中配置该TOKEN。后续有代码提交时，就会自动构建静态网页并部署到githubPages中。 ","date":"2025-11-03T16:08:31+08:00","image":"https://Liyufei1.github.io/p/blog-build/guidao3_hu_b29969dabc11fbc2.jpg","permalink":"https://Liyufei1.github.io/p/blog-build/","title":"Blog Build"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://Liyufei1.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_7d5f5b09f91c89db.jpg","permalink":"https://Liyufei1.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://Liyufei1.github.io/p/math-typesetting/","title":"Math Typesetting"}]